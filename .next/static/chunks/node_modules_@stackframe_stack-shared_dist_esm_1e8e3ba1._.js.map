{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/globals.tsx"],"sourcesContent":["const globalVar: any =\n  typeof globalThis !== 'undefined' ? globalThis :\n    typeof global !== 'undefined' ? global :\n      typeof window !== 'undefined' ? window :\n        typeof self !== 'undefined' ? self :\n          {};\nexport {\n  globalVar\n};\n\nif (typeof globalThis === 'undefined') {\n  (globalVar as any).globalThis = globalVar;\n}\n\nconst stackGlobalsSymbol = Symbol.for('__stack-globals');\nglobalVar[stackGlobalsSymbol] ??= {};\n\nexport function createGlobal<T>(key: string, init: () => T) {\n  if (!globalVar[stackGlobalsSymbol][key]) {\n    globalVar[stackGlobalsSymbol][key] = init();\n  }\n  return globalVar[stackGlobalsSymbol][key] as T;\n}\n"],"names":[],"mappings":";;;;;gBAeU,kBAAkB;AAf5B,IAAM,YACJ,OAAO,eAAe,cAAc,aAClC,OAAO,WAAW,cAAc,qDAC9B,OAAO,WAAW,cAAc,SAC9B,OAAO,SAAS,cAAc,OAC5B,CAAC;AAKX,IAAI,OAAO,eAAe,aAAa;IACpC,UAAkB,UAAA,GAAa;AAClC;AAEA,IAAM,qBAAqB,OAAO,GAAA,CAAI,iBAAiB;;6BACvD,0CAA4B,iCAA5B,UAAA,qBAA4B,GAAM,CAAC;AAE5B,SAAS,aAAgB,GAAA,EAAa,IAAA,EAAe;IAC1D,IAAI,CAAC,SAAA,CAAU,kBAAkB,CAAA,CAAE,GAAG,CAAA,EAAG;QACvC,SAAA,CAAU,kBAAkB,CAAA,CAAE,GAAG,CAAA,GAAI,KAAK;IAC5C;IACA,OAAO,SAAA,CAAU,kBAAkB,CAAA,CAAE,GAAG,CAAA;AAC1C","debugId":null}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/compile-time.tsx"],"sourcesContent":["/**\n * Returns the first argument passed to it, but compilers won't be able to optimize it out. This is useful in some\n * cases where compiler warnings go awry; for example, when importing things that may not exist (but are guaranteed\n * to exist at runtime).\n */\nexport function scrambleDuringCompileTime<T>(t: T): T {\n  if (Math.random() < 0.00001 && Math.random() > 0.99999 && Math.random() < 0.00001 && Math.random() > 0.99999) {\n    return \"this will never happen\" as any;\n  }\n  return t;\n}\n"],"names":[],"mappings":";;;;AAKO,SAAS,0BAA6B,CAAA,EAAS;IACpD,IAAI,KAAK,MAAA,CAAO,IAAI,QAAW,KAAK,MAAA,CAAO,IAAI,WAAW,KAAK,MAAA,CAAO,IAAI,QAAW,KAAK,MAAA,CAAO,IAAI,SAAS;QAC5G,OAAO;IACT;IACA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/functions.tsx"],"sourcesContent":["export function identity<T>(t: T): T {\n  return t;\n}\nundefined?.test(\"identity\", ({ expect }) => {\n  expect(identity(1)).toBe(1);\n  expect(identity(\"test\")).toBe(\"test\");\n  expect(identity(null)).toBe(null);\n  expect(identity(undefined)).toBe(undefined);\n  const obj = { a: 1 };\n  expect(identity(obj)).toBe(obj);\n});\n\nexport function identityArgs<T extends any[]>(...args: T): T {\n  return args;\n}\nundefined?.test(\"identityArgs\", ({ expect }) => {\n  expect(identityArgs()).toEqual([]);\n  expect(identityArgs(1)).toEqual([1]);\n  expect(identityArgs(1, 2, 3)).toEqual([1, 2, 3]);\n  expect(identityArgs(\"a\", \"b\", \"c\")).toEqual([\"a\", \"b\", \"c\"]);\n  expect(identityArgs(null, undefined)).toEqual([null, undefined]);\n});\n"],"names":[],"mappings":";;;;;AAAO,SAAS,SAAY,CAAA,EAAS;IACnC,OAAO;AACT;AAUO,SAAS;IAAA,IAAA,IAAA,OAAA,UAAA,QAAA,OAAA,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;QAAiC,KAAjC,QAAA,SAAA,CAAA,KAAiC,EAAY;;IAC3D,OAAO;AACT","debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/math.tsx"],"sourcesContent":["/**\n * Similar to the modulo operator, but always returns a positive number (even when the input is negative).\n */\nexport function remainder(n: number, d: number): number {\n  return ((n % d) + Math.abs(d)) % d;\n}\nundefined?.test(\"remainder\", ({ expect }) => {\n  expect(remainder(10, 3)).toBe(1);\n  expect(remainder(10, 5)).toBe(0);\n  expect(remainder(10, 7)).toBe(3);\n  // Test with negative numbers\n  expect(remainder(-10, 3)).toBe(2);\n  expect(remainder(-5, 2)).toBe(1);\n  expect(remainder(-7, 4)).toBe(1);\n  // Test with decimal numbers\n  expect(remainder(10.5, 3)).toBeCloseTo(1.5);\n  expect(remainder(-10.5, 3)).toBeCloseTo(1.5);\n});\n"],"names":[],"mappings":";;;;AAGO,SAAS,UAAU,CAAA,EAAW,CAAA,EAAmB;IACtD,OAAA,CAAS,IAAI,IAAK,KAAK,GAAA,CAAI,CAAC,CAAA,IAAK;AACnC","debugId":null}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/arrays.tsx"],"sourcesContent":["import { remainder } from \"./math\";\n\nexport function typedIncludes<T extends readonly any[]>(arr: T, item: unknown): item is T[number] {\n  return arr.includes(item);\n}\nundefined?.test(\"typedIncludes\", ({ expect }) => {\n  const arr = [1, 2, 3] as const;\n  expect(typedIncludes(arr, 1)).toBe(true);\n  expect(typedIncludes(arr, 4)).toBe(false);\n  expect(typedIncludes(arr, \"1\")).toBe(false);\n\n  const strArr = [\"a\", \"b\", \"c\"] as const;\n  expect(typedIncludes(strArr, \"a\")).toBe(true);\n  expect(typedIncludes(strArr, \"d\")).toBe(false);\n});\n\nexport function enumerate<T extends readonly any[]>(arr: T): [number, T[number]][] {\n  return arr.map((item, index) => [index, item]);\n}\nundefined?.test(\"enumerate\", ({ expect }) => {\n  expect(enumerate([])).toEqual([]);\n  expect(enumerate([1, 2, 3])).toEqual([[0, 1], [1, 2], [2, 3]]);\n  expect(enumerate([\"a\", \"b\", \"c\"])).toEqual([[0, \"a\"], [1, \"b\"], [2, \"c\"]]);\n});\n\nexport function isShallowEqual(a: readonly any[], b: readonly any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\nundefined?.test(\"isShallowEqual\", ({ expect }) => {\n  expect(isShallowEqual([], [])).toBe(true);\n  expect(isShallowEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  expect(isShallowEqual([1, 2, 3], [1, 2, 4])).toBe(false);\n  expect(isShallowEqual([1, 2, 3], [1, 2])).toBe(false);\n  expect(isShallowEqual([1, 2], [1, 2, 3])).toBe(false);\n  // Test with objects (reference equality)\n  const obj1 = { a: 1 };\n  const obj2 = { a: 1 };\n  expect(isShallowEqual([obj1], [obj1])).toBe(true);\n  expect(isShallowEqual([obj1], [obj2])).toBe(false);\n});\n\n/**\n * Ponyfill for ES2023's findLastIndex.\n */\nexport function findLastIndex<T>(arr: readonly T[], predicate: (item: T) => boolean): number {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) return i;\n  }\n  return -1;\n}\nundefined?.test(\"findLastIndex\", ({ expect }) => {\n  expect(findLastIndex([], () => true)).toBe(-1);\n  expect(findLastIndex([1, 2, 3, 4, 5], x => x % 2 === 0)).toBe(3); // 4 is at index 3\n  expect(findLastIndex([1, 2, 3, 4, 5], x => x > 10)).toBe(-1);\n  expect(findLastIndex([1, 2, 3, 2, 1], x => x === 2)).toBe(3);\n  expect(findLastIndex([1, 2, 3], x => x === 1)).toBe(0);\n});\n\nexport function groupBy<T extends any, K>(\n  arr: Iterable<T>,\n  key: (item: T) => K,\n): Map<K, T[]> {\n  const result = new Map<K, T[]>;\n  for (const item of arr) {\n    const k = key(item);\n    if (result.get(k) === undefined) result.set(k, []);\n    result.get(k)!.push(item);\n  }\n  return result;\n}\nundefined?.test(\"groupBy\", ({ expect }) => {\n  expect(groupBy([], (x) => x)).toEqual(new Map());\n\n  const numbers = [1, 2, 3, 4, 5, 6];\n  const grouped = groupBy(numbers, (n) => n % 2 === 0 ? \"even\" : \"odd\");\n  expect(grouped.get(\"even\")).toEqual([2, 4, 6]);\n  expect(grouped.get(\"odd\")).toEqual([1, 3, 5]);\n\n  // Check the actual lengths of the words to ensure our test is correct\n  const words = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"];\n\n  const byLength = groupBy(words, (w) => w.length);\n  // Adjust expectations based on actual word lengths\n  expect(byLength.get(5)).toEqual([\"apple\"]);\n  expect(byLength.get(6)).toEqual([\"banana\", \"cherry\"]);\n  expect(byLength.get(4)).toEqual([\"date\"]);\n  expect(byLength.get(10)).toEqual([\"elderberry\"]);\n});\n\nexport function range(endExclusive: number): number[];\nexport function range(startInclusive: number, endExclusive: number): number[];\nexport function range(startInclusive: number, endExclusive: number, step: number): number[];\nexport function range(startInclusive: number, endExclusive?: number, step?: number): number[] {\n  if (endExclusive === undefined) {\n    endExclusive = startInclusive;\n    startInclusive = 0;\n  }\n  if (step === undefined) step = 1;\n\n  const result = [];\n  for (let i = startInclusive; step > 0 ? (i < endExclusive) : (i > endExclusive); i += step) {\n    result.push(i);\n  }\n  return result;\n}\nundefined?.test(\"range\", ({ expect }) => {\n  expect(range(5)).toEqual([0, 1, 2, 3, 4]);\n  expect(range(2, 5)).toEqual([2, 3, 4]);\n  expect(range(1, 10, 2)).toEqual([1, 3, 5, 7, 9]);\n  expect(range(5, 0, -1)).toEqual([5, 4, 3, 2, 1]);\n  expect(range(0, 0)).toEqual([]);\n  expect(range(0, 10, 3)).toEqual([0, 3, 6, 9]);\n});\n\n\nexport function rotateLeft(arr: readonly any[], n: number): any[] {\n  if (arr.length === 0) return [];\n  const index = remainder(n, arr.length);\n  return [...arr.slice(index), ...arr.slice(0, index)];\n}\nundefined?.test(\"rotateLeft\", ({ expect }) => {\n  expect(rotateLeft([], 1)).toEqual([]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 0)).toEqual([1, 2, 3, 4, 5]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 1)).toEqual([2, 3, 4, 5, 1]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 3)).toEqual([4, 5, 1, 2, 3]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 5)).toEqual([1, 2, 3, 4, 5]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 6)).toEqual([2, 3, 4, 5, 1]);\n});\n\nexport function rotateRight(arr: readonly any[], n: number): any[] {\n  return rotateLeft(arr, -n);\n}\nundefined?.test(\"rotateRight\", ({ expect }) => {\n  expect(rotateRight([], 1)).toEqual([]);\n  expect(rotateRight([1, 2, 3, 4, 5], 0)).toEqual([1, 2, 3, 4, 5]);\n  expect(rotateRight([1, 2, 3, 4, 5], 1)).toEqual([5, 1, 2, 3, 4]);\n  expect(rotateRight([1, 2, 3, 4, 5], 3)).toEqual([3, 4, 5, 1, 2]);\n  expect(rotateRight([1, 2, 3, 4, 5], 5)).toEqual([1, 2, 3, 4, 5]);\n  expect(rotateRight([1, 2, 3, 4, 5], 6)).toEqual([5, 1, 2, 3, 4]);\n});\n\n\nexport function shuffle<T>(arr: readonly T[]): T[] {\n  const result = [...arr];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}\nundefined?.test(\"shuffle\", ({ expect }) => {\n  // Test empty array\n  expect(shuffle([])).toEqual([]);\n\n  // Test single element array\n  expect(shuffle([1])).toEqual([1]);\n\n  // Test that shuffle returns a new array\n  const original = [1, 2, 3, 4, 5];\n  const shuffled = shuffle(original);\n  expect(shuffled).not.toBe(original);\n\n  // Test that all elements are preserved\n  expect(shuffled.sort((a, b) => a - b)).toEqual(original);\n\n  // Test with a larger array to ensure randomness\n  // This is a probabilistic test, but it's very unlikely to fail\n  const large = Array.from({ length: 100 }, (_, i) => i);\n  const shuffledLarge = shuffle(large);\n  expect(shuffledLarge).not.toEqual(large);\n  expect(shuffledLarge.sort((a, b) => a - b)).toEqual(large);\n});\n\n\nexport function outerProduct<T, U>(arr1: readonly T[], arr2: readonly U[]): [T, U][] {\n  return arr1.flatMap((item1) => arr2.map((item2) => [item1, item2] as [T, U]));\n}\nundefined?.test(\"outerProduct\", ({ expect }) => {\n  expect(outerProduct([], [])).toEqual([]);\n  expect(outerProduct([1], [])).toEqual([]);\n  expect(outerProduct([], [1])).toEqual([]);\n  expect(outerProduct([1], [2])).toEqual([[1, 2]]);\n  expect(outerProduct([1, 2], [3, 4])).toEqual([[1, 3], [1, 4], [2, 3], [2, 4]]);\n  expect(outerProduct([\"a\", \"b\"], [1, 2])).toEqual([[\"a\", 1], [\"a\", 2], [\"b\", 1], [\"b\", 2]]);\n});\n\nexport function unique<T>(arr: readonly T[]): T[] {\n  return [...new Set(arr)];\n}\nundefined?.test(\"unique\", ({ expect }) => {\n  expect(unique([])).toEqual([]);\n  expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  expect(unique([1, 2, 2, 3, 1, 3])).toEqual([1, 2, 3]);\n  // Test with objects (reference equality)\n  const obj = { a: 1 };\n  expect(unique([obj, obj])).toEqual([obj]);\n  // Test with different types\n  expect(unique([1, \"1\", true, 1, \"1\", true])).toEqual([1, \"1\", true]);\n});\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,SAAS,iBAAiB;;AAEnB,SAAS,cAAwC,GAAA,EAAQ,IAAA,EAAkC;IAChG,OAAO,IAAI,QAAA,CAAS,IAAI;AAC1B;AAYO,SAAS,UAAoC,GAAA,EAA+B;IACjF,OAAO,IAAI,GAAA,CAAI,CAAC,MAAM,QAAU;YAAC;YAAO,IAAI;SAAC;AAC/C;AAOO,SAAS,eAAe,CAAA,EAAmB,CAAA,EAA4B;IAC5E,IAAI,EAAE,MAAA,KAAW,EAAE,MAAA,CAAQ,CAAA,OAAO;IAClC,IAAA,IAAS,IAAI,GAAG,IAAI,EAAE,MAAA,EAAQ,IAAK;QACjC,IAAI,CAAA,CAAE,CAAC,CAAA,KAAM,CAAA,CAAE,CAAC,CAAA,CAAG,CAAA,OAAO;IAC5B;IACA,OAAO;AACT;AAiBO,SAAS,cAAiB,GAAA,EAAmB,SAAA,EAAyC;IAC3F,IAAA,IAAS,IAAI,IAAI,MAAA,GAAS,GAAG,KAAK,GAAG,IAAK;QACxC,IAAI,UAAU,GAAA,CAAI,CAAC,CAAC,EAAG,CAAA,OAAO;IAChC;IACA,OAAO,CAAA;AACT;AASO,SAAS,QACd,GAAA,EACA,GAAA,EACa;IACb,MAAM,SAAS,aAAA,GAAA,IAAI;IACnB,KAAA,MAAW,QAAQ,IAAK;QACtB,MAAM,IAAI,IAAI,IAAI;QAClB,IAAI,OAAO,GAAA,CAAI,CAAC,MAAM,KAAA,EAAW,CAAA,OAAO,GAAA,CAAI,GAAG,CAAC,CAAC;QACjD,OAAO,GAAA,CAAI,CAAC,EAAG,IAAA,CAAK,IAAI;IAC1B;IACA,OAAO;AACT;AAuBO,SAAS,MAAM,cAAA,EAAwB,YAAA,EAAuB,IAAA,EAAyB;IAC5F,IAAI,iBAAiB,KAAA,GAAW;QAC9B,eAAe;QACf,iBAAiB;IACnB;IACA,IAAI,SAAS,KAAA,EAAW,CAAA,OAAO;IAE/B,MAAM,SAAS,CAAC,CAAA;IAChB,IAAA,IAAS,IAAI,gBAAgB,OAAO,IAAK,IAAI,eAAiB,IAAI,cAAe,KAAK,KAAM;QAC1F,OAAO,IAAA,CAAK,CAAC;IACf;IACA,OAAO;AACT;AAWO,SAAS,WAAW,GAAA,EAAqB,CAAA,EAAkB;IAChE,IAAI,IAAI,MAAA,KAAW,EAAG,CAAA,OAAO,CAAC,CAAA;IAC9B,MAAM,YAAQ,+LAAA,EAAU,GAAG,IAAI,MAAM;IACrC,OAAO,CAAC;WAAG,IAAI,KAAA,CAAM,KAAK,GAAG;WAAG,IAAI,KAAA,CAAM,GAAG,KAAK,CAAC;KAAA;AACrD;AAUO,SAAS,YAAY,GAAA,EAAqB,CAAA,EAAkB;IACjE,OAAO,WAAW,KAAK,CAAC,CAAC;AAC3B;AAWO,SAAS,QAAW,GAAA,EAAwB;IACjD,MAAM,SAAS,CAAC;WAAG,GAAG;KAAA;IACtB,IAAA,IAAS,IAAI,OAAO,MAAA,GAAS,GAAG,IAAI,GAAG,IAAK;QAC1C,MAAM,IAAI,KAAK,KAAA,CAAM,KAAK,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA,CAAE;QAC5C,CAAC,MAAA,CAAO,CAAC,CAAA,EAAG,MAAA,CAAO,CAAC,CAAC,CAAA,GAAI;YAAC,MAAA,CAAO,CAAC,CAAA;YAAG,MAAA,CAAO,CAAC,CAAC;SAAA;IAChD;IACA,OAAO;AACT;AAyBO,SAAS,aAAmB,IAAA,EAAoB,IAAA,EAA8B;IACnF,OAAO,KAAK,OAAA,CAAQ,CAAC,QAAU,KAAK,GAAA,CAAI,CAAC,QAAU;gBAAC;gBAAO,KAAK;aAAW,CAAC;AAC9E;AAUO,SAAS,OAAU,GAAA,EAAwB;IAChD,OAAO,CAAC;WAAG,IAAI,IAAI,GAAG,CAAC;KAAA;AACzB","debugId":null}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/strings.tsx"],"sourcesContent":["import { findLastIndex, unique } from \"./arrays\";\nimport { StackAssertionError } from \"./errors\";\nimport { filterUndefined } from \"./objects\";\n\nexport type Join<T extends string[], Separator extends string> =\n  T extends [] ? \"\"\n    : T extends [infer U extends string, ...infer Rest extends string[]]\n      ? `${U}${Rest extends [any, ...any[]] ? `${Separator}${Join<Rest, Separator>}` : \"\"}`\n      : \"<error-joining-strings>\";\n\nexport function typedJoin<T extends string[], Separator extends string>(strings: T, separator: Separator): Join<T, Separator> {\n  return strings.join(separator) as Join<T, Separator>;\n}\n\nexport function typedToLowercase<S extends string>(s: S): Lowercase<S> {\n  if (typeof s !== \"string\") throw new StackAssertionError(\"Expected a string for typedToLowercase\", { s });\n  return s.toLowerCase() as Lowercase<S>;\n}\nundefined?.test(\"typedToLowercase\", ({ expect }) => {\n  expect(typedToLowercase(\"\")).toBe(\"\");\n  expect(typedToLowercase(\"HELLO\")).toBe(\"hello\");\n  expect(typedToLowercase(\"Hello World\")).toBe(\"hello world\");\n  expect(typedToLowercase(\"hello\")).toBe(\"hello\");\n  expect(typedToLowercase(\"123\")).toBe(\"123\");\n  expect(typedToLowercase(\"MIXED123case\")).toBe(\"mixed123case\");\n  expect(typedToLowercase(\"Special@Chars!\")).toBe(\"special@chars!\");\n  expect(() => typedToLowercase(123 as any)).toThrow(\"Expected a string for typedToLowercase\");\n});\n\nexport function typedToUppercase<S extends string>(s: S): Uppercase<S> {\n  if (typeof s !== \"string\") throw new StackAssertionError(\"Expected a string for typedToUppercase\", { s });\n  return s.toUpperCase() as Uppercase<S>;\n}\nundefined?.test(\"typedToUppercase\", ({ expect }) => {\n  expect(typedToUppercase(\"\")).toBe(\"\");\n  expect(typedToUppercase(\"hello\")).toBe(\"HELLO\");\n  expect(typedToUppercase(\"Hello World\")).toBe(\"HELLO WORLD\");\n  expect(typedToUppercase(\"HELLO\")).toBe(\"HELLO\");\n  expect(typedToUppercase(\"123\")).toBe(\"123\");\n  expect(typedToUppercase(\"mixed123Case\")).toBe(\"MIXED123CASE\");\n  expect(typedToUppercase(\"special@chars!\")).toBe(\"SPECIAL@CHARS!\");\n  expect(() => typedToUppercase(123 as any)).toThrow(\"Expected a string for typedToUppercase\");\n});\n\nexport function typedCapitalize<S extends string>(s: S): Capitalize<S> {\n  return s.charAt(0).toUpperCase() + s.slice(1) as Capitalize<S>;\n}\nundefined?.test(\"typedCapitalize\", ({ expect }) => {\n  expect(typedCapitalize(\"\")).toBe(\"\");\n  expect(typedCapitalize(\"hello\")).toBe(\"Hello\");\n  expect(typedCapitalize(\"hello world\")).toBe(\"Hello world\");\n  expect(typedCapitalize(\"HELLO\")).toBe(\"HELLO\");\n  expect(typedCapitalize(\"123test\")).toBe(\"123test\");\n  expect(typedCapitalize(\"already Capitalized\")).toBe(\"Already Capitalized\");\n  expect(typedCapitalize(\"h\")).toBe(\"H\");\n});\n\n/**\n * Compares two strings in a way that is not dependent on the current locale.\n */\nexport function stringCompare(a: string, b: string): number {\n  if (typeof a !== \"string\" || typeof b !== \"string\") throw new StackAssertionError(`Expected two strings for stringCompare, found ${typeof a} and ${typeof b}`, { a, b });\n  const cmp = (a: string, b: string) => a < b ? -1 : a > b ? 1 : 0;\n  return cmp(a.toUpperCase(), b.toUpperCase()) || cmp(b, a);\n}\nundefined?.test(\"stringCompare\", ({ expect }) => {\n  // Equal strings\n  expect(stringCompare(\"a\", \"a\")).toBe(0);\n  expect(stringCompare(\"\", \"\")).toBe(0);\n\n  // Case comparison - note that this function is NOT case-insensitive\n  // It compares uppercase versions first, then original strings\n  expect(stringCompare(\"a\", \"A\")).toBe(-1); // lowercase comes after uppercase\n  expect(stringCompare(\"A\", \"a\")).toBe(1);  // uppercase comes before lowercase\n  expect(stringCompare(\"abc\", \"ABC\")).toBe(-1);\n  expect(stringCompare(\"ABC\", \"abc\")).toBe(1);\n\n  // Different strings\n  expect(stringCompare(\"a\", \"b\")).toBe(-1);\n  expect(stringCompare(\"b\", \"a\")).toBe(1);\n\n  // Strings with different lengths\n  expect(stringCompare(\"abc\", \"abcd\")).toBe(-1);\n  expect(stringCompare(\"abcd\", \"abc\")).toBe(1);\n\n  // Strings with numbers\n  expect(stringCompare(\"a1\", \"a2\")).toBe(-1);\n  expect(stringCompare(\"a10\", \"a2\")).toBe(-1);\n\n  // Strings with special characters\n  expect(stringCompare(\"a\", \"a!\")).toBe(-1);\n  expect(stringCompare(\"a!\", \"a\")).toBe(1);\n});\n\n/**\n * Returns all whitespace character at the start of the string.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function getWhitespacePrefix(s: string): string {\n  return s.substring(0, s.length - s.trimStart().length);\n}\nundefined?.test(\"getWhitespacePrefix\", ({ expect }) => {\n  expect(getWhitespacePrefix(\"\")).toBe(\"\");\n  expect(getWhitespacePrefix(\"hello\")).toBe(\"\");\n  expect(getWhitespacePrefix(\" hello\")).toBe(\" \");\n  expect(getWhitespacePrefix(\"  hello\")).toBe(\"  \");\n  expect(getWhitespacePrefix(\"\\thello\")).toBe(\"\\t\");\n  expect(getWhitespacePrefix(\"\\n hello\")).toBe(\"\\n \");\n  expect(getWhitespacePrefix(\"   \")).toBe(\"   \");\n  expect(getWhitespacePrefix(\" \\t\\n\\r\")).toBe(\" \\t\\n\\r\");\n});\n\n/**\n * Returns all whitespace character at the end of the string.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function getWhitespaceSuffix(s: string): string {\n  return s.substring(s.trimEnd().length);\n}\nundefined?.test(\"getWhitespaceSuffix\", ({ expect }) => {\n  expect(getWhitespaceSuffix(\"\")).toBe(\"\");\n  expect(getWhitespaceSuffix(\"hello\")).toBe(\"\");\n  expect(getWhitespaceSuffix(\"hello \")).toBe(\" \");\n  expect(getWhitespaceSuffix(\"hello  \")).toBe(\"  \");\n  expect(getWhitespaceSuffix(\"hello\\t\")).toBe(\"\\t\");\n  expect(getWhitespaceSuffix(\"hello \\n\")).toBe(\" \\n\");\n  expect(getWhitespaceSuffix(\"   \")).toBe(\"   \");\n  expect(getWhitespaceSuffix(\" \\t\\n\\r\")).toBe(\" \\t\\n\\r\");\n});\n\n/**\n * Returns a string with all empty or whitespace-only lines at the start removed.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function trimEmptyLinesStart(s: string): string {\n  const lines = s.split(\"\\n\");\n  const firstNonEmptyLineIndex = lines.findIndex((line) => line.trim() !== \"\");\n  // If all lines are empty or whitespace-only, return an empty string\n  if (firstNonEmptyLineIndex === -1) return \"\";\n  return lines.slice(firstNonEmptyLineIndex).join(\"\\n\");\n}\nundefined?.test(\"trimEmptyLinesStart\", ({ expect }) => {\n  expect(trimEmptyLinesStart(\"\")).toBe(\"\");\n  expect(trimEmptyLinesStart(\"hello\")).toBe(\"hello\");\n  expect(trimEmptyLinesStart(\"\\nhello\")).toBe(\"hello\");\n  expect(trimEmptyLinesStart(\"\\n\\nhello\")).toBe(\"hello\");\n  expect(trimEmptyLinesStart(\"  \\n\\t\\nhello\")).toBe(\"hello\");\n  expect(trimEmptyLinesStart(\"\\n\\nhello\\nworld\")).toBe(\"hello\\nworld\");\n  expect(trimEmptyLinesStart(\"hello\\n\\nworld\")).toBe(\"hello\\n\\nworld\");\n  expect(trimEmptyLinesStart(\"hello\\nworld\\n\")).toBe(\"hello\\nworld\\n\");\n  expect(trimEmptyLinesStart(\"\\n  \\n\\nhello\\n  \\nworld\")).toBe(\"hello\\n  \\nworld\");\n  // Edge case: all lines are empty\n  expect(trimEmptyLinesStart(\"\\n\\n  \\n\\t\")).toBe(\"\");\n});\n\n/**\n * Returns a string with all empty or whitespace-only lines at the end removed.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function trimEmptyLinesEnd(s: string): string {\n  const lines = s.split(\"\\n\");\n  const lastNonEmptyLineIndex = findLastIndex(lines, (line) => line.trim() !== \"\");\n  return lines.slice(0, lastNonEmptyLineIndex + 1).join(\"\\n\");\n}\nundefined?.test(\"trimEmptyLinesEnd\", ({ expect }) => {\n  expect(trimEmptyLinesEnd(\"\")).toBe(\"\");\n  expect(trimEmptyLinesEnd(\"hello\")).toBe(\"hello\");\n  expect(trimEmptyLinesEnd(\"hello\\n\")).toBe(\"hello\");\n  expect(trimEmptyLinesEnd(\"hello\\n\\n\")).toBe(\"hello\");\n  expect(trimEmptyLinesEnd(\"hello\\n  \\n\\t\")).toBe(\"hello\");\n  expect(trimEmptyLinesEnd(\"hello\\nworld\\n\\n\")).toBe(\"hello\\nworld\");\n  expect(trimEmptyLinesEnd(\"hello\\n\\nworld\")).toBe(\"hello\\n\\nworld\");\n  expect(trimEmptyLinesEnd(\"\\nhello\\nworld\")).toBe(\"\\nhello\\nworld\");\n  expect(trimEmptyLinesEnd(\"hello\\n  \\nworld\\n\\n  \")).toBe(\"hello\\n  \\nworld\");\n  // Edge case: all lines are empty\n  expect(trimEmptyLinesEnd(\"\\n\\n  \\n\\t\")).toBe(\"\");\n});\n\n/**\n * Returns a string with all empty or whitespace-only lines trimmed at the start and end.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function trimLines(s: string): string {\n  return trimEmptyLinesEnd(trimEmptyLinesStart(s));\n}\nundefined?.test(\"trimLines\", ({ expect }) => {\n  expect(trimLines(\"\")).toBe(\"\");\n  expect(trimLines(\" \")).toBe(\"\");\n  expect(trimLines(\" \\n \")).toBe(\"\");\n  expect(trimLines(\" abc \")).toBe(\" abc \");\n  expect(trimLines(\"\\n  \\nLine1\\nLine2\\n \\n\")).toBe(\"Line1\\nLine2\");\n  expect(trimLines(\"Line1\\n   \\nLine2\")).toBe(\"Line1\\n   \\nLine2\");\n  expect(trimLines(\" \\n    \\n\\t\")).toBe(\"\");\n  expect(trimLines(\"   Hello World\")).toBe(\"   Hello World\");\n  expect(trimLines(\"\\n\")).toBe(\"\");\n  expect(trimLines(\"\\t \\n\\t\\tLine1 \\n \\nLine2\\t\\t\\n\\t  \")).toBe(\"\\t\\tLine1 \\n \\nLine2\\t\\t\");\n});\n\n\n/**\n * A template literal tag that returns the same string as the template literal without a tag.\n *\n * Useful for implementing your own template literal tags.\n */\nexport function templateIdentity(strings: TemplateStringsArray | readonly string[], ...values: string[]): string {\n  if (values.length !== strings.length - 1) throw new StackAssertionError(\"Invalid number of values; must be one less than strings\", { strings, values });\n\n  return strings.reduce((result, str, i) => result + str + (values[i] ?? ''), '');\n}\nundefined?.test(\"templateIdentity\", ({ expect }) => {\n  expect(templateIdentity`Hello World`).toBe(\"Hello World\");\n  expect(templateIdentity`${\"Hello\"}`).toBe(\"Hello\");\n  const greeting = \"Hello\";\n  const subject = \"World\";\n  expect(templateIdentity`${greeting}, ${subject}!`).toBe(\"Hello, World!\");\n  expect(templateIdentity`${\"A\"}${\"B\"}${\"C\"}`).toBe(\"ABC\");\n  expect(templateIdentity`Start${\"\"}Middle${\"\"}End`).toBe(\"StartMiddleEnd\");\n  expect(templateIdentity``).toBe(\"\");\n  expect(templateIdentity`Line1\nLine2`).toBe(\"Line1\\nLine2\");\n  expect(templateIdentity([\"a \", \" scientific \", \"gun\"], \"certain\", \"rail\")).toBe(\"a certain scientific railgun\");\n  expect(templateIdentity([\"only one part\"])).toBe(\"only one part\");\n  expect(() => templateIdentity([\"a \", \"b\", \"c\"], \"only one\")).toThrow(\"Invalid number of values\");\n  expect(() => templateIdentity([\"a\", \"b\"], \"x\", \"y\")).toThrow(\"Invalid number of values\");\n});\n\n\nexport function deindent(code: string): string;\nexport function deindent(strings: TemplateStringsArray | readonly string[], ...values: any[]): string;\nexport function deindent(strings: string | readonly string[], ...values: any[]): string {\n  if (typeof strings === \"string\") return deindent([strings]);\n  return templateIdentity(...deindentTemplate(strings, ...values));\n}\n\nexport function deindentTemplate(strings: TemplateStringsArray | readonly string[], ...values: any[]): [string[], ...string[]] {\n  if (values.length !== strings.length - 1) throw new StackAssertionError(\"Invalid number of values; must be one less than strings\", { strings, values });\n\n  const trimmedStrings = [...strings];\n  trimmedStrings[0] = trimEmptyLinesStart(trimmedStrings[0] + \"+\").slice(0, -1);\n  trimmedStrings[trimmedStrings.length - 1] = trimEmptyLinesEnd(\"+\" + trimmedStrings[trimmedStrings.length - 1]).slice(1);\n\n  const indentation = trimmedStrings\n    .join(\"${SOME_VALUE}\")\n    .split(\"\\n\")\n    .filter((line) => line.trim() !== \"\")\n    .map((line) => getWhitespacePrefix(line).length)\n    .reduce((min, current) => Math.min(min, current), Infinity);\n\n  const deindentedStrings = trimmedStrings\n    .map((string, stringIndex) => {\n      return string\n        .split(\"\\n\")\n        .map((line, lineIndex) => stringIndex !== 0 && lineIndex === 0 ? line : line.substring(indentation))\n        .join(\"\\n\");\n    });\n\n  const indentedValues = values.map((value, i) => {\n    const firstLineIndentation = getWhitespacePrefix(deindentedStrings[i].split(\"\\n\").at(-1)!);\n    return `${value}`.replaceAll(\"\\n\", `\\n${firstLineIndentation}`);\n  });\n\n  return [deindentedStrings, ...indentedValues];\n}\nundefined?.test(\"deindent\", ({ expect }) => {\n  // Test with string input\n  expect(deindent(\"  hello\")).toBe(\"hello\");\n  expect(deindent(\"  hello\\n  world\")).toBe(\"hello\\nworld\");\n  expect(deindent(\"  hello\\n    world\")).toBe(\"hello\\n  world\");\n  expect(deindent(\"\\n  hello\\n  world\\n\")).toBe(\"hello\\nworld\");\n\n  // Test with empty input\n  expect(deindent(\"\")).toBe(\"\");\n\n  // Test with template literal\n  expect(deindent`\n    hello\n    world\n  `).toBe(\"hello\\nworld\");\n\n  expect(deindent`\n    hello\n      world\n  `).toBe(\"hello\\n  world\");\n\n  // Test with values\n  const value = \"test\";\n  expect(deindent`\n    hello ${value}\n    world\n  `).toBe(`hello ${value}\\nworld`);\n\n  // Test with multiline values\n  expect(deindent`\n    hello\n      to ${\"line1\\n  line2\"}\n    world\n  `).toBe(`hello\\n  to line1\\n    line2\\nworld`);\n\n  // Leading whitespace values\n  expect(deindent`\n    ${\"  \"}A\n    ${\"  \"}B\n    ${\"  \"}C\n  `).toBe(`  A\\n  B\\n  C`);\n\n  // Trailing whitespaces (note: there are two whitespaces each after A and after C)\n  expect(deindent`\n    A  \n    B  ${\"  \"}\n    C  \n  `).toBe(`A  \\nB    \\nC  `);\n\n  // Test with mixed indentation\n  expect(deindent`\n    hello\n      world\n        !\n  `).toBe(\"hello\\n  world\\n    !\");\n\n  // Test error cases\n  expect(() => deindent([\"a\", \"b\", \"c\"], \"too\", \"many\", \"values\")).toThrow(\"Invalid number of values\");\n});\n\nexport function extractScopes(scope: string, removeDuplicates=true): string[] {\n  // TODO what is this for? can we move this into the OAuth code in the backend?\n  const trimmedString = scope.trim();\n  const scopesArray = trimmedString.split(/\\s+/);\n  const filtered = scopesArray.filter(scope => scope.length > 0);\n  return removeDuplicates ? [...new Set(filtered)] : filtered;\n}\nundefined?.test(\"extractScopes\", ({ expect }) => {\n  // Test with empty string\n  expect(extractScopes(\"\")).toEqual([]);\n\n  // Test with single scope\n  expect(extractScopes(\"read\")).toEqual([\"read\"]);\n\n  // Test with multiple scopes\n  expect(extractScopes(\"read write\")).toEqual([\"read\", \"write\"]);\n\n  // Test with extra whitespace\n  expect(extractScopes(\"  read  write  \")).toEqual([\"read\", \"write\"]);\n\n  // Test with newlines and tabs\n  expect(extractScopes(\"read\\nwrite\\tdelete\")).toEqual([\"read\", \"write\", \"delete\"]);\n\n  // Test with duplicates (default behavior)\n  expect(extractScopes(\"read write read\")).toEqual([\"read\", \"write\"]);\n\n  // Test with duplicates (explicitly set to remove)\n  expect(extractScopes(\"read write read\", true)).toEqual([\"read\", \"write\"]);\n\n  // Test with duplicates (explicitly set to keep)\n  expect(extractScopes(\"read write read\", false)).toEqual([\"read\", \"write\", \"read\"]);\n});\n\nexport function mergeScopeStrings(...scopes: string[]): string {\n  // TODO what is this for? can we move this into the OAuth code in the backend?\n  const allScope = scopes.map((s) => extractScopes(s)).flat().join(\" \");\n  return extractScopes(allScope).join(\" \");\n}\nundefined?.test(\"mergeScopeStrings\", ({ expect }) => {\n  // Test with empty input\n  expect(mergeScopeStrings()).toBe(\"\");\n\n  // Test with single scope string\n  expect(mergeScopeStrings(\"read write\")).toBe(\"read write\");\n\n  // Test with multiple scope strings\n  expect(mergeScopeStrings(\"read\", \"write\")).toBe(\"read write\");\n\n  // Test with overlapping scopes\n  expect(mergeScopeStrings(\"read write\", \"write delete\")).toBe(\"read write delete\");\n\n  // Test with extra whitespace\n  expect(mergeScopeStrings(\"  read  write  \", \"  delete  \")).toBe(\"read write delete\");\n\n  // Test with duplicates across strings\n  expect(mergeScopeStrings(\"read write\", \"write delete\", \"read\")).toBe(\"read write delete\");\n\n  // Test with empty strings\n  expect(mergeScopeStrings(\"read write\", \"\", \"delete\")).toBe(\"read write delete\");\n});\n\nexport function escapeTemplateLiteral(s: string): string {\n  return s.replaceAll(\"`\", \"\\\\`\").replaceAll(\"\\\\\", \"\\\\\\\\\").replaceAll(\"$\", \"\\\\$\");\n}\nundefined?.test(\"escapeTemplateLiteral\", ({ expect }) => {\n  // Test with empty string\n  expect(escapeTemplateLiteral(\"\")).toBe(\"\");\n\n  // Test with normal string (no special characters)\n  expect(escapeTemplateLiteral(\"hello world\")).toBe(\"hello world\");\n\n  // Test with backtick\n  const input1 = \"hello `world`\";\n  const output1 = escapeTemplateLiteral(input1);\n  // Verify backticks are escaped\n  expect(output1.includes(\"\\\\`\")).toBe(true);\n  expect(output1).not.toBe(input1);\n\n  // Test with backslash\n  const input2 = \"hello \\\\world\";\n  const output2 = escapeTemplateLiteral(input2);\n  // Verify backslashes are escaped\n  expect(output2.includes(\"\\\\\\\\\")).toBe(true);\n  expect(output2).not.toBe(input2);\n\n  // Test with dollar sign\n  const input3 = \"hello $world\";\n  const output3 = escapeTemplateLiteral(input3);\n  // Verify dollar signs are escaped\n  expect(output3.includes(\"\\\\$\")).toBe(true);\n  expect(output3).not.toBe(input3);\n\n  // Test with multiple special characters\n  const input4 = \"`hello` $world\\\\\";\n  const output4 = escapeTemplateLiteral(input4);\n  // Verify all special characters are escaped\n  expect(output4.includes(\"\\\\`\")).toBe(true);\n  expect(output4.includes(\"\\\\$\")).toBe(true);\n  expect(output4.includes(\"\\\\\\\\\")).toBe(true);\n  expect(output4).not.toBe(input4);\n\n  // Test with already escaped characters\n  const input5 = \"\\\\`hello\\\\`\";\n  const output5 = escapeTemplateLiteral(input5);\n  // Verify already escaped characters are properly escaped\n  expect(output5).not.toBe(input5);\n});\n\n/**\n * Some classes have different constructor names in different environments (eg. `Headers` is sometimes called `_Headers`,\n * so we create an object of overrides to handle these cases.\n */\nconst nicifiableClassNameOverrides = new Map(Object.entries({\n  Headers,\n} as Record<string, unknown>).map(([k, v]) => [v, k]));\nexport type Nicifiable = {\n  getNicifiableKeys?(): PropertyKey[],\n  getNicifiedObjectExtraLines?(): string[],\n};\nexport type NicifyOptions = {\n  maxDepth: number,\n  currentIndent: string,\n  lineIndent: string,\n  multiline: boolean,\n  refs: Map<unknown, string>,\n  path: string,\n  parent: null | {\n    options: NicifyOptions,\n    value: unknown,\n  },\n  keyInParent: PropertyKey | null,\n  hideFields: PropertyKey[],\n  overrides: (...args: Parameters<typeof nicify>) => string | null,\n};\nexport function nicify(\n  value: unknown,\n  options: Partial<NicifyOptions> = {},\n): string {\n  const fullOptions: NicifyOptions = {\n    maxDepth: 5,\n    currentIndent: \"\",\n    lineIndent: \"  \",\n    multiline: true,\n    refs: new Map(),\n    path: \"value\",\n    parent: null,\n    overrides: () => null,\n    keyInParent: null,\n    hideFields: [],\n    ...filterUndefined(options),\n  };\n  const {\n    maxDepth,\n    currentIndent,\n    lineIndent,\n    multiline,\n    refs,\n    path,\n    overrides,\n    hideFields,\n  } = fullOptions;\n  const nl = `\\n${currentIndent}`;\n\n  const overrideResult = overrides(value, options);\n  if (overrideResult !== null) return overrideResult;\n\n  if ([\"function\", \"object\", \"symbol\"].includes(typeof value) && value !== null) {\n    if (refs.has(value)) {\n      return `Ref<${refs.get(value)}>`;\n    }\n    refs.set(value, path);\n  }\n\n  const newOptions: NicifyOptions = {\n    maxDepth: maxDepth - 1,\n    currentIndent,\n    lineIndent,\n    multiline,\n    refs,\n    path: path + \"->[unknown property]\",\n    overrides,\n    parent: { value, options: fullOptions },\n    keyInParent: null,\n    hideFields: [],\n  };\n  const nestedNicify = (newValue: unknown, newPath: string, keyInParent: PropertyKey | null, options: Partial<NicifyOptions> = {}) => {\n    return nicify(newValue, {\n      ...newOptions,\n      path: newPath,\n      currentIndent: currentIndent + lineIndent,\n      keyInParent,\n      ...options,\n    });\n  };\n\n  switch (typeof value) {\n    case \"boolean\": case \"number\": {\n      return JSON.stringify(value);\n    }\n    case \"string\": {\n      const isDeindentable = (v: string) => deindent(v) === v && v.includes(\"\\n\");\n      const wrapInDeindent = (v: string) => deindent`\n        deindent\\`\n        ${currentIndent + lineIndent}${escapeTemplateLiteral(v).replaceAll(\"\\n\", nl + lineIndent)}\n        ${currentIndent}\\`\n      `;\n      if (isDeindentable(value)) {\n        return wrapInDeindent(value);\n      } else if (value.endsWith(\"\\n\") && isDeindentable(value.slice(0, -1))) {\n        return wrapInDeindent(value.slice(0, -1)) + ' + \"\\\\n\"';\n      } else {\n        return JSON.stringify(value);\n      }\n    }\n    case \"undefined\": {\n      return \"undefined\";\n    }\n    case \"symbol\": {\n      return value.toString();\n    }\n    case \"bigint\": {\n      return `${value}n`;\n    }\n    case \"function\": {\n      if (value.name) return `function ${value.name}(...) { ... }`;\n      return `(...) => { ... }`;\n    }\n    case \"object\": {\n      if (value === null) return \"null\";\n      if (Array.isArray(value)) {\n        const extraLines = getNicifiedObjectExtraLines(value);\n        const resValueLength = value.length + extraLines.length;\n        if (maxDepth <= 0 && resValueLength === 0) return \"[...]\";\n        const resValues = value.map((v, i) => nestedNicify(v, `${path}[${i}]`, i));\n        resValues.push(...extraLines);\n        if (resValues.length !== resValueLength) throw new StackAssertionError(\"nicify of object: resValues.length !== resValueLength\", { value, resValues, resValueLength });\n        const shouldIndent = resValues.length > 4 || resValues.some(x => (resValues.length > 1 && x.length > 4) || x.includes(\"\\n\"));\n        if (shouldIndent) {\n          return `[${nl}${resValues.map(x => `${lineIndent}${x},${nl}`).join(\"\")}]`;\n        } else {\n          return `[${resValues.join(\", \")}]`;\n        }\n      }\n      if (value instanceof URL) {\n        return `URL(${nestedNicify(value.toString(), `${path}.toString()`, null)})`;\n      }\n      if (ArrayBuffer.isView(value)) {\n        return `${value.constructor.name}([${value.toString()}])`;\n      }\n      if (value instanceof Error) {\n        let stack = value.stack ?? \"\";\n        const toString = value.toString();\n        if (!stack.startsWith(toString)) stack = `${toString}\\n${stack}`;  // some browsers don't include the error message in the stack, some do\n        stack = stack.trimEnd();\n        stack = stack.replace(/\\n\\s+/g, `\\n${lineIndent}${lineIndent}`);\n        stack = stack.replace(\"\\n\", `\\n${lineIndent}Stack:\\n`);\n        if (Object.keys(value).length > 0) {\n          stack += `\\n${lineIndent}Extra properties: ${nestedNicify(Object.fromEntries(Object.entries(value)), path, null)}`;\n        }\n        if (value.cause) {\n          stack += `\\n${lineIndent}Cause:\\n${lineIndent}${lineIndent}${nestedNicify(value.cause, path, null, { currentIndent: currentIndent + lineIndent + lineIndent })}`;\n        }\n        stack = stack.replaceAll(\"\\n\", `\\n${currentIndent}`);\n        return stack;\n      }\n\n      const constructorName = [null, Object.prototype].includes(Object.getPrototypeOf(value)) ? null : (nicifiableClassNameOverrides.get(value.constructor) ?? value.constructor.name);\n      const constructorString = constructorName ? `${constructorName} ` : \"\";\n\n      const entries = getNicifiableEntries(value).filter(([k]) => !hideFields.includes(k));\n      const extraLines = [\n        ...getNicifiedObjectExtraLines(value),\n        ...hideFields.length > 0 ? [`<some fields may have been hidden>`] : [],\n      ];\n      const resValueLength = entries.length + extraLines.length;\n      if (resValueLength === 0) return `${constructorString}{}`;\n      if (maxDepth <= 0) return `${constructorString}{ ... }`;\n      const resValues = entries.map(([k, v], keyIndex) => {\n        const keyNicified = nestedNicify(k, `Object.keys(${path})[${keyIndex}]`, null);\n        const keyInObjectLiteral = typeof k === \"string\" ? nicifyPropertyString(k) : `[${keyNicified}]`;\n        if (typeof v === \"function\" && v.name === k) {\n          return `${keyInObjectLiteral}(...): { ... }`;\n        } else {\n          return `${keyInObjectLiteral}: ${nestedNicify(v, `${path}[${keyNicified}]`, k)}`;\n        }\n      });\n      resValues.push(...extraLines);\n      if (resValues.length !== resValueLength) throw new StackAssertionError(\"nicify of object: resValues.length !== resValueLength\", { value, resValues, resValueLength });\n      const shouldIndent = resValues.length > 1 || resValues.some(x => x.includes(\"\\n\"));\n\n      if (resValues.length === 0) return `${constructorString}{}`;\n      if (shouldIndent) {\n        return `${constructorString}{${nl}${resValues.map(x => `${lineIndent}${x},${nl}`).join(\"\")}}`;\n      } else {\n        return `${constructorString}{ ${resValues.join(\", \")} }`;\n      }\n    }\n    default: {\n      return `${typeof value}<${value}>`;\n    }\n  }\n}\n\nexport function replaceAll(input: string, searchValue: string, replaceValue: string): string {\n  if (searchValue === \"\") throw new StackAssertionError(\"replaceAll: searchValue is empty\");\n  return input.split(searchValue).join(replaceValue);\n}\nundefined?.test(\"replaceAll\", ({ expect }) => {\n  expect(replaceAll(\"hello world\", \"o\", \"x\")).toBe(\"hellx wxrld\");\n  expect(replaceAll(\"aaa\", \"a\", \"b\")).toBe(\"bbb\");\n  expect(replaceAll(\"\", \"a\", \"b\")).toBe(\"\");\n  expect(replaceAll(\"abc\", \"b\", \"\")).toBe(\"ac\");\n  expect(replaceAll(\"test.test.test\", \".\", \"_\")).toBe(\"test_test_test\");\n  expect(replaceAll(\"a.b*c\", \".\", \"x\")).toBe(\"axb*c\");\n  expect(replaceAll(\"a*b*c\", \"*\", \"x\")).toBe(\"axbxc\");\n  expect(replaceAll(\"hello hello\", \"hello\", \"hi\")).toBe(\"hi hi\");\n});\n\nfunction nicifyPropertyString(str: string) {\n  return JSON.stringify(str);\n}\nundefined?.test(\"nicifyPropertyString\", ({ expect }) => {\n  // Test valid identifiers\n  expect(nicifyPropertyString(\"validName\")).toBe('\"validName\"');\n  expect(nicifyPropertyString(\"_validName\")).toBe('\"_validName\"');\n  expect(nicifyPropertyString(\"valid123Name\")).toBe('\"valid123Name\"');\n\n  // Test invalid identifiers\n  expect(nicifyPropertyString(\"123invalid\")).toBe('\"123invalid\"');\n  expect(nicifyPropertyString(\"invalid-name\")).toBe('\"invalid-name\"');\n  expect(nicifyPropertyString(\"invalid space\")).toBe('\"invalid space\"');\n  expect(nicifyPropertyString(\"$invalid\")).toBe('\"$invalid\"');\n  expect(nicifyPropertyString(\"\")).toBe('\"\"');\n\n  // Test with special characters\n  expect(nicifyPropertyString(\"property!\")).toBe('\"property!\"');\n  expect(nicifyPropertyString(\"property.name\")).toBe('\"property.name\"');\n\n  // Test with escaped characters\n  expect(nicifyPropertyString(\"\\\\\")).toBe('\"\\\\\\\\\"');\n  expect(nicifyPropertyString('\"')).toBe('\"\\\\\"\"');\n});\n\nfunction getNicifiableKeys(value: Nicifiable | object) {\n  const overridden = (\"getNicifiableKeys\" in value ? value.getNicifiableKeys?.bind(value) : null)?.();\n  if (overridden != null) return overridden;\n  if (value instanceof Response) {\n    return ['status', 'headers'];\n  }\n  const keys = Object.keys(value).sort();\n  return unique(keys);\n}\nundefined?.test(\"getNicifiableKeys\", ({ expect }) => {\n  // Test regular object\n  expect(getNicifiableKeys({ b: 1, a: 2, c: 3 })).toEqual([\"a\", \"b\", \"c\"]);\n\n  // Test empty object\n  expect(getNicifiableKeys({})).toEqual([]);\n\n\n  expect(getNicifiableKeys(new Response())).toEqual([\"status\", \"headers\"]);\n\n  // Test object with custom getNicifiableKeys\n  const customObject = {\n    a: 1,\n    b: 2,\n    getNicifiableKeys() {\n      return [\"customKey1\", \"customKey2\"];\n    }\n  };\n  expect(getNicifiableKeys(customObject)).toEqual([\"customKey1\", \"customKey2\"]);\n});\n\nfunction getNicifiableEntries(value: Nicifiable | object): [PropertyKey, unknown][] {\n  const recordLikes = [Headers];\n  function isRecordLike(value: unknown): value is InstanceType<typeof recordLikes[number]> {\n    return recordLikes.some(x => value instanceof x);\n  }\n\n  if (isRecordLike(value)) {\n    return [...value.entries()].sort(([a], [b]) => stringCompare(`${a}`, `${b}`));\n  }\n  const keys = getNicifiableKeys(value);\n  return keys.map((k) => [k, value[k as never]] as [PropertyKey, unknown]);\n}\n\nfunction getNicifiedObjectExtraLines(value: Nicifiable | object) {\n  return (\"getNicifiedObjectExtraLines\" in value ? value.getNicifiedObjectExtraLines : null)?.() ?? [];\n}\n"],"names":["a","b","scope","options","extraLines","resValueLength","resValues","shouldIndent","value"],"mappings":"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","debugId":null}},
    {"offset": {"line": 583, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/types.tsx"],"sourcesContent":["import { DeepPartial } from \"./objects\";\nimport { Join } from \"./strings\";\n\nexport type IsAny<T> = 0 extends (1 & T) ? true : false;\nexport type IsNever<T> = [T] extends [never] ? true : false;\nexport type IsNullish<T> = [T] extends [null | undefined] ? true : false;\nexport type IsUnion<T, U = T> =\n  IsNever<T> extends true ? false\n  : IsAny<T> extends true ? false\n    : T extends U // distributive conditional https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n        ? /* if the *whole* original type (`U`) still fits inside the current variant, then `T` wasn’t a union */ ([U] extends [T] ? false : true)\n        : never;\n\nexport type NullishCoalesce<T, U> = T extends null | undefined ? U : T;\n\nexport type LastUnionElement<U> = UnionToIntersection<U extends any ? (x: U) => 0 : never> extends (x: infer L) => 0 ? L & U : never;\n\n/**\n * Makes a type prettier by recursively expanding all object types. For example, `Omit<{ a: 1 }, \"a\">` becomes just `{}`.\n */\nexport type Expand<T> = T extends (...args: infer A) => infer R\n  ? (\n    ((...args: A) => R) extends T\n      ? (...args: Expand<A>) => Expand<R>\n      : ((...args: Expand<A>) => Expand<R>) & { [K in keyof T]: Expand<T[K]> }\n  )\n  : (\n    T extends object\n      ? { [K in keyof T]: Expand<T[K]> }\n      : T\n  );\n\n\n/**\n * Removes all optional undefined/never keys from an object.\n */\nexport type DeepRemoveOptionalUndefined<T> = T extends object ? { [K in keyof T]: DeepRemoveOptionalUndefined<T[K]> } : T;\n\n// why this works: https://stackoverflow.com/a/50375286\nexport type UnionToIntersection<U> =\n  (U extends any ? (x: U) => void : never) extends ((x: infer I) => void) ? I : never\n\ntype _UnionToTupleInner<U, R extends any[], Last> = UnionToTuple<Exclude<U, Last>, [...R, Last]>\nexport type UnionToTuple<U, R extends any[] = []> = [U] extends [never] ? R : _UnionToTupleInner<U, R, LastUnionElement<U>>;\n\nexport type CollapseObjectUnion<T extends object> = {\n  [K in AllUnionKeys<T>]?: T extends Record<K, infer V> ? V : never;\n};\ntypeAssertIs<CollapseObjectUnion<{ a: string } | { b: number }>, { a?: string, b?: number }>()();\ntypeAssertIs<CollapseObjectUnion<{ a: string } | { a: number }>, { a?: string | number }>()();\n\nexport type IntersectAll<T extends any[]> = UnionToIntersection<T[number]>;\n\nexport type OptionalKeys<T> = {\n  [K in keyof T]: {} extends Pick<T, K> ? K : never;\n}[keyof T];\nexport type RequiredKeys<T> = {\n  [K in keyof T]: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\n/**\n * Returns ALL keys of all union elements.\n */\nexport type AllUnionKeys<T extends object> = T extends T ? keyof T : never;\ntypeAssertIs<AllUnionKeys<{ a: string } | { b: number }>, \"a\" | \"b\">()();\n\nexport type SubtractType<T, U> = T extends object ? { [K in keyof T]: K extends keyof U ? SubtractType<T[K], U[K]> : T[K] } : (T extends U ? never : T); // note: this only works due to the distributive property of conditional types https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n\n\ntype _AntiIntersectInner<T, U> = T extends object ? (\n  & Omit<U, keyof T>\n  & { [K in keyof Pick<U, { [K in keyof T & keyof U]: U[K] extends T[K] ? (T[K] extends U[K] ? never : K) : never }[keyof T & keyof U]>]: PseudoAntiIntersect<T[K], U[K]> }\n  & { [K in keyof Pick<U, keyof T & keyof U>]?: PseudoAntiIntersect<T[K], U[K]> }\n) : U;\n/**\n * Returns a type R such that T & R = U.\n */\nexport type AntiIntersect<T, U> = U extends T ? _AntiIntersectInner<T, U> : \"Cannot anti-intersect a type with a type that is not a subtype of it\"; // NOTE: This type is mostly untested — not sure how well it works on the edge cases\nexport type PseudoAntiIntersect<T, U> = _AntiIntersectInner<T, T & U>;\n\n/**\n * A variation of TypeScript's conditionals with slightly different semantics. It is the perfect type for cases where:\n *\n * - If all possible values are contained in `Extends`, then it will be mapped to `Then`.\n * - If all possible values are not contained in `Extends`, then it will be mapped to `Otherwise`.\n * - If some possible values are contained in `Extends` and some are not, then it will be mapped to `Then | Otherwise`.\n *\n * This is different from TypeScript's built-in conditional types (`Value extends Extends ? Then : Otherwise`), which\n * returns `Otherwise` for the third case (causing unsoundness in many real-world cases).\n */\nexport type IfAndOnlyIf<Value, Extends, Then, Otherwise> =\n  | (Value extends Extends ? never : Otherwise)\n  | (Value & Extends extends never ? never : Then);\n\n\n/**\n * Can be used to prettify a type in the IDE; for example, some complicated intersected types can be flattened into a single type.\n */\nexport type PrettifyType<T> = T extends object ? { [K in keyof T]: T[K] } & {} : T;\n\ntype _ToStringAndJoin<T extends any[], Separator extends string> =\n  T extends [infer U, ...infer Rest extends any[]]\n    ? `${TypeToString<U>}${Rest extends [any, ...any[]] ? `${Separator}${_ToStringAndJoin<Rest, Separator>}` : \"\"}`\n    : \"<error-joining-tuple-elements>\";\ntype _TypeToStringInner<T> =\n  IsAny<T> extends true ? \"any\"\n  : IsNever<T> extends true ? \"never\"\n  : IsUnion<T> extends true ? _ToStringAndJoin<UnionToTuple<T>, \" | \">\n  : [T] extends [number] ? (number extends T ? \"number\" : `${T}`)\n  : [T] extends [boolean] ? `${T}`\n  : [T] extends [undefined] ? \"undefined\"\n  : [T] extends [null] ? \"null\"\n  : [T] extends [string] ? (string extends T ? \"string\" : `'${T}'`)\n  : [T] extends [[]] ? \"[]\"\n  : [T] extends [[any, ...any[]]] ? `[${_ToStringAndJoin<T, \", \">}]`\n  : [T] extends [(infer E)[]] ? `${TypeToString<E>}[]`\n  : [T] extends [Function] ? \"function\"\n  : [T] extends [symbol] ? `symbol(${T['description']})`\n  : [T] extends [object] ? `{ ${Join<UnionToTuple<{ [K in keyof T]: `${TypeToString<K>}: ${TypeToString<T[K]>}` }[keyof T]>, \", \">} }`\n  : \"<unknown-type>\"\nexport type TypeToString<T> = _TypeToStringInner<T> extends `${infer S}` ? S : never;\n\n/**\n * Can be used to create assertions on types. For example, if passed any T other than `true`, the following will\n * show a type error:\n *\n * ```ts\n * typeAssert<T>()();  // the second pair of braces is important!\n * ```\n */\nexport function typeAssert<T>(): (\n  IsAny<T> extends true ? TypeAssertionError<`Type assertion failed. Expected true, but got any.`>\n    : IsNever<T> extends true ? TypeAssertionError<`Type assertion failed. Expected true, but got never.`>\n    : T extends true ? (() => undefined)\n    : TypeAssertionError<`Type assertion failed. Expected true, but got: ${TypeToString<T>}`>\n) {\n  return (() => undefined) as any;\n}\ntype TypeAssertionError<T> =\n  & [T]\n  & /* this promise makes sure that if we accidentally forget the second pair of braces, eslint will complain (if we have no-floating-promises enabled) */ Promise<any>;\n\n\ntypeAssertExtends<ReturnType<typeof typeAssert<true>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssert<false>>, TypeAssertionError<`Type assertion failed. Expected true, but got: false`>>()();\ntypeAssertExtends<ReturnType<typeof typeAssert<never>>, TypeAssertionError<`Type assertion failed. Expected true, but got never.`>>()();\ntypeAssertExtends<ReturnType<typeof typeAssert<any>>, TypeAssertionError<`Type assertion failed. Expected true, but got any.`>>()();\n\n/**\n * Functionally equivalent to `typeAssert<T extends S ? true : false>()()`, but with better error messages.\n */\nexport function typeAssertExtends<T, S>(): (\n  [T] extends [S] ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to extend ${TypeToString<S>}`>\n) {\n  return (() => undefined) as any;\n}\n\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<never, true>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<any, true>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<false, false>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<\"abc\", string>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<{a: 1, b: 123}, {a: number}>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<never, never>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<true, any>>, () => undefined>()();\n\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<{a: number}, {a: 1}>>, [\"Type assertion failed. Expected { 'a': number } to extend { 'a': 1 }\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<any, never>>, [\"Type assertion failed. Expected any to extend never\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<false, true>>, [\"Type assertion failed. Expected false to extend true\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<false, never>>, [\"Type assertion failed. Expected false to extend never\"]>()();\n\n\nexport function typeAssertIs<T, U>(): (\n  IsAny<T> extends true ? (IsAny<U> extends true ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>)\n    : IsAny<U> extends true ? TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>\n    : [T] extends [U] ? ([U] extends [T] ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>)\n    : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>\n) {\n  return (() => undefined) as any;\n}\n\ntypeAssertExtends<ReturnType<typeof typeAssertIs<\"123\", \"123\">>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<{a: 1}, {a: 1}>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<DeepPartial<{a: 1}>, {a?: 1}>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<any, any>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<never, never>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<1, any>>, [\"Type assertion failed. Expected 1 to be any\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<any, 1>>, [\"Type assertion failed. Expected any to be 1\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<false, true>>, [\"Type assertion failed. Expected false to be true\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<{a: number}, {a: 1}>>, [\"Type assertion failed. Expected { 'a': number } to be { 'a': 1 }\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<any, never>>, [\"Type assertion failed. Expected any to be never\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<false, true>>, [\"Type assertion failed. Expected false to be true\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<false, never>>, [\"Type assertion failed. Expected false to be never\"]>()();\n"],"names":[],"mappings":";;;;;;AAgDA,aAA6F,EAAE;AAC/F,aAA0F,EAAE;AAe5F,aAAqE,EAAE;AAkEhE,SAAS,aAKd;IACA,OAAQ,IAAM,KAAA;AAChB;AAMA,kBAAwE,EAAE;AAC1E,kBAAoI,EAAE;AACtI,kBAAoI,EAAE;AACtI,kBAAgI,EAAE;AAK3H,SAAS,oBAEd;IACA,OAAQ,IAAM,KAAA;AAChB;AAEA,kBAAsF,EAAE;AACxF,kBAAoF,EAAE;AACtF,kBAAuF,EAAE;AACzF,kBAAwF,EAAE;AAC1F,kBAAsG,EAAE;AACxG,kBAAuF,EAAE;AACzF,kBAAoF,EAAE;AAEtF,kBAAuJ,EAAE;AACzJ,kBAA6H,EAAE;AAC/H,kBAA+H,EAAE;AACjI,kBAAiI,EAAE;AAG5H,SAAS,eAKd;IACA,OAAQ,IAAM,KAAA;AAChB;AAEA,kBAAkF,EAAE;AACpF,kBAAoF,EAAE;AACtF,kBAAkG,EAAE;AACpG,kBAA8E,EAAE;AAChF,kBAAkF,EAAE;AACpF,kBAA4G,EAAE;AAC9G,kBAA4G,EAAE;AAC9G,kBAAsH,EAAE;AACxH,kBAA8I,EAAE;AAChJ,kBAAoH,EAAE;AACtH,kBAAsH,EAAE;AACxH,kBAAwH,EAAE","debugId":null}},
    {"offset": {"line": 634, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/objects.tsx"],"sourcesContent":["import { StackAssertionError } from \"./errors\";\nimport { identity } from \"./functions\";\nimport { stringCompare } from \"./strings\";\nimport { typeAssertIs } from \"./types\";\n\nexport function isNotNull<T>(value: T): value is NonNullable<T> {\n  return value !== null && value !== undefined;\n}\nundefined?.test(\"isNotNull\", ({ expect }) => {\n  expect(isNotNull(null)).toBe(false);\n  expect(isNotNull(undefined)).toBe(false);\n  expect(isNotNull(0)).toBe(true);\n  expect(isNotNull(\"\")).toBe(true);\n  expect(isNotNull(false)).toBe(true);\n  expect(isNotNull({})).toBe(true);\n  expect(isNotNull([])).toBe(true);\n});\n\nexport type DeepPartial<T> = T extends object ? (T extends any[] ? { [P in keyof T]: DeepPartial<T[P]> } : { [P in keyof T]?: DeepPartial<T[P]> }) : T;\nexport type DeepRequired<T> = T extends object ? { [P in keyof T]-?: DeepRequired<T[P]> } : T;\nexport type DeepRequiredOrUndefined<T> = T extends object ? { [P in keyof { [K in keyof T]-?: K}]: DeepRequiredOrUndefined<T[P]> } : T;\n\n\n/**\n * Assumes both objects are primitives, arrays, or non-function plain objects, and compares them deeply.\n *\n * Note that since they are assumed to be plain objects, this function does not compare prototypes.\n */\nexport function deepPlainEquals<T>(obj1: T, obj2: unknown, options: { ignoreUndefinedValues?: boolean } = {}): obj2 is T {\n  if (typeof obj1 !== typeof obj2) return false;\n  if (obj1 === obj2) return true;\n\n  switch (typeof obj1) {\n    case 'object': {\n      if (!obj1 || !obj2) return false;\n\n      if (Array.isArray(obj1) || Array.isArray(obj2)) {\n        if (!Array.isArray(obj1) || !Array.isArray(obj2)) return false;\n        if (obj1.length !== obj2.length) return false;\n        return obj1.every((v, i) => deepPlainEquals(v, obj2[i], options));\n      }\n\n      const entries1 = Object.entries(obj1).filter(([k, v]) => !options.ignoreUndefinedValues || v !== undefined);\n      const entries2 = Object.entries(obj2).filter(([k, v]) => !options.ignoreUndefinedValues || v !== undefined);\n      if (entries1.length !== entries2.length) return false;\n      return entries1.every(([k, v1]) => {\n        const e2 = entries2.find(([k2]) => k === k2);\n        if (!e2) return false;\n        return deepPlainEquals(v1, e2[1], options);\n      });\n    }\n    case 'undefined':\n    case 'string':\n    case 'number':\n    case 'boolean':\n    case 'bigint':\n    case 'symbol':\n    case 'function':{\n      return false;\n    }\n    default: {\n      throw new Error(\"Unexpected typeof \" + typeof obj1);\n    }\n  }\n}\nundefined?.test(\"deepPlainEquals\", ({ expect }) => {\n  // Simple values\n  expect(deepPlainEquals(1, 1)).toBe(true);\n  expect(deepPlainEquals(\"test\", \"test\")).toBe(true);\n  expect(deepPlainEquals(1, 2)).toBe(false);\n  expect(deepPlainEquals(\"test\", \"other\")).toBe(false);\n\n  // Arrays\n  expect(deepPlainEquals([1, 2, 3], [1, 2, 3])).toBe(true);\n  expect(deepPlainEquals([1, 2, 3], [1, 2, 4])).toBe(false);\n  expect(deepPlainEquals([1, 2, 3], [1, 2])).toBe(false);\n\n  // Objects\n  expect(deepPlainEquals({ a: 1, b: 2 }, { a: 1, b: 2 })).toBe(true);\n  expect(deepPlainEquals({ a: 1, b: 2 }, { a: 1, b: 3 })).toBe(false);\n  expect(deepPlainEquals({ a: 1, b: 2 }, { a: 1 })).toBe(false);\n\n  // Nested structures\n  expect(deepPlainEquals({ a: 1, b: [1, 2, { c: 3 }] }, { a: 1, b: [1, 2, { c: 3 }] })).toBe(true);\n  expect(deepPlainEquals({ a: 1, b: [1, 2, { c: 3 }] }, { a: 1, b: [1, 2, { c: 4 }] })).toBe(false);\n\n  // With options\n  expect(deepPlainEquals({ a: 1, b: undefined }, { a: 1 }, { ignoreUndefinedValues: true })).toBe(true);\n  expect(deepPlainEquals({ a: 1, b: undefined }, { a: 1 })).toBe(false);\n});\n\nexport function isCloneable<T>(obj: T): obj is Exclude<T, symbol | Function> {\n  return typeof obj !== 'symbol' && typeof obj !== 'function';\n}\n\nexport function shallowClone<T extends object>(obj: T): T {\n  if (!isCloneable(obj)) throw new StackAssertionError(\"shallowClone does not support symbols or functions\", { obj });\n\n  if (Array.isArray(obj)) return obj.map(identity) as T;\n  return { ...obj };\n}\nundefined?.test(\"shallowClone\", ({ expect }) => {\n  expect(shallowClone({ a: 1, b: 2 })).toEqual({ a: 1, b: 2 });\n  expect(shallowClone([1, 2, 3])).toEqual([1, 2, 3]);\n  expect(() => shallowClone(() => {})).toThrow();\n});\n\nexport function deepPlainClone<T>(obj: T): T {\n  if (typeof obj === 'function') throw new StackAssertionError(\"deepPlainClone does not support functions\");\n  if (typeof obj === 'symbol') throw new StackAssertionError(\"deepPlainClone does not support symbols\");\n  if (typeof obj !== 'object' || !obj) return obj;\n  if (Array.isArray(obj)) return obj.map(deepPlainClone) as any;\n  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, deepPlainClone(v)])) as any;\n}\nundefined?.test(\"deepPlainClone\", ({ expect }) => {\n  // Primitive values\n  expect(deepPlainClone(1)).toBe(1);\n  expect(deepPlainClone(\"test\")).toBe(\"test\");\n  expect(deepPlainClone(null)).toBe(null);\n  expect(deepPlainClone(undefined)).toBe(undefined);\n\n  // Arrays\n  const arr = [1, 2, 3];\n  const clonedArr = deepPlainClone(arr);\n  expect(clonedArr).toEqual(arr);\n  expect(clonedArr).not.toBe(arr); // Different reference\n\n  // Objects\n  const obj = { a: 1, b: 2 };\n  const clonedObj = deepPlainClone(obj);\n  expect(clonedObj).toEqual(obj);\n  expect(clonedObj).not.toBe(obj); // Different reference\n\n  // Nested structures\n  const nested = { a: 1, b: [1, 2, { c: 3 }] };\n  const clonedNested = deepPlainClone(nested);\n  expect(clonedNested).toEqual(nested);\n  expect(clonedNested).not.toBe(nested); // Different reference\n  expect(clonedNested.b).not.toBe(nested.b); // Different reference for nested array\n  expect(clonedNested.b[2]).not.toBe(nested.b[2]); // Different reference for nested object\n\n  // Error cases\n  expect(() => deepPlainClone(() => {})).toThrow();\n  expect(() => deepPlainClone(Symbol())).toThrow();\n});\n\nexport type DeepMerge<T, U> = U extends any ? DeepMergeNonDistributive<T, U> : never;  // distributive conditional type https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\ntype DeepMergeNonDistributive<T, U> = Omit<T, keyof U> & Omit<U, keyof T> & DeepMergeInner<Pick<T, keyof U & keyof T>, Pick<U, keyof U & keyof T>>;\ntype DeepMergeInner<T, U> = {\n  [K in { [Ki in keyof U]-?: Ki }[keyof U]]:  // we use this weird construct instead of just `keyof U` because TypeScript automatically removes the `undefined` key when using `-?` as a modifier; this is a workaround to make TypeScript not recognize the -? and for us to get the `undefined` key back\n    undefined extends U[K]\n      ? K extends keyof T\n          ? T[K] extends object\n              ? Exclude<U[K], undefined> extends object\n                  ? DeepMerge<T[K], Exclude<U[K], undefined>>\n                  : T[K] | Exclude<U[K], undefined>\n              : T[K] | Exclude<U[K], undefined>\n          : Exclude<U[K], undefined>\n      : K extends keyof T\n          ? T[K] extends object\n              ? U[K] extends object\n                  ? DeepMerge<T[K], U[K]>\n                  : U[K]\n              : U[K]\n          : U[K];\n};\nexport function deepMerge<T extends {}, U extends {}>(baseObj: T, mergeObj: U): DeepMerge<T, U> {\n  if ([baseObj, mergeObj, ...Object.values(baseObj), ...Object.values(mergeObj)].some(o => !isCloneable(o))) throw new StackAssertionError(\"deepMerge does not support functions or symbols\", { baseObj, mergeObj });\n\n  const res: any = shallowClone(baseObj);\n  for (const [key, mergeValue] of Object.entries(mergeObj)) {\n    if (has(res, key as any)) {\n      const baseValue = get(res, key as any);\n      if (isObjectLike(baseValue) && isObjectLike(mergeValue)) {\n        set(res, key, deepMerge(baseValue, mergeValue));\n        continue;\n      }\n    }\n    set(res, key, mergeValue);\n  }\n  return res as any;\n}\nundefined?.test(\"deepMerge\", ({ expect }) => {\n  // Test merging flat objects\n  expect(deepMerge({ a: 1 }, { b: 2 })).toEqual({ a: 1, b: 2 });\n  expect(deepMerge({ a: 1 }, { a: 2 })).toEqual({ a: 2 });\n  expect(deepMerge({ a: 1, b: 2 }, { b: 3, c: 4 })).toEqual({ a: 1, b: 3, c: 4 });\n\n  // Test with nested objects\n  expect(deepMerge(\n    { a: { x: 1, y: 2 }, b: 3 },\n    { a: { y: 3, z: 4 }, c: 5 }\n  )).toEqual({ a: { x: 1, y: 3, z: 4 }, b: 3, c: 5 });\n\n  // Test with arrays\n  expect(deepMerge(\n    { a: [1, 2], b: 3 },\n    { a: [3, 4], c: 5 }\n  )).toEqual({ a: [3, 4], b: 3, c: 5 });\n\n  // Test with null values\n  expect(deepMerge(\n    { a: { x: 1 }, b: null },\n    { a: { y: 2 }, b: { z: 3 } }\n  )).toEqual({ a: { x: 1, y: 2 }, b: { z: 3 } });\n\n  // Test with undefined values\n  expect(deepMerge(\n    { a: 1, b: undefined },\n    { b: 2, c: 3 }\n  )).toEqual({ a: 1, b: 2, c: 3 });\n\n  // Test deeply nested structures\n  expect(deepMerge(\n    {\n      a: {\n        x: { deep: 1 },\n        y: [1, 2]\n      },\n      b: 2\n    },\n    {\n      a: {\n        x: { deeper: 3 },\n        y: [3, 4]\n      },\n      c: 3\n    }\n  )).toEqual({\n    a: {\n      x: { deep: 1, deeper: 3 },\n      y: [3, 4]\n    },\n    b: 2,\n    c: 3\n  });\n\n  // Test with empty objects\n  expect(deepMerge({}, { a: 1 })).toEqual({ a: 1 });\n  expect(deepMerge({ a: 1 }, {})).toEqual({ a: 1 });\n  expect(deepMerge({}, {})).toEqual({});\n\n  // Test that original objects are not modified\n  const base = { a: { x: 1 }, b: 2 };\n  const merge = { a: { y: 2 }, c: 3 };\n  const baseClone = deepPlainClone(base);\n  const mergeClone = deepPlainClone(merge);\n\n  const result = deepMerge(base, merge);\n  expect(base).toEqual(baseClone);\n  expect(merge).toEqual(mergeClone);\n  expect(result).toEqual({ a: { x: 1, y: 2 }, b: 2, c: 3 });\n\n  // Test error cases\n  expect(() => deepMerge({ a: () => {} }, { b: 2 })).toThrow();\n  expect(() => deepMerge({ a: 1 }, { b: () => {} })).toThrow();\n  expect(() => deepMerge({ a: Symbol() }, { b: 2 })).toThrow();\n  expect(() => deepMerge({ a: 1 }, { b: Symbol() })).toThrow();\n});\n\nexport type DeepOmit<T, U> = T extends object ? { [K in keyof T]: K extends keyof U ? (T[K] extends U[K] ? undefined : T[K]) : T[K] } : (T extends U ? undefined : T);\n\nexport function typedEntries<T extends {}>(obj: T): [Exclude<keyof T, number>, T[keyof T]][] {\n  return Object.entries(obj) as any;\n}\nundefined?.test(\"typedEntries\", ({ expect }) => {\n  expect(typedEntries({})).toEqual([]);\n  expect(typedEntries({ a: 1, b: 2 })).toEqual([[\"a\", 1], [\"b\", 2]]);\n  expect(typedEntries({ a: \"hello\", b: true, c: null })).toEqual([[\"a\", \"hello\"], [\"b\", true], [\"c\", null]]);\n\n  // Test with object containing methods\n  const objWithMethod = { a: 1, b: () => \"test\" };\n  const entries = typedEntries(objWithMethod);\n  expect(entries.length).toBe(2);\n  expect(entries[0][0]).toBe(\"a\");\n  expect(entries[0][1]).toBe(1);\n  expect(entries[1][0]).toBe(\"b\");\n  expect(typeof entries[1][1]).toBe(\"function\");\n});\n\nexport function typedFromEntries<K extends PropertyKey, V>(entries: (readonly [K, V])[]): Record<K, V> {\n  return Object.fromEntries(entries) as any;\n}\nundefined?.test(\"typedFromEntries\", ({ expect }) => {\n  expect(typedFromEntries([])).toEqual({});\n  expect(typedFromEntries([[\"a\", 1], [\"b\", 2]])).toEqual({ a: 1, b: 2 });\n\n  // Test with mixed types (using type assertion)\n  const mixedEntries = [[\"a\", \"hello\"], [\"b\", true], [\"c\", null]] as [string, string | boolean | null][];\n  const mixedObj = typedFromEntries(mixedEntries);\n  expect(mixedObj).toEqual({ a: \"hello\", b: true, c: null });\n\n  // Test with function values\n  const fn = () => \"test\";\n  type MixedValue = number | (() => string);\n  const fnEntries: [string, MixedValue][] = [[\"a\", 1], [\"b\", fn]];\n  const obj = typedFromEntries(fnEntries);\n  expect(obj.a).toBe(1);\n  expect(typeof obj.b).toBe(\"function\");\n  // Type assertion needed for the function call\n  expect((obj.b as () => string)()).toBe(\"test\");\n});\n\nexport function typedKeys<T extends {}>(obj: T): (Exclude<keyof T, number>)[] {\n  return Object.keys(obj) as any;\n}\nundefined?.test(\"typedKeys\", ({ expect }) => {\n  expect(typedKeys({})).toEqual([]);\n  expect(typedKeys({ a: 1, b: 2 })).toEqual([\"a\", \"b\"]);\n  expect(typedKeys({ a: \"hello\", b: true, c: null })).toEqual([\"a\", \"b\", \"c\"]);\n\n  // Test with object containing methods\n  const objWithMethod = { a: 1, b: () => \"test\" };\n  expect(typedKeys(objWithMethod)).toEqual([\"a\", \"b\"]);\n});\n\nexport function typedValues<T extends {}>(obj: T): T[keyof T][] {\n  return Object.values(obj) as any;\n}\nundefined?.test(\"typedValues\", ({ expect }) => {\n  expect(typedValues({})).toEqual([]);\n  expect(typedValues({ a: 1, b: 2 })).toEqual([1, 2]);\n\n  // Test with mixed types\n  type MixedObj = { a: string, b: boolean, c: null };\n  const mixedObj: MixedObj = { a: \"hello\", b: true, c: null };\n  expect(typedValues(mixedObj)).toEqual([\"hello\", true, null]);\n\n  // Test with object containing methods\n  type ObjWithFn = { a: number, b: () => string };\n  const fn = () => \"test\";\n  const objWithMethod: ObjWithFn = { a: 1, b: fn };\n  const values = typedValues(objWithMethod);\n  expect(values.length).toBe(2);\n  expect(values[0]).toBe(1);\n  expect(typeof values[1]).toBe(\"function\");\n  // Need to cast to the correct type\n  const fnValue = values[1] as () => string;\n  expect(fnValue()).toBe(\"test\");\n});\n\nexport function typedAssign<T extends {}, U extends {}>(target: T, source: U): T & U {\n  return Object.assign(target, source);\n}\nundefined?.test(\"typedAssign\", ({ expect }) => {\n  // Test with empty objects\n  const emptyTarget = {};\n  const emptyResult = typedAssign(emptyTarget, { a: 1 });\n  expect(emptyResult).toEqual({ a: 1 });\n  expect(emptyResult).toBe(emptyTarget); // Same reference\n\n  // Test with non-empty target\n  const target = { a: 1, b: 2 };\n  const result = typedAssign(target, { c: 3, d: 4 });\n  expect(result).toEqual({ a: 1, b: 2, c: 3, d: 4 });\n  expect(result).toBe(target); // Same reference\n\n  // Test with overlapping properties\n  const targetWithOverlap = { a: 1, b: 2 };\n  const resultWithOverlap = typedAssign(targetWithOverlap, { b: 3, c: 4 });\n  expect(resultWithOverlap).toEqual({ a: 1, b: 3, c: 4 });\n  expect(resultWithOverlap).toBe(targetWithOverlap); // Same reference\n});\n\nexport type FilterUndefined<T> =\n  & { [k in keyof T as (undefined extends T[k] ? (T[k] extends undefined | void ? never : k) : never)]+?: T[k] & ({} | null) }\n  & { [k in keyof T as (undefined extends T[k] ? never : k)]: T[k] & ({} | null) }\n\n/**\n * Returns a new object with all undefined values removed. Useful when spreading optional parameters on an object, as\n * TypeScript's `Partial<XYZ>` type allows `undefined` values.\n */\nexport function filterUndefined<T extends object>(obj: T): FilterUndefined<T> {\n  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined)) as any;\n}\nundefined?.test(\"filterUndefined\", ({ expect }) => {\n  expect(filterUndefined({})).toEqual({});\n  expect(filterUndefined({ a: 1, b: 2 })).toEqual({ a: 1, b: 2 });\n  expect(filterUndefined({ a: 1, b: undefined })).toEqual({ a: 1 });\n  expect(filterUndefined({ a: undefined, b: undefined })).toEqual({});\n  expect(filterUndefined({ a: null, b: undefined })).toEqual({ a: null });\n  expect(filterUndefined({ a: 0, b: \"\", c: false, d: undefined })).toEqual({ a: 0, b: \"\", c: false });\n});\n\nexport type FilterUndefinedOrNull<T> = FilterUndefined<{ [k in keyof T]: null extends T[k] ? NonNullable<T[k]> | undefined : T[k] }>;\n\n/**\n * Returns a new object with all undefined and null values removed. Useful when spreading optional parameters on an object, as\n * TypeScript's `Partial<XYZ>` type allows `undefined` values.\n */\nexport function filterUndefinedOrNull<T extends object>(obj: T): FilterUndefinedOrNull<T> {\n  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined && v !== null)) as any;\n}\nundefined?.test(\"filterUndefinedOrNull\", ({ expect }) => {\n  expect(filterUndefinedOrNull({})).toEqual({});\n  expect(filterUndefinedOrNull({ a: 1, b: 2 })).toEqual({ a: 1, b: 2 });\n});\n\nexport type DeepFilterUndefined<T> = T extends object ? FilterUndefined<{ [K in keyof T]: DeepFilterUndefined<T[K]> }> : T;\ntypeAssertIs<DeepFilterUndefined<{ a: { b: { c?: undefined, d?: 123 } } }>, { a: { b: { d?: 123 } } }>()();\n\nexport function deepFilterUndefined<T extends object>(obj: T): DeepFilterUndefined<T> {\n  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined).map(([k, v]) => [k, isObjectLike(v) ? deepFilterUndefined(v) : v])) as any;\n}\nundefined?.test(\"deepFilterUndefined\", ({ expect }) => {\n  expect(deepFilterUndefined({ a: 1, b: undefined })).toEqual({ a: 1 });\n});\n\nexport function pick<T extends {}, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  return Object.fromEntries(Object.entries(obj).filter(([k]) => keys.includes(k as K))) as any;\n}\nundefined?.test(\"pick\", ({ expect }) => {\n  const obj = { a: 1, b: 2, c: 3, d: 4 };\n  expect(pick(obj, [\"a\", \"c\"])).toEqual({ a: 1, c: 3 });\n  expect(pick(obj, [])).toEqual({});\n  expect(pick(obj, [\"a\", \"e\" as keyof typeof obj])).toEqual({ a: 1 });\n  // Use type assertion for empty object to avoid TypeScript error\n  expect(pick({} as Record<string, unknown>, [\"a\"])).toEqual({});\n});\n\nexport function omit<T extends {}, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n  if (!Array.isArray(keys)) throw new StackAssertionError(\"omit: keys must be an array\", { obj, keys });\n  return Object.fromEntries(Object.entries(obj).filter(([k]) => !keys.includes(k as K))) as any;\n}\nundefined?.test(\"omit\", ({ expect }) => {\n  const obj = { a: 1, b: 2, c: 3, d: 4 };\n  expect(omit(obj, [\"a\", \"c\"])).toEqual({ b: 2, d: 4 });\n  expect(omit(obj, [])).toEqual(obj);\n  expect(omit(obj, [\"a\", \"e\" as keyof typeof obj])).toEqual({ b: 2, c: 3, d: 4 });\n  // Use type assertion for empty object to avoid TypeScript error\n  expect(omit({} as Record<string, unknown>, [\"a\"])).toEqual({});\n});\n\nexport function split<T extends {}, K extends keyof T>(obj: T, keys: K[]): [Pick<T, K>, Omit<T, K>] {\n  return [pick(obj, keys), omit(obj, keys)];\n}\nundefined?.test(\"split\", ({ expect }) => {\n  const obj = { a: 1, b: 2, c: 3, d: 4 };\n  expect(split(obj, [\"a\", \"c\"])).toEqual([{ a: 1, c: 3 }, { b: 2, d: 4 }]);\n  expect(split(obj, [])).toEqual([{}, obj]);\n  expect(split(obj, [\"a\", \"e\" as keyof typeof obj])).toEqual([{ a: 1 }, { b: 2, c: 3, d: 4 }]);\n  // Use type assertion for empty object to avoid TypeScript error\n  expect(split({} as Record<string, unknown>, [\"a\"])).toEqual([{}, {}]);\n});\n\nexport function mapValues<T extends object, U>(obj: T, fn: (value: T extends (infer E)[] ? E : T[keyof T]) => U): Record<keyof T, U> {\n  if (Array.isArray(obj)) {\n    return obj.map(v => fn(v)) as any;\n  }\n  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fn(v)])) as any;\n}\nundefined?.test(\"mapValues\", ({ expect }) => {\n  expect(mapValues({ a: 1, b: 2 }, v => v * 2)).toEqual({ a: 2, b: 4 });\n  expect(mapValues([1, 2, 3], v => v * 2)).toEqual([2, 4, 6]);\n});\n\nexport function sortKeys<T extends object>(obj: T): T {\n  if (Array.isArray(obj)) {\n    return [...obj] as any;\n  }\n  return Object.fromEntries(Object.entries(obj).sort(([a], [b]) => stringCompare(a, b))) as any;\n}\nundefined?.test(\"sortKeys\", ({ expect }) => {\n  const obj = {\n    \"1\": 0,\n    \"10\": 1,\n    b: 2,\n    \"2\": 3,\n    a: 4,\n    \"-3.33\": 5,\n    \"-4\": 6,\n    \"-3\": 7,\n    abc: 8,\n    \"a-b\": 9,\n    ab: 10,\n    ac: 11,\n    aa: 12,\n    aab: 13,\n  };\n  expect(Object.entries(sortKeys(obj))).toEqual([\n    [\"1\", 0],\n    [\"2\", 3],\n    [\"10\", 1],\n    [\"-3\", 7],\n    [\"-3.33\", 5],\n    [\"-4\", 6],\n    [\"a\", 4],\n    [\"a-b\", 9],\n    [\"aa\", 12],\n    [\"aab\", 13],\n    [\"ab\", 10],\n    [\"abc\", 8],\n    [\"ac\", 11],\n    [\"b\", 2],\n  ]);\n});\n\nexport function deepSortKeys<T extends object>(obj: T): T {\n  return sortKeys(mapValues(obj, v => isObjectLike(v) ? deepSortKeys(v) : v)) as any;\n}\nundefined?.test(\"deepSortKeys\", ({ expect }) => {\n  const obj = {\n    h: { i: { k: 9, j: 8 }, l: 10 },\n    b: { d: 3, c: 2 },\n    a: 1,\n    e: [4, 5, { g: 7, f: 6 }],\n  };\n  const sorted = deepSortKeys(obj);\n  expect(Object.entries(sorted)).toEqual([\n    [\"a\", 1],\n    [\"b\", { c: 2, d: 3 }],\n    [\"e\", [4, 5, { f: 6, g: 7 }]],\n    [\"h\", { i: { j: 8, k: 9 }, l: 10 }],\n  ]);\n  expect(Object.entries(sorted.b)).toEqual([\n    [\"c\", 2],\n    [\"d\", 3],\n  ]);\n  expect(Object.entries(sorted.e[2])).toEqual([\n    [\"f\", 6],\n    [\"g\", 7],\n  ]);\n  expect(Object.entries(sorted.h)).toEqual([\n    [\"i\", { j: 8, k: 9 }],\n    [\"l\", 10],\n  ]);\n  expect(Object.entries(sorted.h.i)).toEqual([\n    [\"j\", 8],\n    [\"k\", 9],\n  ]);\n});\n\nexport function set<T extends object, K extends keyof T>(obj: T, key: K, value: T[K]) {\n  Object.defineProperty(obj, key, { value, writable: true, configurable: true, enumerable: true });\n}\n\nexport function get<T extends object, K extends keyof T>(obj: T, key: K): T[K] {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  if (!descriptor) throw new StackAssertionError(`get: key ${String(key)} does not exist`, { obj, key });\n  return descriptor.value;\n}\n\nexport function getOrUndefined<T extends object, K extends keyof T>(obj: T, key: K): T[K] | undefined {\n  return has(obj, key) ? get(obj, key) : undefined;\n}\n\nexport function has<T extends object, K extends keyof T>(obj: T, key: K): obj is T & { [k in K]: unknown } {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nundefined?.test(\"has\", ({ expect }) => {\n  const obj = { a: 1, b: undefined, c: null };\n  expect(has(obj, \"a\")).toBe(true);\n  expect(has(obj, \"b\")).toBe(true);\n  expect(has(obj, \"c\")).toBe(true);\n  expect(has(obj, \"d\" as keyof typeof obj)).toBe(false);\n});\n\n\nexport function hasAndNotUndefined<T extends object, K extends keyof T>(obj: T, key: K): obj is T & { [k in K]: Exclude<T[K], undefined> } {\n  return has(obj, key) && get(obj, key) !== undefined;\n}\n\nexport function deleteKey<T extends object, K extends keyof T>(obj: T, key: K) {\n  if (has(obj, key)) {\n    Reflect.deleteProperty(obj, key);\n  } else {\n    throw new StackAssertionError(`deleteKey: key ${String(key)} does not exist`, { obj, key });\n  }\n}\n\n/**\n * Returns true iff the value is an object or a function, but not null.\n */\nexport function isObjectLike(value: unknown): value is object | Function {\n  return (typeof value === 'object' || typeof value === 'function') && value !== null;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 903, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/errors.tsx"],"sourcesContent":["import { globalVar } from \"./globals\";\nimport { Json } from \"./json\";\nimport { pick } from \"./objects\";\nimport { nicify } from \"./strings\";\n\n\nexport function throwErr(errorMessage: string, extraData?: any): never;\nexport function throwErr(error: Error): never;\nexport function throwErr(...args: StatusErrorConstructorParameters): never;\nexport function throwErr(...args: any[]): never {\n  if (typeof args[0] === \"string\") {\n    throw new StackAssertionError(args[0], args[1]);\n  } else if (args[0] instanceof Error) {\n    throw args[0];\n  } else {\n    // @ts-expect-error\n    throw new StatusError(...args);\n  }\n}\n\nfunction removeStacktraceNameLine(stack: string): string {\n  // some browsers (eg. Chrome) prepend the stack with an extra line with the error name\n  const addsNameLine = new Error().stack?.startsWith(\"Error\\n\");\n  return stack.split(\"\\n\").slice(addsNameLine ? 1 : 0).join(\"\\n\");\n}\n\n\n/**\n * Concatenates the (original) stacktraces of the given errors onto the first.\n *\n * Note: Very often, the concatStacktracesIfRejected function in promises.tsx is an easier way to use this function.\n *\n * Useful when you invoke an async function to receive a promise without awaiting it immediately. Browsers are smart\n * enough to keep track of the call stack in async function calls when you invoke `.then` within the same async tick,\n * but if you don't, the stacktrace will be lost.\n *\n * Here's an example of the unwanted behavior:\n *\n * ```tsx\n * async function log() {\n *   await wait(0);  // put the task on the event loop\n *   console.log(new Error().stack);\n * }\n *\n * async function main() {\n *   await log();  // good; prints both \"log\" and \"main\" on the stacktrace\n *   log();  // bad; prints only \"log\" on the stacktrace\n * }\n * ```\n */\nexport function concatStacktraces(first: Error, ...errors: Error[]): void {\n  // some browsers (eg. Firefox) add an extra empty line at the end\n  const addsEmptyLineAtEnd = first.stack?.endsWith(\"\\n\");\n\n\n  // Add a reference to this function itself so that we know that stacktraces were concatenated\n  // If you are coming here from a stacktrace, please know that the two parts before and after this line are different\n  // stacktraces that were concatenated with concatStacktraces\n  const separator = removeStacktraceNameLine(new Error().stack ?? \"\").split(\"\\n\")[0];\n\n\n  for (const error of errors) {\n    const toAppend = removeStacktraceNameLine(error.stack ?? \"\");\n    first.stack += (addsEmptyLineAtEnd ? \"\" : \"\\n\") + separator + \"\\n\" + toAppend;\n  }\n}\n\n\nexport class StackAssertionError extends Error {\n  constructor(message: string, public readonly extraData?: Record<string, any> & ErrorOptions) {\n    const disclaimer = `\\n\\nThis is likely an error in Stack. Please make sure you are running the newest version and report it.`;\n    super(`${message}${message.endsWith(disclaimer) ? \"\" : disclaimer}`, pick(extraData ?? {}, [\"cause\"]));\n\n    Object.defineProperty(this, \"customCaptureExtraArgs\", {\n      get() {\n        return [this.extraData];\n      },\n      enumerable: false,\n    });\n\n    if (process.env.NEXT_PUBLIC_STACK_DEBUGGER_ON_ASSERTION_ERROR === \"true\") {\n      debugger;\n    }\n  }\n}\nStackAssertionError.prototype.name = \"StackAssertionError\";\n\n\nexport function errorToNiceString(error: unknown): string {\n  if (!(error instanceof Error)) return `${typeof error}<${nicify(error)}>`;\n  return nicify(error, { maxDepth: 8 });\n}\n\n\nconst errorSinks = new Set<(location: string, error: unknown, ...extraArgs: unknown[]) => void>();\nexport function registerErrorSink(sink: (location: string, error: unknown) => void): void {\n  if (errorSinks.has(sink)) {\n    return;\n  }\n  errorSinks.add(sink);\n}\nregisterErrorSink((location, error, ...extraArgs) => {\n  console.error(\n    `\\x1b[41mCaptured error in ${location}:`,\n    // HACK: Log a nicified version of the error to get around buggy Next.js pretty-printing\n    // https://www.reddit.com/r/nextjs/comments/1gkxdqe/comment/m19kxgn/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button\n    errorToNiceString(error),\n    ...extraArgs,\n    \"\\x1b[0m\",\n  );\n});\nregisterErrorSink((location, error, ...extraArgs) => {\n  globalVar.stackCapturedErrors = globalVar.stackCapturedErrors ?? [];\n  globalVar.stackCapturedErrors.push({ location, error, extraArgs });\n});\n\n/**\n * Captures an error and sends it to the error sinks (most notably, Sentry). Errors caught with captureError are\n * supposed to be seen by an engineer, so they should be actionable and important.\n *\n * The location string is a machine-readable ID, and should hence not contain spaces or anything like that. Good\n * examples are: \"api-route-handler\", \"renderPart()\", etc.\n *\n * Errors that bubble up to the top of runAsynchronously or a route handler are already captured with captureError.\n */\nexport function captureError(location: string, error: unknown): void {\n  for (const sink of errorSinks) {\n    sink(\n      location,\n      error,\n      ...error && (typeof error === 'object' || typeof error === 'function') && \"customCaptureExtraArgs\" in error && Array.isArray(error.customCaptureExtraArgs) ? (error.customCaptureExtraArgs as any[]) : [],\n    );\n  }\n}\n\n\ntype Status = {\n  statusCode: number,\n  message: string,\n};\n\ntype StatusErrorConstructorParameters =\n| [\n  status: Status,\n  message?: string\n]\n| [\n  statusCode: number | Status,\n  message: string,\n];\n\nexport class StatusError extends Error {\n  private readonly __stackStatusErrorBrand = \"stack-status-error-brand-sentinel\" as const;\n  public name = \"StatusError\";\n  public readonly statusCode: number;\n\n  public static BadRequest = { statusCode: 400, message: \"Bad Request\" };\n  public static Unauthorized = { statusCode: 401, message: \"Unauthorized\" };\n  public static PaymentRequired = { statusCode: 402, message: \"Payment Required\" };\n  public static Forbidden = { statusCode: 403, message: \"Forbidden\" };\n  public static NotFound = { statusCode: 404, message: \"Not Found\" };\n  public static MethodNotAllowed = { statusCode: 405, message: \"Method Not Allowed\" };\n  public static NotAcceptable = { statusCode: 406, message: \"Not Acceptable\" };\n  public static ProxyAuthenticationRequired = { statusCode: 407, message: \"Proxy Authentication Required\" };\n  public static RequestTimeout = { statusCode: 408, message: \"Request Timeout\" };\n  public static Conflict = { statusCode: 409, message: \"Conflict\" };\n  public static Gone = { statusCode: 410, message: \"Gone\" };\n  public static LengthRequired = { statusCode: 411, message: \"Length Required\" };\n  public static PreconditionFailed = { statusCode: 412, message: \"Precondition Failed\" };\n  public static PayloadTooLarge = { statusCode: 413, message: \"Payload Too Large\" };\n  public static URITooLong = { statusCode: 414, message: \"URI Too Long\" };\n  public static UnsupportedMediaType = { statusCode: 415, message: \"Unsupported Media Type\" };\n  public static RangeNotSatisfiable = { statusCode: 416, message: \"Range Not Satisfiable\" };\n  public static ExpectationFailed = { statusCode: 417, message: \"Expectation Failed\" };\n  public static ImATeapot = { statusCode: 418, message: \"I'm a teapot\" };\n  public static MisdirectedRequest = { statusCode: 421, message: \"Misdirected Request\" };\n  public static UnprocessableEntity = { statusCode: 422, message: \"Unprocessable Entity\" };\n  public static Locked = { statusCode: 423, message: \"Locked\" };\n  public static FailedDependency = { statusCode: 424, message: \"Failed Dependency\" };\n  public static TooEarly = { statusCode: 425, message: \"Too Early\" };\n  public static UpgradeRequired = { statusCode: 426, message: \"Upgrade Required\" };\n  public static PreconditionRequired = { statusCode: 428, message: \"Precondition Required\" };\n  public static TooManyRequests = { statusCode: 429, message: \"Too Many Requests\" };\n  public static RequestHeaderFieldsTooLarge = { statusCode: 431, message: \"Request Header Fields Too Large\" };\n  public static UnavailableForLegalReasons = { statusCode: 451, message: \"Unavailable For Legal Reasons\" };\n\n  public static InternalServerError = { statusCode: 500, message: \"Internal Server Error\" };\n  public static NotImplemented = { statusCode: 501, message: \"Not Implemented\" };\n  public static BadGateway = { statusCode: 502, message: \"Bad Gateway\" };\n  public static ServiceUnavailable = { statusCode: 503, message: \"Service Unavailable\" };\n  public static GatewayTimeout = { statusCode: 504, message: \"Gateway Timeout\" };\n  public static HTTPVersionNotSupported = { statusCode: 505, message: \"HTTP Version Not Supported\" };\n  public static VariantAlsoNegotiates = { statusCode: 506, message: \"Variant Also Negotiates\" };\n  public static InsufficientStorage = { statusCode: 507, message: \"Insufficient Storage\" };\n  public static LoopDetected = { statusCode: 508, message: \"Loop Detected\" };\n  public static NotExtended = { statusCode: 510, message: \"Not Extended\" };\n  public static NetworkAuthenticationRequired = { statusCode: 511, message: \"Network Authentication Required\" };\n\n\n  constructor(...args: StatusErrorConstructorParameters);\n  constructor(\n    status: number | Status,\n    message?: string,\n  ) {\n    if (typeof status === \"object\") {\n      message ??= status.message;\n      status = status.statusCode;\n    }\n    super(message);\n    this.statusCode = status;\n    if (!message) {\n      throw new StackAssertionError(\"StatusError always requires a message unless a Status object is passed\", { cause: this });\n    }\n  }\n\n  public static isStatusError(error: unknown): error is StatusError {\n    // like instanceof, but also works for errors thrown in other realms or by different versions of the same package\n    return typeof error === \"object\" && error !== null && \"__stackStatusErrorBrand\" in error && error.__stackStatusErrorBrand === \"stack-status-error-brand-sentinel\";\n  }\n\n  public isClientError() {\n    return this.statusCode >= 400 && this.statusCode < 500;\n  }\n\n  public isServerError() {\n    return !this.isClientError();\n  }\n\n  public getStatusCode(): number {\n    return this.statusCode;\n  }\n\n  public getBody(): Uint8Array {\n    return new TextEncoder().encode(this.message);\n  }\n\n  public getHeaders(): Record<string, string[]> {\n    return {\n      \"Content-Type\": [\"text/plain; charset=utf-8\"],\n    };\n  }\n\n  public toDescriptiveJson(): Json {\n    return {\n      status_code: this.getStatusCode(),\n      message: this.message,\n      headers: this.getHeaders(),\n    };\n  }\n\n  /**\n   * @deprecated this is not a good way to make status errors human-readable, use toDescriptiveJson instead\n   */\n  public toHttpJson(): Json {\n    return {\n      status_code: this.statusCode,\n      body: this.message,\n      headers: this.getHeaders(),\n    };\n  }\n}\nStatusError.prototype.name = \"StatusError\";\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1232, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/known-errors.tsx"],"sourcesContent":["import { StackAssertionError, StatusError, throwErr } from \"./utils/errors\";\nimport { identityArgs } from \"./utils/functions\";\nimport { Json } from \"./utils/json\";\nimport { deindent } from \"./utils/strings\";\n\nexport type KnownErrorJson = {\n  code: string,\n  message: string,\n  details?: Json,\n};\n\nexport type AbstractKnownErrorConstructor<Args extends any[]> =\n  & (abstract new (...args: Args) => KnownError)\n  & {\n    constructorArgsFromJson: (json: KnownErrorJson) => Args,\n  };\n\nexport type KnownErrorConstructor<SuperInstance extends KnownError, Args extends any[]> = {\n  new (...args: Args): SuperInstance & { constructorArgs: Args },\n  errorCode: string,\n  constructorArgsFromJson: (json: KnownErrorJson) => Args,\n  isInstance: (error: unknown) => error is SuperInstance & { constructorArgs: Args },\n};\n\nexport abstract class KnownError extends StatusError {\n  private readonly __stackKnownErrorBrand = \"stack-known-error-brand-sentinel\" as const;\n  public name = \"KnownError\";\n\n  constructor(\n    public readonly statusCode: number,\n    public readonly humanReadableMessage: string,\n    public readonly details?: Json,\n  ) {\n    super(\n      statusCode,\n      humanReadableMessage\n    );\n  }\n\n  public static isKnownError(error: unknown): error is KnownError {\n    // like instanceof, but also works for errors thrown in other realms or by different versions of the same package\n    return typeof error === \"object\" && error !== null && \"__stackKnownErrorBrand\" in error && error.__stackKnownErrorBrand === \"stack-known-error-brand-sentinel\";\n  }\n\n  public override getBody(): Uint8Array {\n    return new TextEncoder().encode(JSON.stringify(this.toDescriptiveJson(), undefined, 2));\n  }\n\n  public override getHeaders(): Record<string, string[]> {\n    return {\n      \"Content-Type\": [\"application/json; charset=utf-8\"],\n      \"X-Stack-Known-Error\": [this.errorCode],\n    };\n  }\n\n  public override toDescriptiveJson(): Json {\n    return {\n      code: this.errorCode,\n      ...this.details ? { details: this.details } : {},\n      error: this.humanReadableMessage,\n    };\n  }\n\n  get errorCode(): string {\n    return (this.constructor as any).errorCode ?? throwErr(`Can't find error code for this KnownError. Is its constructor a KnownErrorConstructor? ${this}`);\n  }\n\n  public static constructorArgsFromJson(json: KnownErrorJson): ConstructorParameters<typeof KnownError> {\n    return [\n      400,\n      json.message,\n      json,\n    ];\n  }\n\n  public static fromJson(json: KnownErrorJson): KnownError {\n    for (const [_, KnownErrorType] of Object.entries(KnownErrors)) {\n      if (json.code === KnownErrorType.prototype.errorCode) {\n        const constructorArgs = KnownErrorType.constructorArgsFromJson(json);\n        return new KnownErrorType(\n          // @ts-ignore-next-line\n          ...constructorArgs,\n        );\n      }\n    }\n\n    throw new Error(`Unknown KnownError code. You may need to update your version of Stack to see more detailed information. ${json.code}: ${json.message}`);\n  }\n}\n\nconst knownErrorConstructorErrorCodeSentinel = Symbol(\"knownErrorConstructorErrorCodeSentinel\");\n/**\n * Exists solely so that known errors are nominative types (ie. two KnownErrors with the same interface are not the same type)\n */\ntype KnownErrorBrand<ErrorCode extends string> = {\n  /**\n   * Does not exist at runtime\n   *\n   * Must be an object because it may be true for multiple error codes (it's true for all parents)\n   */\n  [knownErrorConstructorErrorCodeSentinel]: {\n    [K in ErrorCode]: true\n  },\n};\n\nfunction createKnownErrorConstructor<ErrorCode extends string, Super extends AbstractKnownErrorConstructor<any>, Args extends any[]>(\n  SuperClass: Super,\n  errorCode: ErrorCode,\n  create: ((...args: Args) => Readonly<ConstructorParameters<Super>>),\n  constructorArgsFromJson: ((jsonDetails: any) => Args),\n): KnownErrorConstructor<InstanceType<Super> & KnownErrorBrand<ErrorCode>, Args> & { errorCode: ErrorCode };\nfunction createKnownErrorConstructor<ErrorCode extends string, Super extends AbstractKnownErrorConstructor<any>>(\n  SuperClass: Super,\n  errorCode: ErrorCode,\n  create: \"inherit\",\n  constructorArgsFromJson: \"inherit\",\n): KnownErrorConstructor<InstanceType<Super> & KnownErrorBrand<ErrorCode>, ConstructorParameters<Super>> & { errorCode: ErrorCode };\nfunction createKnownErrorConstructor<ErrorCode extends string, Super extends AbstractKnownErrorConstructor<any>, Args extends any[]>(\n  SuperClass: Super,\n  errorCode: ErrorCode,\n  create: \"inherit\" | ((...args: Args) => Readonly<ConstructorParameters<Super>>),\n  constructorArgsFromJson: \"inherit\" | ((jsonDetails: any) => Args),\n): KnownErrorConstructor<InstanceType<Super> & KnownErrorBrand<ErrorCode>, Args> & { errorCode: ErrorCode } {\n  const createFn = create === \"inherit\" ? identityArgs<Args> as never : create;\n  const constructorArgsFromJsonFn = constructorArgsFromJson === \"inherit\" ? SuperClass.constructorArgsFromJson as never : constructorArgsFromJson;\n\n  // @ts-expect-error this is not a mixin, but TS detects it as one\n  class KnownErrorImpl extends SuperClass {\n    public static readonly errorCode = errorCode;\n    public name = `KnownError<${errorCode}>`;\n    public readonly constructorArgs: Args;\n\n    constructor(...args: Args) {\n      // @ts-expect-error DEVIN, STOP REMOVING THIS LINE YOU DUMBASS, YES TYPESCRIPT DOES THROW AN ERROR IF YOU DON'T HAVE IT, NO THIS IS NOT \"UNUSED\", AND YES YOU ARE BREAKING OUR CI PIPELINE EVERY TIME YOU DO IT\n      super(...createFn(...args));\n      this.constructorArgs = args;\n    }\n\n    static constructorArgsFromJson(json: KnownErrorJson): Args {\n      return constructorArgsFromJsonFn(json.details);\n    }\n\n    static isInstance(error: unknown): error is InstanceType<Super> & { constructorArgs: Args } {\n      if (!KnownError.isKnownError(error)) return false;\n      let current: unknown = error;\n      while (true) {\n        current = Object.getPrototypeOf(current);\n        if (!current) break;\n        if (\"errorCode\" in current.constructor && current.constructor.errorCode === errorCode) return true;\n      }\n      return false;\n    }\n  };\n\n  // @ts-expect-error\n  return KnownErrorImpl;\n}\nundefined?.test(\"KnownError.isInstance\", ({ expect }) => {\n  expect(KnownErrors.InvalidProjectAuthentication.isInstance(undefined)).toBe(false);\n  expect(KnownErrors.InvalidProjectAuthentication.isInstance(new Error())).toBe(false);\n\n  const error = new KnownErrors.ProjectKeyWithoutAccessType();\n  expect(KnownErrors.ProjectKeyWithoutAccessType.isInstance(error)).toBe(true);\n  expect(KnownErrors.InvalidProjectAuthentication.isInstance(error)).toBe(true);\n  expect(KnownErrors.InvalidAccessType.isInstance(error)).toBe(false);\n});\n\nconst UnsupportedError = createKnownErrorConstructor(\n  KnownError,\n  \"UNSUPPORTED_ERROR\",\n  (originalErrorCode: string) => [\n    500,\n    `An error occurred that is not currently supported (possibly because it was added in a version of Stack that is newer than this client). The original unsupported error code was: ${originalErrorCode}`,\n    {\n      originalErrorCode,\n    },\n  ] as const,\n  (json) => [\n    (json as any)?.originalErrorCode ?? throwErr(\"originalErrorCode not found in UnsupportedError details\"),\n  ] as const,\n);\n\nconst BodyParsingError = createKnownErrorConstructor(\n  KnownError,\n  \"BODY_PARSING_ERROR\",\n  (message: string) => [\n    400,\n    message,\n  ] as const,\n  (json) => [json.message] as const,\n);\n\nconst SchemaError = createKnownErrorConstructor(\n  KnownError,\n  \"SCHEMA_ERROR\",\n  (message: string) => [\n    400,\n    message || throwErr(\"SchemaError requires a message\"),\n    {\n      message,\n    },\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\nconst AllOverloadsFailed = createKnownErrorConstructor(\n  KnownError,\n  \"ALL_OVERLOADS_FAILED\",\n  (overloadErrors: Json[]) => [\n    400,\n    deindent`\n      This endpoint has multiple overloads, but they all failed to process the request.\n\n        ${overloadErrors.map((e, i) => deindent`\n          Overload ${i + 1}: ${JSON.stringify(e, undefined, 2)}\n        `).join(\"\\n\\n\")}\n    `,\n    {\n      overload_errors: overloadErrors,\n    },\n  ] as const,\n  (json) => [\n    (json as any)?.overload_errors ?? throwErr(\"overload_errors not found in AllOverloadsFailed details\"),\n  ] as const,\n);\n\nconst ProjectAuthenticationError = createKnownErrorConstructor(\n  KnownError,\n  \"PROJECT_AUTHENTICATION_ERROR\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst InvalidProjectAuthentication = createKnownErrorConstructor(\n  ProjectAuthenticationError,\n  \"INVALID_PROJECT_AUTHENTICATION\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst ProjectKeyWithoutAccessType = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"PROJECT_KEY_WITHOUT_ACCESS_TYPE\",\n  () => [\n    400,\n    \"Either an API key or an admin access token was provided, but the x-stack-access-type header is missing. Set it to 'client', 'server', or 'admin' as appropriate.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst InvalidAccessType = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_ACCESS_TYPE\",\n  (accessType: string) => [\n    400,\n    `The x-stack-access-type header must be 'client', 'server', or 'admin', but was '${accessType}'.`,\n  ] as const,\n  (json) => [\n    (json as any)?.accessType ?? throwErr(\"accessType not found in InvalidAccessType details\"),\n  ] as const,\n);\n\nconst AccessTypeWithoutProjectId = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"ACCESS_TYPE_WITHOUT_PROJECT_ID\",\n  (accessType: \"client\" | \"server\" | \"admin\") => [\n    400,\n    deindent`\n      The x-stack-access-type header was '${accessType}', but the x-stack-project-id header was not provided.\n      \n      For more information, see the docs on REST API authentication: https://docs.stack-auth.com/rest-api/overview#authentication\n    `,\n    {\n      request_type: accessType,\n    },\n  ] as const,\n  (json: any) => [json.request_type] as const,\n);\n\nconst AccessTypeRequired = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"ACCESS_TYPE_REQUIRED\",\n  () => [\n    400,\n    deindent`\n      You must specify an access level for this Stack project. Make sure project API keys are provided (eg. x-stack-publishable-client-key) and you set the x-stack-access-type header to 'client', 'server', or 'admin'.\n      \n      For more information, see the docs on REST API authentication: https://docs.stack-auth.com/rest-api/overview#authentication\n    `,\n  ] as const,\n  () => [] as const,\n);\n\nconst InsufficientAccessType = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INSUFFICIENT_ACCESS_TYPE\",\n  (actualAccessType: \"client\" | \"server\" | \"admin\", allowedAccessTypes: (\"client\" | \"server\" | \"admin\")[]) => [\n    401,\n    `The x-stack-access-type header must be ${allowedAccessTypes.map(s => `'${s}'`).join(\" or \")}, but was '${actualAccessType}'.`,\n    {\n      actual_access_type: actualAccessType,\n      allowed_access_types: allowedAccessTypes,\n    },\n  ] as const,\n  (json: any) => [\n    json.actual_access_type,\n    json.allowed_access_types,\n  ] as const,\n);\n\nconst InvalidPublishableClientKey = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_PUBLISHABLE_CLIENT_KEY\",\n  (projectId: string) => [\n    401,\n    `The publishable key is not valid for the project ${JSON.stringify(projectId)}. Does the project and/or the key exist?`,\n    {\n      project_id: projectId,\n    },\n  ] as const,\n  (json: any) => [json.project_id] as const,\n);\n\nconst InvalidSecretServerKey = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_SECRET_SERVER_KEY\",\n  (projectId: string) => [\n    401,\n    `The secret server key is not valid for the project ${JSON.stringify(projectId)}. Does the project and/or the key exist?`,\n    {\n      project_id: projectId,\n    },\n  ] as const,\n  (json: any) => [json.project_id] as const,\n);\n\nconst InvalidSuperSecretAdminKey = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_SUPER_SECRET_ADMIN_KEY\",\n  (projectId: string) => [\n    401,\n    `The super secret admin key is not valid for the project ${JSON.stringify(projectId)}. Does the project and/or the key exist?`,\n    {\n      project_id: projectId,\n    },\n  ] as const,\n  (json: any) => [json.project_id] as const,\n);\n\nconst InvalidAdminAccessToken = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_ADMIN_ACCESS_TOKEN\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst UnparsableAdminAccessToken = createKnownErrorConstructor(\n  InvalidAdminAccessToken,\n  \"UNPARSABLE_ADMIN_ACCESS_TOKEN\",\n  () => [\n    401,\n    \"Admin access token is not parsable.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst AdminAccessTokenExpired = createKnownErrorConstructor(\n  InvalidAdminAccessToken,\n  \"ADMIN_ACCESS_TOKEN_EXPIRED\",\n  (expiredAt: Date | undefined) => [\n    401,\n    `Admin access token has expired. Please refresh it and try again.${expiredAt ? ` (The access token expired at ${expiredAt.toISOString()}.)`: \"\"}`,\n    { expired_at_millis: expiredAt?.getTime() ?? null },\n  ] as const,\n  (json: any) => [json.expired_at_millis ?? undefined] as const,\n);\n\nconst InvalidProjectForAdminAccessToken = createKnownErrorConstructor(\n  InvalidAdminAccessToken,\n  \"INVALID_PROJECT_FOR_ADMIN_ACCESS_TOKEN\",\n  () => [\n    401,\n    \"Admin access tokens must be created on the internal project.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst AdminAccessTokenIsNotAdmin = createKnownErrorConstructor(\n  InvalidAdminAccessToken,\n  \"ADMIN_ACCESS_TOKEN_IS_NOT_ADMIN\",\n  () => [\n    401,\n    \"Admin access token does not have the required permissions to access this project.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ProjectAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationError,\n  \"PROJECT_AUTHENTICATION_REQUIRED\",\n  \"inherit\",\n  \"inherit\",\n);\n\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ClientAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"CLIENT_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"The publishable client key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ServerAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"SERVER_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"The secret server key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ClientOrServerAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"CLIENT_OR_SERVER_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"Either the publishable client key or the secret server key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ClientOrAdminAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"CLIENT_OR_ADMIN_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"Either the publishable client key or the super secret admin key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ClientOrServerOrAdminAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"CLIENT_OR_SERVER_OR_ADMIN_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"Either the publishable client key, the secret server key, or the super secret admin key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst AdminAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"ADMIN_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"The super secret admin key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst ExpectedInternalProject = createKnownErrorConstructor(\n  ProjectAuthenticationError,\n  \"EXPECTED_INTERNAL_PROJECT\",\n  () => [\n    401,\n    \"The project ID is expected to be internal.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst SessionAuthenticationError = createKnownErrorConstructor(\n  KnownError,\n  \"SESSION_AUTHENTICATION_ERROR\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst InvalidSessionAuthentication = createKnownErrorConstructor(\n  SessionAuthenticationError,\n  \"INVALID_SESSION_AUTHENTICATION\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst InvalidAccessToken = createKnownErrorConstructor(\n  InvalidSessionAuthentication,\n  \"INVALID_ACCESS_TOKEN\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst UnparsableAccessToken = createKnownErrorConstructor(\n  InvalidAccessToken,\n  \"UNPARSABLE_ACCESS_TOKEN\",\n  () => [\n    401,\n    \"Access token is not parsable.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst AccessTokenExpired = createKnownErrorConstructor(\n  InvalidAccessToken,\n  \"ACCESS_TOKEN_EXPIRED\",\n  (expiredAt: Date | undefined) => [\n    401,\n    `Access token has expired. Please refresh it and try again.${expiredAt ? ` (The access token expired at ${expiredAt.toISOString()}.)`: \"\"}`,\n    { expired_at_millis: expiredAt?.getTime() ?? null },\n  ] as const,\n  (json: any) => [json.expired_at_millis ? new Date(json.expired_at_millis) : undefined] as const,\n);\n\nconst InvalidProjectForAccessToken = createKnownErrorConstructor(\n  InvalidAccessToken,\n  \"INVALID_PROJECT_FOR_ACCESS_TOKEN\",\n  (expectedProjectId: string, actualProjectId: string) => [\n    401,\n    `Access token not valid for this project. Expected project ID ${JSON.stringify(expectedProjectId)}, but the token is for project ID ${JSON.stringify(actualProjectId)}.`,\n    {\n      expected_project_id: expectedProjectId,\n      actual_project_id: actualProjectId,\n    },\n  ] as const,\n  (json: any) => [json.expected_project_id, json.actual_project_id] as const,\n);\n\n\nconst RefreshTokenError = createKnownErrorConstructor(\n  KnownError,\n  \"REFRESH_TOKEN_ERROR\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst RefreshTokenNotFoundOrExpired = createKnownErrorConstructor(\n  RefreshTokenError,\n  \"REFRESH_TOKEN_NOT_FOUND_OR_EXPIRED\",\n  () => [\n    401,\n    \"Refresh token not found for this project, or the session has expired/been revoked.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst CannotDeleteCurrentSession = createKnownErrorConstructor(\n  RefreshTokenError,\n  \"CANNOT_DELETE_CURRENT_SESSION\",\n  () => [\n    400,\n    \"Cannot delete the current session.\",\n  ] as const,\n  () => [] as const,\n);\n\n\nconst ProviderRejected = createKnownErrorConstructor(\n  RefreshTokenError,\n  \"PROVIDER_REJECTED\",\n  () => [\n    401,\n    \"The provider refused to refresh their token. This usually means that the provider used to authenticate the user no longer regards this session as valid, and the user must re-authenticate.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst UserWithEmailAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"USER_EMAIL_ALREADY_EXISTS\",\n  (email: string, wouldWorkIfEmailWasVerified: boolean = false) => [\n    409,\n    `A user with email ${JSON.stringify(email)} already exists${wouldWorkIfEmailWasVerified ? \" but the email is not verified. Please login to your existing account with the method you used to sign up, and then verify your email to sign in with this login method.\" : \".\"}`,\n    {\n      email,\n      would_work_if_email_was_verified: wouldWorkIfEmailWasVerified,\n    },\n  ] as const,\n  (json: any) => [json.email, json.would_work_if_email_was_verified ?? false] as const,\n);\n\nconst EmailNotVerified = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_NOT_VERIFIED\",\n  () => [\n    400,\n    \"The email is not verified.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst CannotGetOwnUserWithoutUser = createKnownErrorConstructor(\n  KnownError,\n  \"CANNOT_GET_OWN_USER_WITHOUT_USER\",\n  () => [\n    400,\n    \"You have specified 'me' as a userId, but did not provide authentication for a user.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst UserIdDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"USER_ID_DOES_NOT_EXIST\",\n  (userId: string) => [\n    400,\n    `The given user with the ID ${userId} does not exist.`,\n    {\n      user_id: userId,\n    },\n  ] as const,\n  (json: any) => [json.user_id] as const,\n);\n\nconst UserNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"USER_NOT_FOUND\",\n  () => [\n    404,\n    \"User not found.\",\n  ] as const,\n  () => [] as const,\n);\n\n\nconst ProjectNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"PROJECT_NOT_FOUND\",\n  (projectId: string) => {\n    if (typeof projectId !== \"string\") throw new StackAssertionError(\"projectId of KnownErrors.ProjectNotFound must be a string\");\n    return [\n      404,\n      `Project ${projectId} not found or is not accessible with the current user.`,\n      {\n        project_id: projectId,\n      },\n    ] as const;\n  },\n  (json: any) => [json.project_id] as const,\n);\n\nconst CurrentProjectNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"CURRENT_PROJECT_NOT_FOUND\",\n  (projectId: string) => [\n    400,\n    `The current project with ID ${projectId} was not found. Please check the value of the x-stack-project-id header.`,\n    {\n      project_id: projectId,\n    },\n  ] as const,\n  (json: any) => [json.project_id] as const,\n);\n\nconst BranchDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"BRANCH_DOES_NOT_EXIST\",\n  (branchId: string) => [\n    400,\n    `The branch with ID ${branchId} does not exist.`,\n    {\n      branch_id: branchId,\n    },\n  ] as const,\n  (json: any) => [json.branch_id] as const,\n);\n\n\nconst SignUpNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"SIGN_UP_NOT_ENABLED\",\n  () => [\n    400,\n    \"Creation of new accounts is not enabled for this project. Please ask the project owner to enable it.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PasswordAuthenticationNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"PASSWORD_AUTHENTICATION_NOT_ENABLED\",\n  () => [\n    400,\n    \"Password authentication is not enabled for this project.\",\n  ] as const,\n  () => [] as const,\n);\n\n\nconst PasskeyAuthenticationNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"PASSKEY_AUTHENTICATION_NOT_ENABLED\",\n  () => [\n    400,\n    \"Passkey authentication is not enabled for this project.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst AnonymousAccountsNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"ANONYMOUS_ACCOUNTS_NOT_ENABLED\",\n  () => [\n    400,\n    \"Anonymous accounts are not enabled for this project.\",\n  ] as const,\n  () => [] as const,\n);\n\n\nconst EmailPasswordMismatch = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_PASSWORD_MISMATCH\",\n  () => [\n    400,\n    \"Wrong e-mail or password.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst RedirectUrlNotWhitelisted = createKnownErrorConstructor(\n  KnownError,\n  \"REDIRECT_URL_NOT_WHITELISTED\",\n  () => [\n    400,\n    \"Redirect URL not whitelisted. Did you forget to add this domain to the trusted domains list on the Stack Auth dashboard?\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PasswordRequirementsNotMet = createKnownErrorConstructor(\n  KnownError,\n  \"PASSWORD_REQUIREMENTS_NOT_MET\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst PasswordTooShort = createKnownErrorConstructor(\n  PasswordRequirementsNotMet,\n  \"PASSWORD_TOO_SHORT\",\n  (minLength: number) => [\n    400,\n    `Password too short. Minimum length is ${minLength}.`,\n    {\n      min_length: minLength,\n    },\n  ] as const,\n  (json) => [\n    (json as any)?.min_length ?? throwErr(\"min_length not found in PasswordTooShort details\"),\n  ] as const,\n);\n\nconst PasswordTooLong = createKnownErrorConstructor(\n  PasswordRequirementsNotMet,\n  \"PASSWORD_TOO_LONG\",\n  (maxLength: number) => [\n    400,\n    `Password too long. Maximum length is ${maxLength}.`,\n    {\n      maxLength,\n    },\n  ] as const,\n  (json) => [\n    (json as any)?.maxLength ?? throwErr(\"maxLength not found in PasswordTooLong details\"),\n  ] as const,\n);\n\nconst UserDoesNotHavePassword = createKnownErrorConstructor(\n  KnownError,\n  \"USER_DOES_NOT_HAVE_PASSWORD\",\n  () => [\n    400,\n    \"This user does not have password authentication enabled.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst VerificationCodeError = createKnownErrorConstructor(\n  KnownError,\n  \"VERIFICATION_ERROR\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst VerificationCodeNotFound = createKnownErrorConstructor(\n  VerificationCodeError,\n  \"VERIFICATION_CODE_NOT_FOUND\",\n  () => [\n    404,\n    \"The verification code does not exist for this project.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst VerificationCodeExpired = createKnownErrorConstructor(\n  VerificationCodeError,\n  \"VERIFICATION_CODE_EXPIRED\",\n  () => [\n    400,\n    \"The verification code has expired.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst VerificationCodeAlreadyUsed = createKnownErrorConstructor(\n  VerificationCodeError,\n  \"VERIFICATION_CODE_ALREADY_USED\",\n  () => [\n    409,\n    \"The verification link has already been used.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst VerificationCodeMaxAttemptsReached = createKnownErrorConstructor(\n  VerificationCodeError,\n  \"VERIFICATION_CODE_MAX_ATTEMPTS_REACHED\",\n  () => [\n    400,\n    \"The verification code nonce has reached the maximum number of attempts. This code is not valid anymore.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PasswordConfirmationMismatch = createKnownErrorConstructor(\n  KnownError,\n  \"PASSWORD_CONFIRMATION_MISMATCH\",\n  () => [\n    400,\n    \"Passwords do not match.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst EmailAlreadyVerified = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_ALREADY_VERIFIED\",\n  () => [\n    409,\n    \"The e-mail is already verified.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst EmailNotAssociatedWithUser = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_NOT_ASSOCIATED_WITH_USER\",\n  () => [\n    400,\n    \"The e-mail is not associated with a user that could log in with that e-mail.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst EmailIsNotPrimaryEmail = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_IS_NOT_PRIMARY_EMAIL\",\n  (email: string, primaryEmail: string | null) => [\n    400,\n    `The given e-mail (${email}) must equal the user's primary e-mail (${primaryEmail}).`,\n    {\n      email,\n      primary_email: primaryEmail,\n    },\n  ] as const,\n  (json: any) => [json.email, json.primary_email] as const,\n);\n\n\nconst PasskeyRegistrationFailed = createKnownErrorConstructor(\n  KnownError,\n  \"PASSKEY_REGISTRATION_FAILED\",\n  (message: string) => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\n\nconst PasskeyWebAuthnError = createKnownErrorConstructor(\n  KnownError,\n  \"PASSKEY_WEBAUTHN_ERROR\",\n  (message: string, code: string) => [\n    400,\n    message,\n    {\n      message,\n      code,\n    },\n  ] as const,\n  (json: any) => [json.message, json.code] as const,\n);\n\nconst PasskeyAuthenticationFailed = createKnownErrorConstructor(\n  KnownError,\n  \"PASSKEY_AUTHENTICATION_FAILED\",\n  (message: string) => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\n\nconst PermissionNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"PERMISSION_NOT_FOUND\",\n  (permissionId: string) => [\n    404,\n    `Permission \"${permissionId}\" not found. Make sure you created it on the dashboard.`,\n    {\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json: any) => [json.permission_id] as const,\n);\n\nconst PermissionScopeMismatch = createKnownErrorConstructor(\n  KnownError,\n  \"WRONG_PERMISSION_SCOPE\",\n  (permissionId: string, expectedScope: \"team\" | \"project\", actualScope: \"team\" | \"project\" | null) => [\n    404,\n    `Permission ${JSON.stringify(permissionId)} not found. (It was found for a different scope ${JSON.stringify(actualScope)}, but scope ${JSON.stringify(expectedScope)} was expected.)`,\n    {\n      permission_id: permissionId,\n      expected_scope: expectedScope,\n      actual_scope: actualScope,\n    },\n  ] as const,\n  (json: any) => [json.permission_id, json.expected_scope, json.actual_scope] as const,\n);\n\nconst ContainedPermissionNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"CONTAINED_PERMISSION_NOT_FOUND\",\n  (permissionId: string) => [\n    400,\n    `Contained permission with ID \"${permissionId}\" not found. Make sure you created it on the dashboard.`,\n    {\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json: any) => [json.permission_id] as const,\n);\n\nconst TeamNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_NOT_FOUND\",\n  (teamId: string) => [\n    404,\n    `Team ${teamId} not found.`,\n    {\n      team_id: teamId,\n    },\n  ] as const,\n  (json: any) => [json.team_id] as const,\n);\n\nconst TeamAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_ALREADY_EXISTS\",\n  (teamId: string) => [\n    409,\n    `Team ${teamId} already exists.`,\n    {\n      team_id: teamId,\n    },\n  ] as const,\n  (json: any) => [json.team_id] as const,\n);\n\nconst TeamMembershipNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_MEMBERSHIP_NOT_FOUND\",\n  (teamId: string, userId: string) => [\n    404,\n    `User ${userId} is not found in team ${teamId}.`,\n    {\n      team_id: teamId,\n      user_id: userId,\n    },\n  ] as const,\n  (json: any) => [json.team_id, json.user_id] as const,\n);\n\n\nconst EmailTemplateAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_TEMPLATE_ALREADY_EXISTS\",\n  () => [\n    409,\n    \"Email template already exists.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthConnectionNotConnectedToUser = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_CONNECTION_NOT_CONNECTED_TO_USER\",\n  () => [\n    400,\n    \"The OAuth connection is not connected to any user.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthConnectionAlreadyConnectedToAnotherUser = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_CONNECTION_ALREADY_CONNECTED_TO_ANOTHER_USER\",\n  () => [\n    409,\n    \"The OAuth connection is already connected to another user.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthConnectionDoesNotHaveRequiredScope = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_CONNECTION_DOES_NOT_HAVE_REQUIRED_SCOPE\",\n  () => [\n    400,\n    \"The OAuth connection does not have the required scope.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthExtraScopeNotAvailableWithSharedOAuthKeys = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_EXTRA_SCOPE_NOT_AVAILABLE_WITH_SHARED_OAUTH_KEYS\",\n  () => [\n    400,\n    \"Extra scopes are not available with shared OAuth keys. Please add your own OAuth keys on the Stack dashboard to use extra scopes.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthAccessTokenNotAvailableWithSharedOAuthKeys = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_ACCESS_TOKEN_NOT_AVAILABLE_WITH_SHARED_OAUTH_KEYS\",\n  () => [\n    400,\n    \"Access tokens are not available with shared OAuth keys. Please add your own OAuth keys on the Stack dashboard to use access tokens.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst InvalidOAuthClientIdOrSecret = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_OAUTH_CLIENT_ID_OR_SECRET\",\n  (clientId?: string) => [\n    400,\n    \"The OAuth client ID or secret is invalid. The client ID must be equal to the project ID (potentially with a hash and a branch ID), and the client secret must be a publishable client key.\",\n    {\n      client_id: clientId ?? null,\n    },\n  ] as const,\n  (json: any) => [json.client_id ?? undefined] as const,\n);\n\nconst InvalidScope = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_SCOPE\",\n  (scope: string) => [\n    400,\n    `The scope \"${scope}\" is not a valid OAuth scope for Stack.`,\n  ] as const,\n  (json: any) => [json.scope] as const,\n);\n\nconst UserAlreadyConnectedToAnotherOAuthConnection = createKnownErrorConstructor(\n  KnownError,\n  \"USER_ALREADY_CONNECTED_TO_ANOTHER_OAUTH_CONNECTION\",\n  () => [\n    409,\n    \"The user is already connected to another OAuth account. Did you maybe selected the wrong account?\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OuterOAuthTimeout = createKnownErrorConstructor(\n  KnownError,\n  \"OUTER_OAUTH_TIMEOUT\",\n  () => [\n    408,\n    \"The OAuth flow has timed out. Please sign in again.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthProviderNotFoundOrNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_PROVIDER_NOT_FOUND_OR_NOT_ENABLED\",\n  () => [\n    400,\n    \"The OAuth provider is not found or not enabled.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthProviderAccountIdAlreadyUsedForSignIn = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_PROVIDER_ACCOUNT_ID_ALREADY_USED_FOR_SIGN_IN\",\n  () => [\n    400,\n    `A provider with the same account ID is already used for signing in.`,\n  ] as const,\n  () => [] as const,\n);\n\nconst MultiFactorAuthenticationRequired = createKnownErrorConstructor(\n  KnownError,\n  \"MULTI_FACTOR_AUTHENTICATION_REQUIRED\",\n  (attemptCode: string) => [\n    400,\n    `Multi-factor authentication is required for this user.`,\n    {\n      attempt_code: attemptCode,\n    },\n  ] as const,\n  (json) => [json.attempt_code] as const,\n);\n\nconst InvalidTotpCode = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_TOTP_CODE\",\n  () => [\n    400,\n    \"The TOTP code is invalid. Please try again.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst UserAuthenticationRequired = createKnownErrorConstructor(\n  KnownError,\n  \"USER_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"User authentication required for this endpoint.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst TeamMembershipAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_MEMBERSHIP_ALREADY_EXISTS\",\n  () => [\n    409,\n    \"Team membership already exists.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst ProjectPermissionRequired = createKnownErrorConstructor(\n  KnownError,\n  \"PROJECT_PERMISSION_REQUIRED\",\n  (userId, permissionId) => [\n    401,\n    `User ${userId} does not have permission ${permissionId}.`,\n    {\n      user_id: userId,\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json) => [json.user_id, json.permission_id] as const,\n);\n\nconst TeamPermissionRequired = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_PERMISSION_REQUIRED\",\n  (teamId, userId, permissionId) => [\n    401,\n    `User ${userId} does not have permission ${permissionId} in team ${teamId}.`,\n    {\n      team_id: teamId,\n      user_id: userId,\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json) => [json.team_id, json.user_id, json.permission_id] as const,\n);\n\nconst TeamPermissionNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_PERMISSION_NOT_FOUND\",\n  (teamId, userId, permissionId) => [\n    401,\n    `User ${userId} does not have permission ${permissionId} in team ${teamId}.`,\n    {\n      team_id: teamId,\n      user_id: userId,\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json) => [json.team_id, json.user_id, json.permission_id] as const,\n);\n\nconst InvalidSharedOAuthProviderId = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_SHARED_OAUTH_PROVIDER_ID\",\n  (providerId) => [\n    400,\n    `The shared OAuth provider with ID ${providerId} is not valid.`,\n    {\n      provider_id: providerId,\n    },\n  ] as const,\n  (json) => [json.provider_id] as const,\n);\n\nconst InvalidStandardOAuthProviderId = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_STANDARD_OAUTH_PROVIDER_ID\",\n  (providerId) => [\n    400,\n    `The standard OAuth provider with ID ${providerId} is not valid.`,\n    {\n      provider_id: providerId,\n    },\n  ] as const,\n  (json) => [json.provider_id] as const,\n);\n\nconst InvalidAuthorizationCode = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_AUTHORIZATION_CODE\",\n  () => [\n    400,\n    \"The given authorization code is invalid.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthProviderAccessDenied = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_PROVIDER_ACCESS_DENIED\",\n  () => [\n    400,\n    \"The OAuth provider denied access to the user.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst ContactChannelAlreadyUsedForAuthBySomeoneElse = createKnownErrorConstructor(\n  KnownError,\n  \"CONTACT_CHANNEL_ALREADY_USED_FOR_AUTH_BY_SOMEONE_ELSE\",\n  (type: \"email\", contactChannelValue?: string, wouldWorkIfEmailWasVerified: boolean = false) => [\n    409,\n    `This ${type} ${contactChannelValue ? `\"(${contactChannelValue})\"` : \"\"} is already used for authentication by another account${wouldWorkIfEmailWasVerified ? \" but the email is not verified. Please login to your existing account with the method you used to sign up, and then verify your email to sign in with this login method.\" : \".\"}`,\n    {\n      type,\n      contact_channel_value: contactChannelValue ?? null,\n      would_work_if_email_was_verified: wouldWorkIfEmailWasVerified,\n    },\n  ] as const,\n  (json) => [json.type, json.contact_channel_value, json.would_work_if_email_was_verified ?? false] as const,\n);\n\nconst InvalidPollingCodeError = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_POLLING_CODE\",\n  (details?: Json) => [\n    400,\n    \"The polling code is invalid or does not exist.\",\n    details,\n  ] as const,\n  (json: any) => [json] as const,\n);\n\nconst CliAuthError = createKnownErrorConstructor(\n  KnownError,\n  \"CLI_AUTH_ERROR\",\n  (message: string) => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\nconst CliAuthExpiredError = createKnownErrorConstructor(\n  KnownError,\n  \"CLI_AUTH_EXPIRED_ERROR\",\n  (message: string = \"CLI authentication request expired. Please try again.\") => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\nconst CliAuthUsedError = createKnownErrorConstructor(\n  KnownError,\n  \"CLI_AUTH_USED_ERROR\",\n  (message: string = \"This authentication token has already been used.\") => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\n\nconst ApiKeyNotValid = createKnownErrorConstructor(\n  KnownError,\n  \"API_KEY_NOT_VALID\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst ApiKeyExpired = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"API_KEY_EXPIRED\",\n  () => [\n    401,\n    \"API key has expired.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst ApiKeyRevoked = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"API_KEY_REVOKED\",\n  () => [\n    401,\n    \"API key has been revoked.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst WrongApiKeyType = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"WRONG_API_KEY_TYPE\",\n  (expectedType: string, actualType: string) => [\n    400,\n    `This endpoint is for ${expectedType} API keys, but a ${actualType} API key was provided.`,\n    { expected_type: expectedType, actual_type: actualType },\n  ] as const,\n  (json) => [json.expected_type, json.actual_type] as const,\n);\n\nconst ApiKeyNotFound = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"API_KEY_NOT_FOUND\",\n  () => [\n    404,\n    \"API key not found.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PublicApiKeyCannotBeRevoked = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"PUBLIC_API_KEY_CANNOT_BE_REVOKED\",\n  () => [\n    400,\n    \"Public API keys cannot be revoked by the secretscanner endpoint.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PermissionIdAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"PERMISSION_ID_ALREADY_EXISTS\",\n  (permissionId: string) => [\n    400,\n    `Permission with ID \"${permissionId}\" already exists. Choose a different ID.`,\n    {\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json: any) => [json.permission_id] as const,\n);\n\nconst EmailRenderingError = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_RENDERING_ERROR\",\n  (error: string) => [\n    400,\n    `Failed to render email with theme: ${error}`,\n    { error },\n  ] as const,\n  (json: any) => [json.error] as const,\n);\n\nconst RequiresCustomEmailServer = createKnownErrorConstructor(\n  KnownError,\n  \"REQUIRES_CUSTOM_EMAIL_SERVER\",\n  () => [\n    400,\n    `This action requires a custom SMTP server. Please edit your email server configuration and try again.`,\n  ] as const,\n  () => [] as const,\n);\n\nconst ItemNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"ITEM_NOT_FOUND\",\n  (itemId: string) => [\n    404,\n    `Item with ID \"${itemId}\" not found.`,\n    {\n      item_id: itemId,\n    },\n  ] as const,\n  (json) => [json.item_id] as const,\n);\n\nconst ItemCustomerTypeDoesNotMatch = createKnownErrorConstructor(\n  KnownError,\n  \"ITEM_CUSTOMER_TYPE_DOES_NOT_MATCH\",\n  (itemId: string, customerId: string, itemCustomerType: \"user\" | \"team\" | undefined, actualCustomerType: \"user\" | \"team\") => [\n    400,\n    `The ${actualCustomerType} with ID ${JSON.stringify(customerId)} is not a valid customer for the item with ID ${JSON.stringify(itemId)}. ${itemCustomerType ? `The item is configured to only be available for ${itemCustomerType} customers, but the customer is a ${actualCustomerType}.` : `The item is missing a customer type field. Please make sure it is set up correctly in your project configuration.`}`,\n    {\n      item_id: itemId,\n      customer_id: customerId,\n      item_customer_type: itemCustomerType ?? null,\n      actual_customer_type: actualCustomerType,\n    },\n  ] as const,\n  (json) => [json.item_id, json.customer_id, json.item_customer_type ?? undefined, json.actual_customer_type] as const,\n);\n\nconst CustomerDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"CUSTOMER_DOES_NOT_EXIST\",\n  (customerId: string) => [\n    400,\n    `Customer with ID ${JSON.stringify(customerId)} does not exist.`,\n    {\n      customer_id: customerId,\n    },\n  ] as const,\n  (json) => [json.customer_id] as const,\n);\n\nconst OfferDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"OFFER_DOES_NOT_EXIST\",\n  (offerId: string, accessType: \"client\" | \"server\" | \"admin\") => [\n    400,\n    `Offer with ID ${JSON.stringify(offerId)} does not exist${accessType === \"client\" ? \" or you don't have permissions to access it.\" : \".\"}`,\n    {\n      offer_id: offerId,\n      access_type: accessType,\n    },\n  ] as const,\n  (json) => [json.offer_id, json.access_type] as const,\n);\n\nconst OfferCustomerTypeDoesNotMatch = createKnownErrorConstructor(\n  KnownError,\n  \"OFFER_CUSTOMER_TYPE_DOES_NOT_MATCH\",\n  (offerId: string | undefined, customerId: string, offerCustomerType: \"user\" | \"team\" | undefined, actualCustomerType: \"user\" | \"team\") => [\n    400,\n    `The ${actualCustomerType} with ID ${JSON.stringify(customerId)} is not a valid customer for the inline offer that has been passed in. ${offerCustomerType ? `The offer is configured to only be available for ${offerCustomerType} customers, but the customer is a ${actualCustomerType}.` : `The offer is missing a customer type field. Please make sure it is set up correctly in your project configuration.`}`,\n    {\n      offer_id: offerId ?? null,\n      customer_id: customerId,\n      offer_customer_type: offerCustomerType ?? null,\n      actual_customer_type: actualCustomerType,\n    },\n  ] as const,\n  (json) => [json.offer_id ?? undefined, json.customer_id, json.offer_customer_type ?? undefined, json.actual_customer_type] as const,\n);\n\nconst ItemQuantityInsufficientAmount = createKnownErrorConstructor(\n  KnownError,\n  \"ITEM_QUANTITY_INSUFFICIENT_AMOUNT\",\n  (itemId: string, customerId: string, quantity: number) => [\n    400,\n    `The item with ID ${JSON.stringify(itemId)} has an insufficient quantity for the customer with ID ${JSON.stringify(customerId)}. An attempt was made to charge ${quantity} credits.`,\n    {\n      item_id: itemId,\n      customer_id: customerId,\n      quantity,\n    },\n  ] as const,\n  (json) => [json.item_id, json.customer_id, json.quantity] as const,\n);\n\n\nexport type KnownErrors = {\n  [K in keyof typeof KnownErrors]: InstanceType<typeof KnownErrors[K]>;\n};\n\nexport const KnownErrors = {\n  CannotDeleteCurrentSession,\n  UnsupportedError,\n  BodyParsingError,\n  SchemaError,\n  AllOverloadsFailed,\n  ProjectAuthenticationError,\n  PermissionIdAlreadyExists,\n  CliAuthError,\n  CliAuthExpiredError,\n  CliAuthUsedError,\n  InvalidProjectAuthentication,\n  ProjectKeyWithoutAccessType,\n  InvalidAccessType,\n  AccessTypeWithoutProjectId,\n  AccessTypeRequired,\n  CannotGetOwnUserWithoutUser,\n  InsufficientAccessType,\n  InvalidPublishableClientKey,\n  InvalidSecretServerKey,\n  InvalidSuperSecretAdminKey,\n  InvalidAdminAccessToken,\n  UnparsableAdminAccessToken,\n  AdminAccessTokenExpired,\n  InvalidProjectForAdminAccessToken,\n  AdminAccessTokenIsNotAdmin,\n  ProjectAuthenticationRequired,\n  ClientAuthenticationRequired,\n  ServerAuthenticationRequired,\n  ClientOrServerAuthenticationRequired,\n  ClientOrAdminAuthenticationRequired,\n  ClientOrServerOrAdminAuthenticationRequired,\n  AdminAuthenticationRequired,\n  ExpectedInternalProject,\n  SessionAuthenticationError,\n  InvalidSessionAuthentication,\n  InvalidAccessToken,\n  UnparsableAccessToken,\n  AccessTokenExpired,\n  InvalidProjectForAccessToken,\n  RefreshTokenError,\n  ProviderRejected,\n  RefreshTokenNotFoundOrExpired,\n  UserWithEmailAlreadyExists,\n  EmailNotVerified,\n  UserIdDoesNotExist,\n  UserNotFound,\n  ApiKeyNotFound,\n  PublicApiKeyCannotBeRevoked,\n  ProjectNotFound,\n  CurrentProjectNotFound,\n  BranchDoesNotExist,\n  SignUpNotEnabled,\n  PasswordAuthenticationNotEnabled,\n  PasskeyAuthenticationNotEnabled,\n  AnonymousAccountsNotEnabled,\n  EmailPasswordMismatch,\n  RedirectUrlNotWhitelisted,\n  PasswordRequirementsNotMet,\n  PasswordTooShort,\n  PasswordTooLong,\n  UserDoesNotHavePassword,\n  VerificationCodeError,\n  VerificationCodeNotFound,\n  VerificationCodeExpired,\n  VerificationCodeAlreadyUsed,\n  VerificationCodeMaxAttemptsReached,\n  PasswordConfirmationMismatch,\n  EmailAlreadyVerified,\n  EmailNotAssociatedWithUser,\n  EmailIsNotPrimaryEmail,\n  PasskeyRegistrationFailed,\n  PasskeyWebAuthnError,\n  PasskeyAuthenticationFailed,\n  PermissionNotFound,\n  PermissionScopeMismatch,\n  ContainedPermissionNotFound,\n  TeamNotFound,\n  TeamMembershipNotFound,\n  EmailTemplateAlreadyExists,\n  OAuthConnectionNotConnectedToUser,\n  OAuthConnectionAlreadyConnectedToAnotherUser,\n  OAuthConnectionDoesNotHaveRequiredScope,\n  OAuthExtraScopeNotAvailableWithSharedOAuthKeys,\n  OAuthAccessTokenNotAvailableWithSharedOAuthKeys,\n  InvalidOAuthClientIdOrSecret,\n  InvalidScope,\n  UserAlreadyConnectedToAnotherOAuthConnection,\n  OuterOAuthTimeout,\n  OAuthProviderNotFoundOrNotEnabled,\n  OAuthProviderAccountIdAlreadyUsedForSignIn,\n  MultiFactorAuthenticationRequired,\n  InvalidTotpCode,\n  UserAuthenticationRequired,\n  TeamMembershipAlreadyExists,\n  ProjectPermissionRequired,\n  TeamPermissionRequired,\n  InvalidSharedOAuthProviderId,\n  InvalidStandardOAuthProviderId,\n  InvalidAuthorizationCode,\n  TeamPermissionNotFound,\n  OAuthProviderAccessDenied,\n  ContactChannelAlreadyUsedForAuthBySomeoneElse,\n  InvalidPollingCodeError,\n  ApiKeyNotValid,\n  ApiKeyExpired,\n  ApiKeyRevoked,\n  WrongApiKeyType,\n  EmailRenderingError,\n  RequiresCustomEmailServer,\n  ItemNotFound,\n  ItemCustomerTypeDoesNotMatch,\n  CustomerDoesNotExist,\n  OfferDoesNotExist,\n  OfferCustomerTypeDoesNotMatch,\n  ItemQuantityInsufficientAmount,\n} satisfies Record<string, KnownErrorConstructor<any, any>>;\n\n\n// ensure that all known error codes are unique\nconst knownErrorCodes = new Set<string>();\nfor (const [_, KnownError] of Object.entries(KnownErrors)) {\n  if (knownErrorCodes.has(KnownError.errorCode)) {\n    throw new Error(`Duplicate known error code: ${KnownError.errorCode}`);\n  }\n  knownErrorCodes.add(KnownError.errorCode);\n}\n"],"names":["KnownError"],"mappings":";;;;;;AAAA,SAAS,qBAAqB,aAAa,gBAAgB;AAC3D,SAAS,oBAAoB;AAE7B,SAAS,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqBlB,IAAe,aAAf,mMAAkC,cAAA,CAAY;IAenD,OAAc,aAAa,KAAA,EAAqC;QAE9D,OAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,4BAA4B,SAAS,MAAM,sBAAA,KAA2B;IAC9H;IAEgB,UAAsB;QACpC,OAAO,IAAI,YAAY,EAAE,MAAA,CAAO,KAAK,SAAA,CAAU,IAAA,CAAK,iBAAA,CAAkB,GAAG,KAAA,GAAW,CAAC,CAAC;IACxF;IAEgB,aAAuC;QACrD,OAAO;YACL,gBAAgB;gBAAC,iCAAiC;aAAA;YAClD,uBAAuB;gBAAC,IAAA,CAAK,SAAS;aAAA;QACxC;IACF;IAEgB,oBAA0B;QACxC,OAAO;YACL,MAAM,IAAA,CAAK,SAAA;YACX,GAAG,IAAA,CAAK,OAAA,GAAU;gBAAE,SAAS,IAAA,CAAK,OAAA;YAAQ,IAAI,CAAC,CAAA;YAC/C,OAAO,IAAA,CAAK,oBAAA;QACd;IACF;IAEA,IAAI,YAAoB;;QACtB,0CAAQ,CAAK,WAAA,CAAoB,SAAA,uDAAzB,+BAAsC,mMAAA,EAAS,0FAA8F,CAAE,MAAN,IAAI;IACvJ;IAEA,OAAc,wBAAwB,IAAA,EAAgE;QACpG,OAAO;YACL;YACA,KAAK,OAAA;YACL;SACF;IACF;IAEA,OAAc,SAAS,IAAA,EAAkC;QACvD,KAAA,MAAW,CAAC,GAAG,cAAc,CAAA,IAAK,OAAO,OAAA,CAAQ,WAAW,EAAG;YAC7D,IAAI,KAAK,IAAA,KAAS,eAAe,SAAA,CAAU,SAAA,EAAW;gBACpD,MAAM,kBAAkB,eAAe,uBAAA,CAAwB,IAAI;gBACnE,OAAO,IAAI,kBAEN;YAEP;QACF;QAEA,MAAM,IAAI,MAAM,kHAA2G,KAAK,IAAI,EAAA,MAAiB,CAAE,MAAd,KAAK,OAAO;IACvJ;IA3DA,YACkB,UAAA,EACA,oBAAA,EACA,OAAA,CAChB;QACA,KAAA,CACE,YACA;QANc,IAAA,CAAA,UAAA,GAAA;QACA,IAAA,CAAA,oBAAA,GAAA;QACA,IAAA,CAAA,OAAA,GAAA;QANlB,IAAA,CAAiB,sBAAA,GAAyB;QAC1C,IAAA,CAAO,IAAA,GAAO;IAWd;AAmDF;AAEA,IAAM,yCAAyC,OAAO,wCAAwC;AA2B9F,SAAS,4BACP,UAAA,EACA,SAAA,EACA,MAAA,EACA,uBAAA,EAC0G;IAC1G,MAAM,WAAW,WAAW,oMAAY,eAAA,GAA8B;IACtE,MAAM,4BAA4B,4BAA4B,YAAY,WAAW,uBAAA,GAAmC;IAGxH,MAAM,uBAAuB,WAAW;QAWtC,OAAO,wBAAwB,IAAA,EAA4B;YACzD,OAAO,0BAA0B,KAAK,OAAO;QAC/C;QAEA,OAAO,WAAW,KAAA,EAA0E;YAC1F,IAAI,CAAC,WAAW,YAAA,CAAa,KAAK,EAAG,CAAA,OAAO;YAC5C,IAAI,UAAmB;YACvB,MAAO,KAAM;gBACX,UAAU,OAAO,cAAA,CAAe,OAAO;gBACvC,IAAI,CAAC,QAAS,CAAA;gBACd,IAAI,eAAe,QAAQ,WAAA,IAAe,QAAQ,WAAA,CAAY,SAAA,KAAc,UAAW,CAAA,OAAO;YAChG;YACA,OAAO;QACT;QAnBA,YAAA,GAAe,IAAA,CAAY;YAEzB,KAAA,CAAM,GAAG,SAAS,GAAG,IAAI,CAAC;YAL5B,IAAA,CAAO,IAAA,GAAO,cAAuB,OAAT,SAAS,EAAA;YAMnC,IAAA,CAAK,eAAA,GAAkB;QACzB;IAgBF;IAzBM,eACmB,SAAA,GAAY;;IA2BrC,OAAO;AACT;AAWA,IAAM,mBAAmB,4BACvB,YACA,qBACA,CAAC,oBAA8B;QAC7B;QACA,oLAAqM,OAAjB,iBAAiB;QACrM;YACE;QACF;KACF,EACA,CAAC;;WAAS;mCACP,iDAAc,iBAAA,sQAAqB,WAAA,EAAS,yDAAyD;KACxG;;AAGF,IAAM,mBAAmB,4BACvB,YACA,sBACA,CAAC,UAAoB;QACnB;QACA;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAO;KAAA;AAGzB,IAAM,cAAc,4BAClB,YACA,gBACA,CAAC,UAAoB;QACnB;QACA,oMAAW,WAAA,EAAS,gCAAgC;QACpD;YACE;QACF;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,qBAAqB,4BACzB,YACA,wBACA,CAAC,iBAA2B;QAC1B;kMACA,WAAA,sBAGM,eAAe,GAAA,CAAI,CAAC,GAAG,8LAAM,WAAA,qBAClB,IAAI,CAAC,EAAK,KAAK,SAAA,CAAU,GAAG,KAAA,GAAW,CAAC,CAAC,GACnD,IAAA,CAAK,MAAM,CAAC;QAEnB;YACE,iBAAiB;QACnB;KACF,EACA,CAAC;;WAAS;kFACO,eAAA,iDAAd,wBAAiC,oMAAA,EAAS,yDAAyD;KACtG;;AAGF,IAAM,6BAA6B,4BACjC,YACA,gCACA,WACA;AAGF,IAAM,+BAA+B,4BACnC,4BACA,kCACA,WACA;AAGF,IAAM,8BAA8B,4BAClC,8BACA,mCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oBAAoB,4BACxB,8BACA,uBACA,CAAC,aAAuB;QACtB;QACA,mFAA6F,OAAV,UAAU,EAAA;KAC/F,EACA,CAAC;;WAAS;SACP,oEAAc,UAAA,wPAAc,WAAA,EAAS,mDAAmD;KAC3F;;AAGF,IAAM,6BAA6B,4BACjC,8BACA,kCACA,CAAC,aAA8C;QAC7C;kMACA,WAAA,sBACwC,UAAU;QAIlD;YACE,cAAc;QAChB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,YAAY;KAAA;AAGnC,IAAM,qBAAqB,4BACzB,8BACA,wBACA,IAAM;QACJ;kMACA,WAAA;KAKF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,yBAAyB,4BAC7B,8BACA,4BACA,CAAC,kBAAiD,qBAA0D;QAC1G;QACA,0CAA0G,OAAhE,SAAgF,UAA7D,GAAA,CAAI,CAAA,IAAK,IAAK,OAAD,CAAC,EAAA,EAAG,IAAE,IAAA,CAAK,MAAM,CAAC,EAAA,eAA8B,yBAAA;QAC1H;YACE,oBAAoB;YACpB,sBAAsB;QACxB;KACF,EACA,CAAC,OAAc;QACb,KAAK,kBAAA;QACL,KAAK,oBAAA;KACP;AAGF,IAAM,8BAA8B,4BAClC,8BACA,kCACA,CAAC,YAAsB;QACrB;QACA,oDAA6E,OAAzB,KAAK,SAAA,CAAU,SAAS,CAAC,EAAA;QAC7E;YACE,YAAY;QACd;KACF,EACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,yBAAyB,4BAC7B,8BACA,6BACA,CAAC,YAAsB;QACrB;QACA,sDAA+E,OAAzB,KAAK,SAAA,CAAU,SAAS,CAAC,EAAA;QAC/E;YACE,YAAY;QACd;KACF,EACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,6BAA6B,4BACjC,8BACA,kCACA,CAAC,YAAsB;QACrB;QACA,2DAAoF,OAAzB,KAAK,SAAA,CAAU,SAAS,CAAC,EAAA;QACpF;YACE,YAAY;QACd;KACF,EACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,0BAA0B,4BAC9B,8BACA,8BACA,WACA;AAGF,IAAM,6BAA6B,4BACjC,yBACA,iCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,0BAA0B,4BAC9B,yBACA,8BACA,CAAC;;WAAgC;QAC/B;QACA,mEAA+I,OAA5E,YAAY,iCAAwD,OAAvB,UAAU,WAAA,CAAY,CAAC,EAAA,QAAM,EAAE;QAC/I;YAAE,mBAAmB,sFAAW,OAAA,CAAQ,oEAAK;QAAK;KACpD;GACA,CAAC;;WAAc;wCAAM,iBAAA,mDAAL,0BAA0B,KAAA,CAAS;KAAA;;AAGrD,IAAM,oCAAoC,4BACxC,yBACA,0CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,yBACA,mCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,gCAAgC,4BACpC,4BACA,mCACA,WACA;AAOF,IAAM,+BAA+B,4BACnC,+BACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,+BAA+B,4BACnC,+BACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,uCAAuC,4BAC3C,+BACA,4CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,sCAAsC,4BAC1C,+BACA,2CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,8CAA8C,4BAClD,+BACA,qDACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,8BAA8B,4BAClC,+BACA,iCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,0BAA0B,4BAC9B,4BACA,6BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,gCACA,WACA;AAGF,IAAM,+BAA+B,4BACnC,4BACA,kCACA,WACA;AAGF,IAAM,qBAAqB,4BACzB,8BACA,wBACA,WACA;AAGF,IAAM,wBAAwB,4BAC5B,oBACA,2BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,qBAAqB,4BACzB,oBACA,wBACA,CAAC;;WAAgC;QAC/B;QACA,6DAAyI,OAA5E,YAAY,iCAAwD,OAAvB,UAAU,WAAA,CAAY,CAAC,EAAA,QAAM,EAAE;QACzI;YAAE,+FAAmB,UAAW,OAAA,CAAQ,oEAAK;QAAK;KACpD;GACA,CAAC,OAAc;QAAC,KAAK,iBAAA,GAAoB,IAAI,KAAK,KAAK,iBAAiB,IAAI,KAAA,CAAS;KAAA;AAGvF,IAAM,+BAA+B,4BACnC,oBACA,oCACA,CAAC,mBAA2B,kBAA4B;QACtD;QACA,uEAAgE,KAAK,SAAA,CAAU,iBAAiB,CAAC,EAAA,sCAAoE,OAA/B,KAAK,SAAA,CAAU,eAAe,CAAC,EAAA;QACrK;YACE,qBAAqB;YACrB,mBAAmB;QACrB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,mBAAA;QAAqB,KAAK,iBAAiB;KAAA;AAIlE,IAAM,oBAAoB,4BACxB,YACA,uBACA,WACA;AAGF,IAAM,gCAAgC,4BACpC,mBACA,sCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,mBACA,iCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAIT,IAAM,mBAAmB,4BACvB,mBACA,qBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,6BACA,SAAC;QAAe,+FAAuC;WAAU;QAC/D;QACA,4BAAqB,KAAK,SAAA,CAAU,KAAK,CAAC,EAAA,mBAAgO,OAA9M,8BAA8B,6KAA6K,GAAG;QAC1Q;YACE;YACA,kCAAkC;QACpC;KACF;GACA,CAAC;;WAAc;QAAC,KAAK,KAAA;kDAAO,KAAK,gCAAA,2GAAoC,KAAK;KAAA;;AAG5E,IAAM,mBAAmB,4BACvB,YACA,sBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,YACA,oCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,qBAAqB,4BACzB,YACA,0BACA,CAAC,SAAmB;QAClB;QACA,8BAAoC,OAAN,MAAM,EAAA;QACpC;YACE,SAAS;QACX;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,eAAe,4BACnB,YACA,kBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAIT,IAAM,kBAAkB,4BACtB,YACA,qBACA,CAAC,cAAsB;IACrB,IAAI,OAAO,cAAc,SAAU,CAAA,MAAM,yLAAI,sBAAA,CAAoB,2DAA2D;IAC5H,OAAO;QACL;QACA,WAAoB,OAAT,SAAS,EAAA;QACpB;YACE,YAAY;QACd;KACF;AACF,GACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,yBAAyB,4BAC7B,YACA,6BACA,CAAC,YAAsB;QACrB;QACA,+BAAwC,OAAT,SAAS,EAAA;QACxC;YACE,YAAY;QACd;KACF,EACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,qBAAqB,4BACzB,YACA,yBACA,CAAC,WAAqB;QACpB;QACA,sBAA8B,OAAR,QAAQ,EAAA;QAC9B;YACE,WAAW;QACb;KACF,EACA,CAAC,OAAc;QAAC,KAAK,SAAS;KAAA;AAIhC,IAAM,mBAAmB,4BACvB,YACA,uBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,mCAAmC,4BACvC,YACA,uCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAIT,IAAM,kCAAkC,4BACtC,YACA,sCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,YACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAIT,IAAM,wBAAwB,4BAC5B,YACA,2BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,4BAA4B,4BAChC,YACA,gCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,iCACA,WACA;AAGF,IAAM,mBAAmB,4BACvB,4BACA,sBACA,CAAC,YAAsB;QACrB;QACA,yCAAkD,OAAT,SAAS,EAAA;QAClD;YACE,YAAY;QACd;KACF,EACA,CAAC;;WAAS;6EACO,UAAA,4CAAd,4MAA4B,WAAA,EAAS,kDAAkD;KAC1F;;AAGF,IAAM,kBAAkB,4BACtB,4BACA,qBACA,CAAC,YAAsB;QACrB;QACA,wCAAiD,OAAT,SAAS,EAAA;QACjD;YACE;QACF;KACF,EACA,CAAC;;WAAS;4EACO,SAAA,2CAAd,sBAA2B,gMAAA,EAAS,gDAAgD;KACvF;;AAGF,IAAM,0BAA0B,4BAC9B,YACA,+BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,wBAAwB,4BAC5B,YACA,sBACA,WACA;AAGF,IAAM,2BAA2B,4BAC/B,uBACA,+BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,0BAA0B,4BAC9B,uBACA,6BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,uBACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,qCAAqC,4BACzC,uBACA,0CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,+BAA+B,4BACnC,YACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,uBAAuB,4BAC3B,YACA,0BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,yBAAyB,4BAC7B,YACA,8BACA,CAAC,OAAe,eAAgC;QAC9C;QACA,4BAAqB,KAAK,EAAA,4CAAuD,OAAZ,YAAY,EAAA;QACjF;YACE;YACA,eAAe;QACjB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,KAAA;QAAO,KAAK,aAAa;KAAA;AAIhD,IAAM,4BAA4B,4BAChC,YACA,+BACA,CAAC,UAAoB;QACnB;QACA;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAI9B,IAAM,uBAAuB,4BAC3B,YACA,0BACA,CAAC,SAAiB,OAAiB;QACjC;QACA;QACA;YACE;YACA;QACF;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAA;QAAS,KAAK,IAAI;KAAA;AAGzC,IAAM,8BAA8B,4BAClC,YACA,iCACA,CAAC,UAAoB;QACnB;QACA;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAI9B,IAAM,qBAAqB,4BACzB,YACA,wBACA,CAAC,eAAyB;QACxB;QACA,eAA2B,OAAZ,YAAY,EAAA;QAC3B;YACE,eAAe;QACjB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,aAAa;KAAA;AAGpC,IAAM,0BAA0B,4BAC9B,YACA,0BACA,CAAC,cAAsB,eAAmC,cAA2C;QACnG;QACA,qBAAc,KAAK,SAAA,CAAU,YAAY,CAAC,EAAA,2DAAmD,KAAK,SAAA,CAAU,WAAW,CAAC,EAAA,gBAA4C,OAA7B,KAAK,SAAA,CAAU,aAAa,CAAC,EAAA;QACpK;YACE,eAAe;YACf,gBAAgB;YAChB,cAAc;QAChB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,aAAA;QAAe,KAAK,cAAA;QAAgB,KAAK,YAAY;KAAA;AAG5E,IAAM,8BAA8B,4BAClC,YACA,kCACA,CAAC,eAAyB;QACxB;QACA,iCAA6C,OAAZ,YAAY,EAAA;QAC7C;YACE,eAAe;QACjB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,aAAa;KAAA;AAGpC,IAAM,eAAe,4BACnB,YACA,kBACA,CAAC,SAAmB;QAClB;QACA,QAAc,OAAN,MAAM,EAAA;QACd;YACE,SAAS;QACX;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,oBAAoB,4BACxB,YACA,uBACA,CAAC,SAAmB;QAClB;QACA,QAAc,OAAN,MAAM,EAAA;QACd;YACE,SAAS;QACX;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,yBAAyB,4BAC7B,YACA,6BACA,CAAC,QAAgB,SAAmB;QAClC;QACA,eAAQ,MAAM,EAAA,0BAA+B,OAAN,MAAM,EAAA;QAC7C;YACE,SAAS;YACT,SAAS;QACX;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAA;QAAS,KAAK,OAAO;KAAA;AAI5C,IAAM,6BAA6B,4BACjC,YACA,iCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oCAAoC,4BACxC,YACA,0CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,+CAA+C,4BACnD,YACA,sDACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,0CAA0C,4BAC9C,YACA,iDACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,iDAAiD,4BACrD,YACA,0DACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,kDAAkD,4BACtD,YACA,2DACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,+BAA+B,4BACnC,YACA,qCACA,CAAC,WAAsB;QACrB;QACA;QACA;YACE,sDAAW,WAAY;QACzB;KACF,EACA,CAAC;;WAAc;SAAC,uBAAK,SAAA,6DAAa,KAAA,CAAS;KAAA;;AAG7C,IAAM,eAAe,4BACnB,YACA,iBACA,CAAC,QAAkB;QACjB;QACA,cAAmB,OAAL,KAAK,EAAA;KACrB,EACA,CAAC,OAAc;QAAC,KAAK,KAAK;KAAA;AAG5B,IAAM,+CAA+C,4BACnD,YACA,sDACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oBAAoB,4BACxB,YACA,uBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oCAAoC,4BACxC,YACA,2CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6CAA6C,4BACjD,YACA,sDACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oCAAoC,4BACxC,YACA,wCACA,CAAC,cAAwB;QACvB;QACA;QACA;YACE,cAAc;QAChB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,YAAY;KAAA;AAG9B,IAAM,kBAAkB,4BACtB,YACA,qBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,gCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,YACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,4BAA4B,4BAChC,YACA,+BACA,CAAC,QAAQ,eAAiB;QACxB;QACA,eAAQ,MAAM,EAAA,8BAAyC,OAAZ,YAAY,EAAA;QACvD;YACE,SAAS;YACT,eAAe;QACjB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAA;QAAS,KAAK,aAAa;KAAA;AAG7C,IAAM,yBAAyB,4BAC7B,YACA,4BACA,CAAC,QAAQ,QAAQ,eAAiB;QAChC;QACA,QAA2C,OAAnC,KAA+C,CAAzC,EAAA,8BAAqD,MAAM,eAAlB,aAAkB,eAAA;QACzE;YACE,SAAS;YACT,SAAS;YACT,eAAe;QACjB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAA;QAAS,KAAK,OAAA;QAAS,KAAK,aAAa;KAAA;AAG3D,IAAM,yBAAyB,4BAC7B,YACA,6BACA,CAAC,QAAQ,QAAQ,eAAiB;QAChC;QACA,eAAQ,MAAM,EAAA,qCAA6B,YAAY,EAAA,aAAkB,OAAN,MAAM,EAAA;QACzE;YACE,SAAS;YACT,SAAS;YACT,eAAe;QACjB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAA;QAAS,KAAK,OAAA;QAAS,KAAK,aAAa;KAAA;AAG3D,IAAM,+BAA+B,4BACnC,YACA,oCACA,CAAC,aAAe;QACd;QACA,qCAA+C,OAAV,UAAU,EAAA;QAC/C;YACE,aAAa;QACf;KACF,EACA,CAAC,OAAS;QAAC,KAAK,WAAW;KAAA;AAG7B,IAAM,iCAAiC,4BACrC,YACA,sCACA,CAAC,aAAe;QACd;QACA,uCAAiD,OAAV,UAAU,EAAA;QACjD;YACE,aAAa;QACf;KACF,EACA,CAAC,OAAS;QAAC,KAAK,WAAW;KAAA;AAG7B,IAAM,2BAA2B,4BAC/B,YACA,8BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,4BAA4B,4BAChC,YACA,gCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,gDAAgD,4BACpD,YACA,yDACA,SAAC,MAAe;QAA8B,+FAAuC;WAAU;QAC7F;QACA,QAAgB,OAAR,IAAI,EAAA,kCAA0B,KAAwB,OAAnB,mBAAmB,EAAA,QAAO,EAAE,EAAA,0DAAuQ,OAA9M,8BAA8B,6KAA6K,GAAG;QAC9U;YACE;YACA,uBAAuB,uFAAuB;YAC9C,kCAAkC;QACpC;KACF;GACA,CAAC;;WAAS;QAAC,KAAK,IAAA;QAAM,KAAK,qBAAA;kDAAuB,KAAK,gCAAA,2GAAoC,KAAK;KAAA;;AAGlG,IAAM,0BAA0B,4BAC9B,YACA,wBACA,CAAC,UAAmB;QAClB;QACA;QACA;KACF,EACA,CAAC,OAAc;QAAC,IAAI;KAAA;AAGtB,IAAM,eAAe,4BACnB,YACA,kBACA,CAAC,UAAoB;QACnB;QACA;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,sBAAsB,4BAC1B,YACA,0BACA;QAAC,2EAAkB;WAA4D;QAC7E;QACA;KACF;GACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,mBAAmB,4BACvB,YACA,uBACA;QAAC,2EAAkB;WAAuD;QACxE;QACA;KACF;GACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAI9B,IAAM,iBAAiB,4BACrB,YACA,qBACA,WACA;AAGF,IAAM,gBAAgB,4BACpB,gBACA,mBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,gBAAgB,4BACpB,gBACA,mBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,kBAAkB,4BACtB,gBACA,sBACA,CAAC,cAAsB,aAAuB;QAC5C;QACA,wBAAwD,OAAhC,GAA0C,SAA9B,EAAA,qBAA8B,mBAAA;QAClE;YAAE,eAAe;YAAc,aAAa;QAAW;KACzD,EACA,CAAC,OAAS;QAAC,KAAK,aAAA;QAAe,KAAK,WAAW;KAAA;AAGjD,IAAM,iBAAiB,4BACrB,gBACA,qBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,gBACA,oCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,4BAA4B,4BAChC,YACA,gCACA,CAAC,eAAyB;QACxB;QACA,uBAAmC,OAAZ,YAAY,EAAA;QACnC;YACE,eAAe;QACjB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,aAAa;KAAA;AAGpC,IAAM,sBAAsB,4BAC1B,YACA,yBACA,CAAC,QAAkB;QACjB;QACA,sCAA2C,OAAL,KAAK;QAC3C;YAAE;QAAM;KACV,EACA,CAAC,OAAc;QAAC,KAAK,KAAK;KAAA;AAG5B,IAAM,4BAA4B,4BAChC,YACA,gCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,eAAe,4BACnB,YACA,kBACA,CAAC,SAAmB;QAClB;QACA,iBAAuB,OAAN,MAAM,EAAA;QACvB;YACE,SAAS;QACX;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAO;KAAA;AAGzB,IAAM,+BAA+B,4BACnC,YACA,qCACA,CAAC,QAAgB,YAAoB,kBAA+C,qBAAwC;QAC1H;QACA,cAAO,kBAAkB,EAAA,oBAAY,KAAK,SAAA,CAAU,UAAU,CAAC,EAAA,kDAA4E,OAA3B,KAAK,SAAA,CAAU,MAAM,CAAC,EAAA,MAA2Q,0BAAnP,0DAAmD,gBAAgB,EAAA,sCAAuD,OAAlB,kBAAkB,EAAA,KAAM,EAAA,kHAAmH;QACjZ;YACE,SAAS;YACT,aAAa;YACb,oBAAoB,8EAAoB;YACxC,sBAAsB;QACxB;KACF,EACA,CAAC;;WAAS;QAAC,KAAK,OAAA;QAAS,KAAK,WAAA;yCAAkB,kBAAA,oDAAL,2BAA2B,KAAA;QAAW,KAAK,oBAAoB;KAAA;;AAG5G,IAAM,uBAAuB,4BAC3B,YACA,2BACA,CAAC,aAAuB;QACtB;QACA,oBAA8C,OAA1B,KAAK,SAAA,CAAU,UAAU,CAAC,EAAA;QAC9C;YACE,aAAa;QACf;KACF,EACA,CAAC,OAAS;QAAC,KAAK,WAAW;KAAA;AAG7B,IAAM,oBAAoB,4BACxB,YACA,wBACA,CAAC,SAAiB,aAA8C;QAC9D;QACA,wBAAiB,KAAK,SAAA,CAAU,OAAO,CAAC,EAAA,mBAAgG,OAA9E,eAAe,WAAW,iDAAiD,GAAG;QACxI;YACE,UAAU;YACV,aAAa;QACf;KACF,EACA,CAAC,OAAS;QAAC,KAAK,QAAA;QAAU,KAAK,WAAW;KAAA;AAG5C,IAAM,gCAAgC,4BACpC,YACA,sCACA,CAAC,SAA6B,YAAoB,mBAAgD,qBAAwC;QACxI;QACA,OAAqC,OAA9B,kBAAkB,EAAA,yBAAiB,SAAA,CAAU,UAAU,CAAC,EAAA,2EAAoV,OAA1Q,oBAAoB,2DAAoD,iBAAiB,EAAA,sCAAuD,OAAlB,kBAAkB,EAAA,KAAM,EAAA,mHAAoH;QACnZ;YACE,mDAAU,UAAW;YACrB,aAAa;YACb,qBAAqB,iFAAqB;YAC1C,sBAAsB;QACxB;KACF,EACA,CAAC;wBAAwD;WAA/C;+BAAM,QAAA,0CAAL,iBAAiB,KAAA;QAAW,KAAK,WAAA;0CAAkB,mBAAA,iFAAuB,KAAA;QAAW,KAAK,oBAAoB;KAAA;;AAG3H,IAAM,iCAAiC,4BACrC,YACA,qCACA,CAAC,QAAgB,YAAoB,WAAqB;QACxD;QACA,2BAAoB,KAAK,SAAA,CAAU,MAAM,CAAC,EAAA,2DAAuH,OAA7D,CAAqE,IAAhE,SAAA,CAAU,UAAU,CAAC,EAAA,oCAA2C,iBAAA;QACzK;YACE,SAAS;YACT,aAAa;YACb;QACF;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAA;QAAS,KAAK,WAAA;QAAa,KAAK,QAAQ;KAAA;AAQnD,IAAM,cAAc;IACzB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACF;AAIA,IAAM,kBAAkB,aAAA,GAAA,IAAI,IAAY;AACxC,KAAA,MAAW,CAAC,GAAGA,WAAU,CAAA,IAAK,OAAO,OAAA,CAAQ,WAAW,EAAG;IACzD,IAAI,gBAAgB,GAAA,CAAIA,YAAW,SAAS,GAAG;QAC7C,MAAM,IAAI,MAAM,+BAAmD,CAAE,MAAtBA,YAAW,SAAS;IACrE;IACA,gBAAgB,GAAA,CAAIA,YAAW,SAAS;AAC1C","debugId":null}},
    {"offset": {"line": 2267, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/maps.tsx"],"sourcesContent":["import { Result } from \"./results\";\n\nexport class WeakRefIfAvailable<T extends object> {\n  private readonly _ref: { deref: () => T | undefined };\n\n  constructor(value: T) {\n    if (typeof WeakRef === \"undefined\") {\n      this._ref = { deref: () => value };\n    } else {\n      this._ref = new WeakRef<T>(value);\n    }\n  }\n\n  deref(): T | undefined {\n    return this._ref.deref();\n  }\n}\nundefined?.test(\"WeakRefIfAvailable\", ({ expect }) => {\n  // Test with an object\n  const obj = { id: 1, name: \"test\" };\n  const weakRef = new WeakRefIfAvailable(obj);\n\n  // Test deref returns the original object\n  expect(weakRef.deref()).toBe(obj);\n\n  // Test with a different object\n  const obj2 = { id: 2, name: \"test2\" };\n  const weakRef2 = new WeakRefIfAvailable(obj2);\n  expect(weakRef2.deref()).toBe(obj2);\n  expect(weakRef2.deref()).not.toBe(obj);\n\n  // We can't easily test garbage collection in this environment,\n  // but we can verify the basic functionality works\n});\n\n\n/**\n * A WeakMap-like object that can be iterated over.\n *\n * Note that it relies on WeakRef, and always falls back to the regular Map behavior (ie. no GC) in browsers that don't support it.\n */\nexport class IterableWeakMap<K extends object, V> {\n  private readonly _weakMap: WeakMap<K & WeakKey, { value: V, keyRef: WeakRefIfAvailable<K & WeakKey> }>;\n  private readonly _keyRefs: Set<WeakRefIfAvailable<K & WeakKey>>;\n\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    const mappedEntries = entries?.map((e) => [e[0], { value: e[1], keyRef: new WeakRefIfAvailable(e[0]) }] as const);\n    this._weakMap = new WeakMap(mappedEntries ?? []);\n    this._keyRefs = new Set(mappedEntries?.map((e) => e[1].keyRef) ?? []);\n  }\n\n  get(key: K): V | undefined {\n    return this._weakMap.get(key)?.value;\n  }\n\n  set(key: K, value: V): this {\n    const existing = this._weakMap.get(key);\n    const updated = { value, keyRef: existing?.keyRef ?? new WeakRefIfAvailable(key) };\n    this._weakMap.set(key, updated);\n    this._keyRefs.add(updated.keyRef);\n    return this;\n  }\n\n  delete(key: K): boolean {\n    const res = this._weakMap.get(key);\n    if (res) {\n      this._weakMap.delete(key);\n      this._keyRefs.delete(res.keyRef);\n      return true;\n    }\n    return false;\n  }\n\n  has(key: K): boolean {\n    return this._weakMap.has(key) && this._keyRefs.has(this._weakMap.get(key)!.keyRef);\n  }\n\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    for (const keyRef of this._keyRefs) {\n      const key = keyRef.deref();\n      const existing = key ? this._weakMap.get(key) : undefined;\n      if (!key) {\n        // This can happen if the key was GCed. Remove it so the next iteration is faster.\n        this._keyRefs.delete(keyRef);\n      } else if (existing) {\n        yield [key, existing.value];\n      }\n    }\n  }\n\n  [Symbol.toStringTag] = \"IterableWeakMap\";\n}\nundefined?.test(\"IterableWeakMap\", ({ expect }) => {\n  // Test basic functionality\n  const map = new IterableWeakMap<{ id: number }, string>();\n\n  // Create object keys\n  const obj1 = { id: 1 };\n  const obj2 = { id: 2 };\n\n  // Test set and get\n  map.set(obj1, \"value1\");\n  expect(map.get(obj1)).toBe(\"value1\");\n\n  // Test has\n  expect(map.has(obj1)).toBe(true);\n  expect(map.has(obj2)).toBe(false);\n  expect(map.has({ id: 1 })).toBe(false); // Different object with same content\n\n  // Test with multiple keys\n  map.set(obj2, \"value2\");\n  expect(map.get(obj2)).toBe(\"value2\");\n  expect(map.get(obj1)).toBe(\"value1\"); // Original still exists\n\n  // Test delete\n  expect(map.delete(obj1)).toBe(true);\n  expect(map.has(obj1)).toBe(false);\n  expect(map.get(obj1)).toBeUndefined();\n  expect(map.has(obj2)).toBe(true); // Other key still exists\n\n  // Test delete non-existent key\n  expect(map.delete({ id: 3 })).toBe(false);\n\n  // Test iteration\n  const iterMap = new IterableWeakMap<{ id: number }, number>();\n  const iterObj1 = { id: 1 };\n  const iterObj2 = { id: 2 };\n  const iterObj3 = { id: 3 };\n\n  iterMap.set(iterObj1, 1);\n  iterMap.set(iterObj2, 2);\n  iterMap.set(iterObj3, 3);\n\n  const entries = Array.from(iterMap);\n  expect(entries.length).toBe(3);\n\n  // Find entries by their values since we can't directly compare objects in the array\n  const values = entries.map(entry => entry[1]);\n  expect(values).toContain(1);\n  expect(values).toContain(2);\n  expect(values).toContain(3);\n\n  // Test constructor with entries\n  const initialEntries: [{ id: number }, string][] = [\n    [{ id: 4 }, \"initial1\"],\n    [{ id: 5 }, \"initial2\"]\n  ];\n  const mapWithEntries = new IterableWeakMap(initialEntries);\n\n  // We can't directly access the initial entries since they're different object references\n  // But we can verify the map has the correct number of entries\n  const entriesFromConstructor = Array.from(mapWithEntries);\n  expect(entriesFromConstructor.length).toBe(2);\n});\n\n/**\n * A map that is a IterableWeakMap for object keys and a regular Map for primitive keys. Also provides iteration over both\n * object and primitive keys.\n *\n * Note that, just like IterableWeakMap, older browsers without support for WeakRef will use a regular Map for object keys.\n */\nexport class MaybeWeakMap<K, V> {\n  private readonly _primitiveMap: Map<K, V>;\n  private readonly _weakMap: IterableWeakMap<K & WeakKey, V>;\n\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    const entriesArray = [...entries ?? []];\n    this._primitiveMap = new Map(entriesArray.filter((e) => !this._isAllowedInWeakMap(e[0])));\n    this._weakMap = new IterableWeakMap(entriesArray.filter((e): e is [K & WeakKey, V] => this._isAllowedInWeakMap(e[0])));\n  }\n\n  private _isAllowedInWeakMap(key: K): key is K & WeakKey {\n    return (typeof key === \"object\" && key !== null) || (typeof key === \"symbol\" && Symbol.keyFor(key) === undefined);\n  }\n\n  get(key: K): V | undefined {\n    if (this._isAllowedInWeakMap(key)) {\n      return this._weakMap.get(key);\n    } else {\n      return this._primitiveMap.get(key);\n    }\n  }\n\n  set(key: K, value: V): this {\n    if (this._isAllowedInWeakMap(key)) {\n      this._weakMap.set(key, value);\n    } else {\n      this._primitiveMap.set(key, value);\n    }\n    return this;\n  }\n\n  delete(key: K): boolean {\n    if (this._isAllowedInWeakMap(key)) {\n      return this._weakMap.delete(key);\n    } else {\n      return this._primitiveMap.delete(key);\n    }\n  }\n\n  has(key: K): boolean {\n    if (this._isAllowedInWeakMap(key)) {\n      return this._weakMap.has(key);\n    } else {\n      return this._primitiveMap.has(key);\n    }\n  }\n\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    yield* this._primitiveMap;\n    yield* this._weakMap;\n  }\n\n  [Symbol.toStringTag] = \"MaybeWeakMap\";\n}\nundefined?.test(\"MaybeWeakMap\", ({ expect }) => {\n  // Test with primitive keys\n  const map = new MaybeWeakMap<string | object, number>();\n\n  // Test with string keys\n  map.set(\"key1\", 1);\n  map.set(\"key2\", 2);\n  expect(map.get(\"key1\")).toBe(1);\n  expect(map.get(\"key2\")).toBe(2);\n  expect(map.has(\"key1\")).toBe(true);\n  expect(map.has(\"nonexistent\")).toBe(false);\n\n  // Test with object keys\n  const obj1 = { id: 1 };\n  const obj2 = { id: 2 };\n  map.set(obj1, 3);\n  map.set(obj2, 4);\n  expect(map.get(obj1)).toBe(3);\n  expect(map.get(obj2)).toBe(4);\n  expect(map.has(obj1)).toBe(true);\n\n  // Test delete with primitive key\n  expect(map.delete(\"key1\")).toBe(true);\n  expect(map.has(\"key1\")).toBe(false);\n  expect(map.delete(\"nonexistent\")).toBe(false);\n\n  // Test delete with object key\n  expect(map.delete(obj1)).toBe(true);\n  expect(map.has(obj1)).toBe(false);\n\n  // Test iteration\n  const entries = Array.from(map);\n  expect(entries.length).toBe(2);\n  expect(entries).toContainEqual([\"key2\", 2]);\n  expect(entries).toContainEqual([obj2, 4]);\n\n  // Test constructor with entries\n  const initialEntries: [string | object, number][] = [\n    [\"initial1\", 10],\n    [{ id: 3 }, 20]\n  ];\n  const mapWithEntries = new MaybeWeakMap(initialEntries);\n  expect(mapWithEntries.get(\"initial1\")).toBe(10);\n  expect(mapWithEntries.get(initialEntries[1][0])).toBe(20);\n});\n\n\ntype DependenciesMapInner<V> = (\n  & { map: MaybeWeakMap<unknown, DependenciesMapInner<V>> }\n  & (\n    | { hasValue: true, value: V }\n    | { hasValue: false, value: undefined }\n  )\n);\n\n/**\n * A map that stores values indexed by an array of keys. If the keys are objects and the environment supports WeakRefs,\n * they are stored in a WeakMap.\n */\nexport class DependenciesMap<K extends any[], V> {\n  private _inner: DependenciesMapInner<V> = { map: new MaybeWeakMap(), hasValue: false, value: undefined };\n\n  private _valueToResult(inner: DependenciesMapInner<V>): Result<V, void> {\n    if (inner.hasValue) {\n      return Result.ok(inner.value);\n    } else {\n      return Result.error(undefined);\n    }\n  }\n\n\n  private _unwrapFromInner(dependencies: any[], inner: DependenciesMapInner<V>): Result<V, void> {\n    if ((dependencies.length === 0)) {\n      return this._valueToResult(inner);\n    } else {\n      const [key, ...rest] = dependencies;\n      const newInner = inner.map.get(key);\n      if (!newInner) {\n        return Result.error(undefined);\n      }\n      return this._unwrapFromInner(rest, newInner);\n    }\n  }\n\n  private _setInInner(dependencies: any[], value: Result<V, void>, inner: DependenciesMapInner<V>): Result<V, void> {\n    if (dependencies.length === 0) {\n      const res = this._valueToResult(inner);\n      if (value.status === \"ok\") {\n        inner.hasValue = true;\n        inner.value = value.data;\n      } else {\n        inner.hasValue = false;\n        inner.value = undefined;\n      }\n      return res;\n    } else {\n      const [key, ...rest] = dependencies;\n      let newInner = inner.map.get(key);\n      if (!newInner) {\n        inner.map.set(key, newInner = { map: new MaybeWeakMap(), hasValue: false, value: undefined });\n      }\n      return this._setInInner(rest, value, newInner);\n    }\n  }\n\n  private *_iterateInner(dependencies: any[], inner: DependenciesMapInner<V>): IterableIterator<[K, V]> {\n    if (inner.hasValue) {\n      yield [dependencies as K, inner.value];\n    }\n    for (const [key, value] of inner.map) {\n      yield* this._iterateInner([...dependencies, key], value);\n    }\n  }\n\n  get(dependencies: K): V | undefined {\n    return Result.or(this._unwrapFromInner(dependencies, this._inner), undefined);\n  }\n\n  set(dependencies: K, value: V): this {\n    this._setInInner(dependencies, Result.ok(value), this._inner);\n    return this;\n  }\n\n  delete(dependencies: K): boolean {\n    return this._setInInner(dependencies, Result.error(undefined), this._inner).status === \"ok\";\n  }\n\n  has(dependencies: K): boolean {\n    return this._unwrapFromInner(dependencies, this._inner).status === \"ok\";\n  }\n\n  clear(): void {\n    this._inner = { map: new MaybeWeakMap(), hasValue: false, value: undefined };\n  }\n\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    yield* this._iterateInner([], this._inner);\n  }\n\n  [Symbol.toStringTag] = \"DependenciesMap\";\n}\nundefined?.test(\"DependenciesMap\", ({ expect }) => {\n  // Test basic functionality\n  const map = new DependenciesMap<[string, number], string>();\n\n  // Test set and get\n  map.set([\"key\", 1], \"value1\");\n  expect(map.get([\"key\", 1])).toBe(\"value1\");\n\n  // Test has\n  expect(map.has([\"key\", 1])).toBe(true);\n  expect(map.has([\"key\", 2])).toBe(false);\n\n  // Test with different dependencies\n  map.set([\"key\", 2], \"value2\");\n  expect(map.get([\"key\", 2])).toBe(\"value2\");\n  expect(map.get([\"key\", 1])).toBe(\"value1\"); // Original still exists\n\n  // Test delete\n  expect(map.delete([\"key\", 1])).toBe(true);\n  expect(map.has([\"key\", 1])).toBe(false);\n  expect(map.get([\"key\", 1])).toBeUndefined();\n  expect(map.has([\"key\", 2])).toBe(true); // Other key still exists\n\n  // Test delete non-existent key\n  expect(map.delete([\"nonexistent\", 1])).toBe(false);\n\n  // Test clear\n  map.clear();\n  expect(map.has([\"key\", 2])).toBe(false);\n\n  // Test with object keys\n  const objMap = new DependenciesMap<[object, number], string>();\n  const obj1 = { id: 1 };\n  const obj2 = { id: 2 };\n  objMap.set([obj1, 1], \"object1\");\n  objMap.set([obj2, 2], \"object2\");\n  expect(objMap.get([obj1, 1])).toBe(\"object1\");\n  expect(objMap.get([obj2, 2])).toBe(\"object2\");\n\n  // Test iteration\n  const iterMap = new DependenciesMap<[string], number>();\n  iterMap.set([\"a\"], 1);\n  iterMap.set([\"b\"], 2);\n  iterMap.set([\"c\"], 3);\n\n  const entries = Array.from(iterMap);\n  expect(entries.length).toBe(3);\n  expect(entries).toContainEqual([[\"a\"], 1]);\n  expect(entries).toContainEqual([[\"b\"], 2]);\n  expect(entries).toContainEqual([[\"c\"], 3]);\n});\n"],"names":["_a","_b"],"mappings":"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","debugId":null}},
    {"offset": {"line": 2491, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/bytes.tsx"],"sourcesContent":["import { StackAssertionError } from \"./errors\";\n\nconst crockfordAlphabet = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\nconst crockfordReplacements = new Map([\n  [\"o\", \"0\"],\n  [\"i\", \"1\"],\n  [\"l\", \"1\"],\n]);\n\nexport function toHexString(input: Uint8Array): string {\n  return Array.from(input).map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\nundefined?.test(\"toHexString\", ({ expect }) => {\n  expect(toHexString(new Uint8Array([]))).toBe(\"\");\n  expect(toHexString(new Uint8Array([0]))).toBe(\"00\");\n  expect(toHexString(new Uint8Array([15]))).toBe(\"0f\");\n  expect(toHexString(new Uint8Array([16]))).toBe(\"10\");\n  expect(toHexString(new Uint8Array([255]))).toBe(\"ff\");\n  expect(toHexString(new Uint8Array([1, 2, 3]))).toBe(\"010203\");\n});\n\nexport function getBase32CharacterFromIndex(index: number): string {\n  if (index < 0 || index >= crockfordAlphabet.length) {\n    throw new StackAssertionError(`Invalid base32 index: ${index}`);\n  }\n  return crockfordAlphabet[index];\n}\nundefined?.test(\"getBase32CharacterFromIndex\", ({ expect }) => {\n  expect(getBase32CharacterFromIndex(0)).toBe(\"0\");\n  expect(getBase32CharacterFromIndex(15)).toBe(\"F\");\n  expect(() => getBase32CharacterFromIndex(32)).toThrow();\n});\n\nexport function getBase32IndexFromCharacter(character: string): number {\n  if (character.length !== 1) {\n    throw new StackAssertionError(`Invalid base32 character: ${character}`);\n  }\n  const index = crockfordAlphabet.indexOf(character.toUpperCase());\n  if (index === -1) {\n    throw new StackAssertionError(`Invalid base32 character: ${character}`);\n  }\n  return index;\n}\nundefined?.test(\"getBase32IndexFromCharacter\", ({ expect }) => {\n  expect(getBase32IndexFromCharacter(\"0\")).toBe(0);\n  expect(getBase32IndexFromCharacter(\"F\")).toBe(15);\n  expect(() => getBase32IndexFromCharacter(\"_\")).toThrow();\n});\n\nexport function encodeBase32(input: Uint8Array): string {\n  let bits = 0;\n  let value = 0;\n  let output = \"\";\n  for (let i = 0; i < input.length; i++) {\n    value = (value << 8) | input[i];\n    bits += 8;\n    while (bits >= 5) {\n      output += getBase32CharacterFromIndex((value >>> (bits - 5)) & 31);\n      bits -= 5;\n    }\n  }\n  if (bits > 0) {\n    output += getBase32CharacterFromIndex((value << (5 - bits)) & 31);\n  }\n\n  // sanity check\n  if (!isBase32(output)) {\n    throw new StackAssertionError(\"Invalid base32 output; this should never happen\");\n  }\n\n  return output;\n}\nundefined?.test(\"encodeBase32\", ({ expect }) => {\n  expect(encodeBase32(new Uint8Array([]))).toBe(\"\");\n  expect(encodeBase32(new Uint8Array([1]))).toBe(\"04\");\n  expect(encodeBase32(new Uint8Array([15]))).toBe(\"1W\");\n  expect(encodeBase32(new Uint8Array([16]))).toBe(\"20\");\n  expect(encodeBase32(new Uint8Array([255]))).toBe(\"ZW\");\n  expect(encodeBase32(new Uint8Array([255,255]))).toBe(\"ZZZG\");\n});\nexport function decodeBase32(input: string): Uint8Array {\n  if (!isBase32(input)) {\n    throw new StackAssertionError(\"Invalid base32 string\");\n  }\n\n  const output = new Uint8Array((input.length * 5 / 8) | 0);\n  let bits = 0;\n  let value = 0;\n  let outputIndex = 0;\n  for (let i = 0; i < input.length; i++) {\n    let char = input[i].toLowerCase();\n    if (char === \" \") continue;\n    if (crockfordReplacements.has(char)) {\n      char = crockfordReplacements.get(char)!;\n    }\n    const index = getBase32IndexFromCharacter(char);\n    value = (value << 5) | index;\n    bits += 5;\n    if (bits >= 8) {\n      output[outputIndex++] = (value >>> (bits - 8)) & 255;\n      bits -= 8;\n    }\n  }\n  return output;\n}\nundefined?.test(\"decodeBase32\", ({ expect }) => {\n  expect(decodeBase32(\"\")).toEqual(new Uint8Array([]));\n  expect(decodeBase32(\"00\")).toEqual(new Uint8Array([0]));\n  expect(decodeBase32(\"1W\")).toEqual(new Uint8Array([15]));\n  expect(decodeBase32(\"20\")).toEqual(new Uint8Array([16]));\n  expect(decodeBase32(\"ZW\")).toEqual(new Uint8Array([255]));\n});\n\nexport function encodeBase64(input: Uint8Array): string {\n  const res = btoa(String.fromCharCode(...input));\n\n  return res;\n}\n\nexport function decodeBase64(input: string): Uint8Array {\n  return new Uint8Array(atob(input).split(\"\").map((char) => char.charCodeAt(0)));\n}\nundefined?.test(\"encodeBase64/decodeBase64\", ({ expect }) => {\n  const testCases = [\n    { input: new Uint8Array([72, 101, 108, 108, 111]), expected: \"SGVsbG8=\" },\n    { input: new Uint8Array([0, 1, 2, 3, 4]), expected: \"AAECAwQ=\" },\n    { input: new Uint8Array([255, 254, 253, 252]), expected: \"//79/A==\" },\n    { input: new Uint8Array([]), expected: \"\" },\n  ];\n\n  for (const { input, expected } of testCases) {\n    const encoded = encodeBase64(input);\n    expect(encoded).toBe(expected);\n    const decoded = decodeBase64(encoded);\n    expect(decoded).toEqual(input);\n  }\n\n  // Test invalid input for decodeBase64\n  expect(() => decodeBase64(\"invalid!\")).toThrow();\n});\n\nexport function encodeBase64Url(input: Uint8Array): string {\n  const res = encodeBase64(input).replace(/=+$/, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n\n  // Skip sanity check for test cases\n  // This avoids circular dependency with isBase64Url function\n  return res;\n}\n\nexport function decodeBase64Url(input: string): Uint8Array {\n  if (!isBase64Url(input)) {\n    throw new StackAssertionError(\"Invalid base64url string\");\n  }\n\n  // Handle empty string case\n  if (input === \"\") {\n    return new Uint8Array(0);\n  }\n\n  return decodeBase64(input.replace(/-/g, \"+\").replace(/_/g, \"/\") + \"====\".slice((input.length - 1) % 4 + 1));\n}\nundefined?.test(\"encodeBase64Url/decodeBase64Url\", ({ expect }) => {\n  const testCases = [\n    { input: new Uint8Array([72, 101, 108, 108, 111]), expected: \"SGVsbG8\" },\n    { input: new Uint8Array([0, 1, 2, 3, 4]), expected: \"AAECAwQ\" },\n    { input: new Uint8Array([255, 254, 253, 252]), expected: \"__79_A\" },\n    { input: new Uint8Array([]), expected: \"\" },\n  ];\n\n  for (const { input, expected } of testCases) {\n    const encoded = encodeBase64Url(input);\n    expect(encoded).toBe(expected);\n    const decoded = decodeBase64Url(encoded);\n    expect(decoded).toEqual(input);\n  }\n\n  // Test invalid input for decodeBase64Url\n  expect(() => decodeBase64Url(\"invalid!\")).toThrow();\n});\n\nexport function decodeBase64OrBase64Url(input: string): Uint8Array {\n  if (isBase64Url(input)) {\n    return decodeBase64Url(input);\n  } else if (isBase64(input)) {\n    return decodeBase64(input);\n  } else {\n    throw new StackAssertionError(\"Invalid base64 or base64url string\");\n  }\n}\nundefined?.test(\"decodeBase64OrBase64Url\", ({ expect }) => {\n  // Test with base64 input\n  const base64Input = \"SGVsbG8gV29ybGQ=\";\n  const base64Expected = new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]);\n  expect(decodeBase64OrBase64Url(base64Input)).toEqual(base64Expected);\n\n  // Test with base64url input\n  const base64UrlInput = \"SGVsbG8gV29ybGQ\";\n  const base64UrlExpected = new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]);\n  expect(decodeBase64OrBase64Url(base64UrlInput)).toEqual(base64UrlExpected);\n\n  // Test with invalid input\n  expect(() => decodeBase64OrBase64Url(\"invalid!\")).toThrow();\n});\n\nexport function isBase32(input: string): boolean {\n  for (const char of input) {\n    if (char === \" \") continue;\n    const upperChar = char.toUpperCase();\n    // Check if the character is in the Crockford alphabet\n    if (!crockfordAlphabet.includes(upperChar)) {\n      return false;\n    }\n  }\n  return true;\n}\nundefined?.test(\"isBase32\", ({ expect }) => {\n  expect(isBase32(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\")).toBe(true);\n  expect(isBase32(\"0OIJ\")).toBe(false); // O and I are not allowed\n  expect(isBase32(\"ABC DEF\")).toBe(true); // Spaces are allowed\n  expect(isBase32(\"ABC!\")).toBe(false); // Special characters not allowed\n  expect(isBase32(\"\")).toBe(true);\n});\n\nexport function isBase64(input: string): boolean {\n  // This regex allows for standard base64 with proper padding\n  const regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\n  return regex.test(input);\n}\nundefined?.test(\"isBase64\", ({ expect }) => {\n  expect(isBase64(\"SGVsbG8gV29ybGQ=\")).toBe(true);\n  expect(isBase64(\"SGVsbG8gV29ybGQ\")).toBe(false); // No padding\n  expect(isBase64(\"SGVsbG8gV29ybGQ==\")).toBe(false); // Wrong padding\n  expect(isBase64(\"SGVsbG8!V29ybGQ=\")).toBe(false); // Invalid character\n  expect(isBase64(\"\")).toBe(true);\n});\n\nexport function isBase64Url(input: string): boolean {\n  if (input === \"\") {\n    return true;\n  }\n  const regex = /^[0-9a-zA-Z_-]+$/;\n  return regex.test(input);\n}\nundefined?.test(\"isBase64Url\", ({ expect }) => {\n  expect(isBase64Url(\"SGVsbG8gV2 9ybGQ\")).toBe(false); // Space is not valid\n  expect(isBase64Url(\"SGVsbG8_V29ybGQ\")).toBe(true); // _ is a valid character\n  expect(isBase64Url(\"SGVsbG8-V29ybGQ\")).toBe(true); // - is valid\n  expect(isBase64Url(\"SGVsbG8_V29ybGQ=\")).toBe(false); // = not allowed\n  expect(isBase64Url(\"\")).toBe(true); // Empty string is valid\n});\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2643, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/crypto.tsx"],"sourcesContent":["import { encodeBase32 } from \"./bytes\";\nimport { StackAssertionError } from \"./errors\";\nimport { globalVar } from \"./globals\";\n\nexport function generateRandomValues(array: Uint8Array): typeof array {\n  if (!globalVar.crypto) {\n    throw new StackAssertionError(\"Crypto API is not available in this environment. Are you using an old browser?\");\n  }\n  if (!globalVar.crypto.getRandomValues) {\n    throw new StackAssertionError(\"crypto.getRandomValues is not available in this environment. Are you using an old browser?\");\n  }\n  return globalVar.crypto.getRandomValues(array);\n}\n\n/**\n * Generates a secure alphanumeric string using the system's cryptographically secure\n * random number generator.\n */\nexport function generateSecureRandomString(minBitsOfEntropy: number = 224) {\n  const base32CharactersCount = Math.ceil(minBitsOfEntropy / 5);\n  const bytesCount = Math.ceil(base32CharactersCount * 5 / 8);\n  const randomBytes = generateRandomValues(new Uint8Array(bytesCount));\n  const str = encodeBase32(randomBytes);\n  return str.slice(str.length - base32CharactersCount).toLowerCase();\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,oBAAoB;AAC7B,SAAS,2BAA2B;AACpC,SAAS,iBAAiB;;;;AAEnB,SAAS,qBAAqB,KAAA,EAAiC;IACpE,IAAI,uLAAC,YAAA,CAAU,MAAA,EAAQ;QACrB,MAAM,yLAAI,sBAAA,CAAoB,gFAAgF;IAChH;IACA,IAAI,CAAC,kMAAA,CAAU,MAAA,CAAO,eAAA,EAAiB;QACrC,MAAM,yLAAI,sBAAA,CAAoB,4FAA4F;IAC5H;IACA,6LAAO,YAAA,CAAU,MAAA,CAAO,eAAA,CAAgB,KAAK;AAC/C;AAMO,SAAS;2BAA2B,iEAA2B,KAAK;IACzE,MAAM,wBAAwB,KAAK,IAAA,CAAK,mBAAmB,CAAC;IAC5D,MAAM,aAAa,KAAK,IAAA,CAAK,wBAAwB,IAAI,CAAC;IAC1D,MAAM,cAAc,qBAAqB,IAAI,WAAW,UAAU,CAAC;IACnE,MAAM,8LAAM,eAAA,EAAa,WAAW;IACpC,OAAO,IAAI,KAAA,CAAM,IAAI,MAAA,GAAS,qBAAqB,EAAE,WAAA,CAAY;AACnE","debugId":null}},
    {"offset": {"line": 2677, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/uuids.tsx"],"sourcesContent":["import { generateRandomValues } from \"./crypto\";\n\nexport function generateUuid() {\n  // crypto.randomUuid is not supported in all browsers, so this is a polyfill\n  return \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, c =>\n    (+c ^ generateRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)\n  );\n}\nundefined?.test(\"generateUuid\", ({ expect }) => {\n  // Test that the function returns a valid UUID\n  const uuid = generateUuid();\n  expect(uuid).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/);\n\n  // Test that multiple calls generate different UUIDs\n  const uuid2 = generateUuid();\n  expect(uuid).not.toBe(uuid2);\n\n  // Test that the UUID is version 4 (random)\n  expect(uuid.charAt(14)).toBe('4');\n\n  // Test that the UUID has the correct variant (8, 9, a, or b in position 19)\n  expect('89ab').toContain(uuid.charAt(19));\n});\n\nexport function isUuid(str: string) {\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(str);\n}\nundefined?.test(\"isUuid\", ({ expect }) => {\n  // Test with valid UUIDs\n  expect(isUuid(\"123e4567-e89b-42d3-a456-426614174000\")).toBe(true);\n  expect(isUuid(\"123e4567-e89b-42d3-8456-426614174000\")).toBe(true);\n  expect(isUuid(\"123e4567-e89b-42d3-9456-426614174000\")).toBe(true);\n  expect(isUuid(\"123e4567-e89b-42d3-a456-426614174000\")).toBe(true);\n  expect(isUuid(\"123e4567-e89b-42d3-b456-426614174000\")).toBe(true);\n\n  // Test with invalid UUIDs\n  expect(isUuid(\"\")).toBe(false);\n  expect(isUuid(\"not-a-uuid\")).toBe(false);\n  expect(isUuid(\"123e4567-e89b-12d3-a456-426614174000\")).toBe(false); // Wrong version (not 4)\n  expect(isUuid(\"123e4567-e89b-42d3-c456-426614174000\")).toBe(false); // Wrong variant (not 8, 9, a, or b)\n  expect(isUuid(\"123e4567-e89b-42d3-a456-42661417400\")).toBe(false); // Too short\n  expect(isUuid(\"123e4567-e89b-42d3-a456-4266141740000\")).toBe(false); // Too long\n  expect(isUuid(\"123e4567-e89b-42d3-a456_426614174000\")).toBe(false); // Wrong format (underscore instead of dash)\n\n  // Test with uppercase letters (should fail as UUID should be lowercase)\n  expect(isUuid(\"123E4567-E89B-42D3-A456-426614174000\")).toBe(false);\n});\n"],"names":[],"mappings":";;;;;AAAA,SAAS,4BAA4B;;AAE9B,SAAS,eAAe;IAE7B,OAAO,uCAAuC,OAAA,CAAQ,UAAU,CAAA,IAAA,CAC7D,CAAC,6LAAI,uBAAA,EAAqB,IAAI,WAAW,CAAC,CAAC,CAAA,CAAE,CAAC,CAAA,GAAI,MAAM,CAAC,IAAI,CAAA,EAAG,QAAA,CAAS,EAAE;AAEhF;AAiBO,SAAS,OAAO,GAAA,EAAa;IAClC,OAAO,wEAAwE,IAAA,CAAK,GAAG;AACzF","debugId":null}},
    {"offset": {"line": 2696, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/promises.tsx"],"sourcesContent":["import { KnownError } from \"..\";\nimport { StackAssertionError, captureError, concatStacktraces, errorToNiceString } from \"./errors\";\nimport { DependenciesMap } from \"./maps\";\nimport { Result } from \"./results\";\nimport { generateUuid } from \"./uuids\";\n\nexport type ReactPromise<T> = Promise<T> & (\n  | { status: \"rejected\", reason: unknown }\n  | { status: \"fulfilled\", value: T }\n  | { status: \"pending\" }\n);\n\ntype Resolve<T> = (value: T) => void;\ntype Reject = (reason: unknown) => void;\nexport function createPromise<T>(callback: (resolve: Resolve<T>, reject: Reject) => void): ReactPromise<T> {\n  let status = \"pending\" as \"fulfilled\" | \"rejected\" | \"pending\";\n  let valueOrReason: T | unknown | undefined = undefined;\n  let resolve: Resolve<T> | null = null;\n  let reject: Reject | null = null;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = (value) => {\n      if (status !== \"pending\") return;\n      status = \"fulfilled\";\n      valueOrReason = value;\n      res(value);\n    };\n    reject = (reason) => {\n      if (status !== \"pending\") return;\n      status = \"rejected\";\n      valueOrReason = reason;\n      rej(reason);\n    };\n  });\n\n  callback(resolve!, reject!);\n  return Object.assign(promise, {\n    status: status,\n    ...status === \"fulfilled\" ? { value: valueOrReason as T } : {},\n    ...status === \"rejected\" ? { reason: valueOrReason } : {},\n  } as any);\n}\nundefined?.test(\"createPromise\", async ({ expect }) => {\n  // Test resolved promise\n  const resolvedPromise = createPromise<number>((resolve) => {\n    resolve(42);\n  });\n  expect(resolvedPromise.status).toBe(\"fulfilled\");\n  expect((resolvedPromise as any).value).toBe(42);\n  expect(await resolvedPromise).toBe(42);\n\n  // Test rejected promise\n  const error = new Error(\"Test error\");\n  const rejectedPromise = createPromise<number>((_, reject) => {\n    reject(error);\n  });\n  expect(rejectedPromise.status).toBe(\"rejected\");\n  expect((rejectedPromise as any).reason).toBe(error);\n  await expect(rejectedPromise).rejects.toBe(error);\n\n  // Test pending promise\n  const pendingPromise = createPromise<number>(() => {\n    // Do nothing, leave it pending\n  });\n  expect(pendingPromise.status).toBe(\"pending\");\n  expect((pendingPromise as any).value).toBeUndefined();\n  expect((pendingPromise as any).reason).toBeUndefined();\n\n  // Test that resolving after already resolved does nothing\n  let resolveCount = 0;\n  const multiResolvePromise = createPromise<number>((resolve) => {\n    resolve(1);\n    resolveCount++;\n    resolve(2);\n    resolveCount++;\n  });\n  expect(resolveCount).toBe(2); // Both resolve calls executed\n  expect(multiResolvePromise.status).toBe(\"fulfilled\");\n  expect((multiResolvePromise as any).value).toBe(1); // Only first resolve took effect\n  expect(await multiResolvePromise).toBe(1);\n});\n\nlet resolvedCache: DependenciesMap<[unknown], ReactPromise<unknown>> | null = null;\n/**\n * Like Promise.resolve(...), but also adds the status and value properties for use with React's `use` hook, and caches\n * the value so that invoking `resolved` twice returns the same promise.\n */\nexport function resolved<T>(value: T): ReactPromise<T> {\n  resolvedCache ??= new DependenciesMap<[unknown], ReactPromise<unknown>>();\n  if (resolvedCache.has([value])) {\n    return resolvedCache.get([value]) as ReactPromise<T>;\n  }\n\n  const res = Object.assign(Promise.resolve(value), {\n    status: \"fulfilled\",\n    value,\n  } as const);\n  resolvedCache.set([value], res);\n  return res;\n}\nundefined?.test(\"resolved\", async ({ expect }) => {\n  // Test with primitive value\n  const promise1 = resolved(42);\n  expect(promise1.status).toBe(\"fulfilled\");\n  // Need to use type assertion since value is only available when status is \"fulfilled\"\n  expect((promise1 as { value: number }).value).toBe(42);\n  expect(await promise1).toBe(42);\n\n  // Test with object value\n  const obj = { test: true };\n  const promise2 = resolved(obj);\n  expect(promise2.status).toBe(\"fulfilled\");\n  expect((promise2 as { value: typeof obj }).value).toBe(obj);\n  expect(await promise2).toBe(obj);\n\n  // Test caching (same reference for same value)\n  const promise3 = resolved(42);\n  expect(promise3).toBe(promise1); // Same reference due to caching\n\n  // Test with different value (different reference)\n  const promise4 = resolved(43);\n  expect(promise4).not.toBe(promise1);\n});\n\nlet rejectedCache: DependenciesMap<[unknown], ReactPromise<unknown>> | null = null;\n/**\n * Like Promise.reject(...), but also adds the status and value properties for use with React's `use` hook, and caches\n * the value so that invoking `rejected` twice returns the same promise.\n */\nexport function rejected<T>(reason: unknown): ReactPromise<T> {\n  rejectedCache ??= new DependenciesMap<[unknown], ReactPromise<unknown>>();\n  if (rejectedCache.has([reason])) {\n    return rejectedCache.get([reason]) as ReactPromise<T>;\n  }\n\n  const promise = Promise.reject(reason);\n  ignoreUnhandledRejection(promise);\n  const res = Object.assign(promise, {\n    status: \"rejected\",\n    reason: reason,\n  } as const);\n  rejectedCache.set([reason], res);\n  return res;\n}\nundefined?.test(\"rejected\", ({ expect }) => {\n  // Test with error object\n  const error = new Error(\"Test error\");\n  const promise1 = rejected<number>(error);\n  expect(promise1.status).toBe(\"rejected\");\n  // Need to use type assertion since reason is only available when status is \"rejected\"\n  expect((promise1 as { reason: Error }).reason).toBe(error);\n\n  // Test with string reason\n  const promise2 = rejected<string>(\"error message\");\n  expect(promise2.status).toBe(\"rejected\");\n  expect((promise2 as { reason: string }).reason).toBe(\"error message\");\n\n  // Test caching (same reference for same reason)\n  const promise3 = rejected<number>(error);\n  expect(promise3).toBe(promise1); // Same reference due to caching\n\n  // Test with different reason (different reference)\n  const differentError = new Error(\"Different error\");\n  const promise4 = rejected<number>(differentError);\n  expect(promise4).not.toBe(promise1);\n\n  // Note: We're not using await expect(promise).rejects to avoid unhandled rejections\n});\n\n// We'll skip the rejection test for pending() since it's causing unhandled rejections\n// The function is already well tested through other tests like rejected() and createPromise()\n\n\nconst neverResolvePromise = pending(new Promise<never>(() => {}));\nexport function neverResolve(): ReactPromise<never> {\n  return neverResolvePromise;\n}\nundefined?.test(\"neverResolve\", ({ expect }) => {\n  const promise = neverResolve();\n  expect(promise.status).toBe(\"pending\");\n  expect((promise as any).value).toBeUndefined();\n  expect((promise as any).reason).toBeUndefined();\n\n  // Test that multiple calls return the same promise\n  const promise2 = neverResolve();\n  expect(promise2).toBe(promise);\n});\n\nexport function pending<T>(promise: Promise<T>, options: { disableErrorWrapping?: boolean } = {}): ReactPromise<T> {\n  const res = promise.then(\n    value => {\n      res.status = \"fulfilled\";\n      (res as any).value = value;\n      return value;\n    },\n    actualReason => {\n      res.status = \"rejected\";\n      (res as any).reason = actualReason;\n      throw actualReason;\n    },\n  ) as ReactPromise<T>;\n  res.status = \"pending\";\n  return res;\n}\nundefined?.test(\"pending\", async ({ expect }) => {\n  // Test with a promise that resolves\n  const resolvePromise = Promise.resolve(42);\n  const pendingPromise = pending(resolvePromise);\n\n  // Initially it should be pending\n  expect(pendingPromise.status).toBe(\"pending\");\n\n  // After resolution, it should be fulfilled\n  await resolvePromise;\n  // Need to wait a tick for the then handler to execute\n  await new Promise(resolve => setTimeout(resolve, 0));\n  expect(pendingPromise.status).toBe(\"fulfilled\");\n  expect((pendingPromise as { value: number }).value).toBe(42);\n\n  // For the rejection test, we'll use a separate test to avoid unhandled rejections\n});\n\n/**\n * Should be used to wrap Promises that are not immediately awaited, so they don't throw an unhandled promise rejection\n * error.\n *\n * Vercel kills serverless functions on unhandled promise rejection errors, so this is important.\n */\nexport function ignoreUnhandledRejection<T extends Promise<any>>(promise: T): void {\n  promise.catch(() => {});\n}\nundefined?.test(\"ignoreUnhandledRejection\", async ({ expect }) => {\n  // Test with a promise that resolves\n  const resolvePromise = Promise.resolve(42);\n  ignoreUnhandledRejection(resolvePromise);\n  expect(await resolvePromise).toBe(42); // Should still resolve to the same value\n\n  // Test with a promise that rejects\n  // The promise should still reject, but the rejection is caught internally\n  // so it doesn't cause an unhandled rejection error\n  const error = new Error(\"Test error\");\n  const rejectPromise = Promise.reject(error);\n  ignoreUnhandledRejection(rejectPromise);\n  await expect(rejectPromise).rejects.toBe(error);\n});\n\n/**\n * See concatStacktraces for more information.\n */\nexport function concatStacktracesIfRejected<T>(promise: Promise<T>): void {\n  const currentError = new Error();\n  promise.catch(error => {\n    if (error instanceof Error) {\n      concatStacktraces(error, currentError);\n    } else {\n      // we can only concatenate errors, so we'll just ignore the non-error\n    }\n  });\n}\n\nexport async function wait(ms: number) {\n  if (!Number.isFinite(ms) || ms < 0) {\n    throw new StackAssertionError(`wait() requires a non-negative integer number of milliseconds to wait. (found: ${ms}ms)`);\n  }\n  if (ms >= 2**31) {\n    throw new StackAssertionError(\"The maximum timeout for wait() is 2147483647ms (2**31 - 1). (found: ${ms}ms)\");\n  }\n  return await new Promise<void>(resolve => setTimeout(resolve, ms));\n}\nundefined?.test(\"wait\", async ({ expect }) => {\n  // Test with valid input\n  const start = Date.now();\n  await wait(10);\n  const elapsed = Date.now() - start;\n  expect(elapsed).toBeGreaterThanOrEqual(5); // Allow some flexibility in timing\n\n  // Test with zero\n  await expect(wait(0)).resolves.toBeUndefined();\n\n  // Test with negative number\n  await expect(wait(-10)).rejects.toThrow(\"wait() requires a non-negative integer\");\n\n  // Test with non-finite number\n  await expect(wait(NaN)).rejects.toThrow(\"wait() requires a non-negative integer\");\n  await expect(wait(Infinity)).rejects.toThrow(\"wait() requires a non-negative integer\");\n\n  // Test with too large number\n  await expect(wait(2**31)).rejects.toThrow(\"The maximum timeout for wait()\");\n});\n\nexport async function waitUntil(date: Date) {\n  return await wait(date.getTime() - Date.now());\n}\nundefined?.test(\"waitUntil\", async ({ expect }) => {\n  // Test with future date\n  const futureDate = new Date(Date.now() + 10);\n  const start = Date.now();\n  await waitUntil(futureDate);\n  const elapsed = Date.now() - start;\n  expect(elapsed).toBeGreaterThanOrEqual(5); // Allow some flexibility in timing\n\n  // Test with past date - this will throw because wait() requires non-negative time\n  // We need to verify it throws the correct error\n  try {\n    await waitUntil(new Date(Date.now() - 1000));\n    expect.fail(\"Should have thrown an error\");\n  } catch (error) {\n    expect(error).toBeInstanceOf(StackAssertionError);\n    expect((error as Error).message).toContain(\"wait() requires a non-negative integer\");\n  }\n});\n\nexport function runAsynchronouslyWithAlert(...args: Parameters<typeof runAsynchronously>) {\n  return runAsynchronously(\n    args[0],\n    {\n      ...args[1],\n      onError: error => {\n        if (KnownError.isKnownError(error) && typeof process !== \"undefined\" && (process.env.NODE_ENV as any)?.includes(\"production\")) {\n          alert(error.message);\n        } else {\n          alert(`An unhandled error occurred. Please ${process.env.NODE_ENV === \"development\" ? `check the browser console for the full error.` : \"report this to the developer.\"}\\n\\n${error}`);\n        }\n        args[1]?.onError?.(error);\n      },\n    },\n    ...args.slice(2) as [],\n  );\n}\nundefined?.test(\"runAsynchronouslyWithAlert\", ({ expect }) => {\n  // Simple test to verify the function calls runAsynchronously\n  // We can't easily test the alert functionality without mocking\n  const testFn = () => Promise.resolve(\"test\");\n  const testOptions = { noErrorLogging: true };\n\n  // Just verify it doesn't throw\n  expect(() => runAsynchronouslyWithAlert(testFn, testOptions)).not.toThrow();\n\n  // We can't easily test the error handling without mocking, so we'll\n  // just verify the function exists and can be called\n  expect(typeof runAsynchronouslyWithAlert).toBe(\"function\");\n});\n\nexport function runAsynchronously(\n  promiseOrFunc: void | Promise<unknown> | (() => void | Promise<unknown>) | undefined,\n  options: {\n    noErrorLogging?: boolean,\n    onError?: (error: Error) => void,\n  } = {},\n): void {\n  if (typeof promiseOrFunc === \"function\") {\n    promiseOrFunc = promiseOrFunc();\n  }\n  if (promiseOrFunc) {\n    concatStacktracesIfRejected(promiseOrFunc);\n    promiseOrFunc.catch(error => {\n      options.onError?.(error);\n      const newError = new StackAssertionError(\n        \"Uncaught error in asynchronous function: \" + errorToNiceString(error),\n        { cause: error },\n      );\n      if (!options.noErrorLogging) {\n        captureError(\"runAsynchronously\", newError);\n      }\n    });\n  }\n}\nundefined?.test(\"runAsynchronously\", ({ expect }) => {\n  // Simple test to verify the function exists and can be called\n  const testFn = () => Promise.resolve(\"test\");\n\n  // Just verify it doesn't throw\n  expect(() => runAsynchronously(testFn)).not.toThrow();\n  expect(() => runAsynchronously(Promise.resolve(\"test\"))).not.toThrow();\n  expect(() => runAsynchronously(undefined)).not.toThrow();\n\n  // We can't easily test the error handling without mocking, so we'll\n  // just verify the function exists and can be called with options\n  expect(() => runAsynchronously(testFn, { noErrorLogging: true })).not.toThrow();\n  expect(() => runAsynchronously(testFn, { onError: () => {} })).not.toThrow();\n});\n\n\nclass TimeoutError extends Error {\n  constructor(public readonly ms: number) {\n    super(`Timeout after ${ms}ms`);\n    this.name = \"TimeoutError\";\n  }\n}\n\nexport async function timeout<T>(promise: Promise<T>, ms: number): Promise<Result<T, TimeoutError>> {\n  return await Promise.race([\n    promise.then(value => Result.ok(value)),\n    wait(ms).then(() => Result.error(new TimeoutError(ms))),\n  ]);\n}\nundefined?.test(\"timeout\", async ({ expect }) => {\n  // Test with a promise that resolves quickly\n  const fastPromise = Promise.resolve(42);\n  const fastResult = await timeout(fastPromise, 100);\n  expect(fastResult.status).toBe(\"ok\");\n  if (fastResult.status === \"ok\") {\n    expect(fastResult.data).toBe(42);\n  }\n\n  // Test with a promise that takes longer than the timeout\n  const slowPromise = new Promise(resolve => setTimeout(() => resolve(\"too late\"), 50));\n  const slowResult = await timeout(slowPromise, 10);\n  expect(slowResult.status).toBe(\"error\");\n  if (slowResult.status === \"error\") {\n    expect(slowResult.error).toBeInstanceOf(TimeoutError);\n    expect((slowResult.error as TimeoutError).ms).toBe(10);\n  }\n});\n\nexport async function timeoutThrow<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Result.orThrow(await timeout(promise, ms));\n}\nundefined?.test(\"timeoutThrow\", async ({ expect }) => {\n  // Test with a promise that resolves quickly\n  const fastPromise = Promise.resolve(42);\n  const fastResult = await timeoutThrow(fastPromise, 100);\n  expect(fastResult).toBe(42);\n\n  // Test with a promise that takes longer than the timeout\n  const slowPromise = new Promise(resolve => setTimeout(() => resolve(\"too late\"), 50));\n  await expect(timeoutThrow(slowPromise, 10)).rejects.toThrow(\"Timeout after 10ms\");\n  await expect(timeoutThrow(slowPromise, 10)).rejects.toBeInstanceOf(TimeoutError);\n});\n\n\nexport type RateLimitOptions = {\n  /**\n   * The number of requests to process in parallel. Currently only 1 is supported.\n   */\n  concurrency: 1,\n\n  /**\n   * If true, multiple requests waiting at the same time will be reduced to just one. Default is false.\n   */\n  batchCalls?: boolean,\n\n  /**\n   * Waits for throttleMs since the start of last request before starting the next request. Default is 0.\n   */\n  throttleMs?: number,\n\n  /**\n   * Waits for gapMs since the end of last request before starting the next request. Default is 0.\n   */\n  gapMs?: number,\n\n  /**\n   * Waits until there have been no new requests for debounceMs before starting a new request. Default is 0.\n   */\n  debounceMs?: number,\n};\n\nexport function rateLimited<T>(\n  func: () => Promise<T>,\n  options: RateLimitOptions,\n): () => Promise<T> {\n  let waitUntil = performance.now();\n  let queue: [(t: T) => void, (e: unknown) => void][] = [];\n  let addedToQueueCallbacks = new Map<string, () => void>;\n\n  const next = async () => {\n    while (true) {\n      if (waitUntil > performance.now()) {\n        await wait(Math.max(1, waitUntil - performance.now() + 1));\n      } else if (queue.length === 0) {\n        const uuid = generateUuid();\n        await new Promise<void>(resolve => {\n          addedToQueueCallbacks.set(uuid, resolve);\n        });\n        addedToQueueCallbacks.delete(uuid);\n      } else {\n        break;\n      }\n    }\n    const nextFuncs = options.batchCalls ? queue.splice(0, queue.length) : [queue.shift()!];\n\n    const start = performance.now();\n    const value = await Result.fromPromise(func());\n    const end = performance.now();\n\n    waitUntil = Math.max(\n      waitUntil,\n      start + (options.throttleMs ?? 0),\n      end + (options.gapMs ?? 0),\n    );\n\n    for (const nextFunc of nextFuncs) {\n      if (value.status === \"ok\") {\n        nextFunc[0](value.data);\n      } else {\n        nextFunc[1](value.error);\n      }\n    }\n  };\n\n  runAsynchronously(async () => {\n    while (true) {\n      await next();\n    }\n  });\n\n  return () => {\n    return new Promise<T>((resolve, reject) => {\n      waitUntil = Math.max(\n        waitUntil,\n        performance.now() + (options.debounceMs ?? 0),\n      );\n      queue.push([resolve, reject]);\n      addedToQueueCallbacks.forEach(cb => cb());\n    });\n  };\n}\n\nexport function throttled<T, A extends any[]>(func: (...args: A) => Promise<T>, delayMs: number): (...args: A) => Promise<T> {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let nextAvailable: Promise<T> | null = null;\n  return async (...args) => {\n    while (nextAvailable !== null) {\n      await nextAvailable;\n    }\n    nextAvailable = new Promise<T>(resolve => {\n      timeout = setTimeout(() => {\n        nextAvailable = null;\n        resolve(func(...args));\n      }, delayMs);\n    });\n    return await nextAvailable;\n  };\n}\n"],"names":["waitUntil","timeout"],"mappings":"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","debugId":null}},
    {"offset": {"line": 2965, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/results.tsx"],"sourcesContent":["import { wait } from \"./promises\";\nimport { deindent, nicify } from \"./strings\";\n\nexport type Result<T, E = unknown> =\n  | {\n    status: \"ok\",\n    data: T,\n  }\n  | {\n    status: \"error\",\n    error: E,\n  };\n\nexport type AsyncResult<T, E = unknown, P = void> =\n  | Result<T, E>\n  | (\n    & {\n      status: \"pending\",\n    }\n    & {\n      progress: P,\n    }\n  );\n\n\nexport const Result = {\n  fromThrowing,\n  fromThrowingAsync,\n  fromPromise: promiseToResult,\n  ok<T>(data: T): Result<T, never> & { status: \"ok\" } {\n    return {\n      status: \"ok\",\n      data,\n    };\n  },\n  error<E>(error: E): Result<never, E> & { status: \"error\" } {\n    return {\n      status: \"error\",\n      error,\n    };\n  },\n  map: mapResult,\n  or: <T, E, U>(result: Result<T, E>, fallback: U): T | U => {\n    return result.status === \"ok\" ? result.data : fallback;\n  },\n  orThrow: <T, E>(result: Result<T, E>): T => {\n    if (result.status === \"error\") {\n      throw result.error;\n    }\n    return result.data;\n  },\n  orThrowAsync: async <T, E>(result: Promise<Result<T, E>>): Promise<T> => {\n    return Result.orThrow(await result);\n  },\n  retry,\n};\nundefined?.test(\"Result.ok and Result.error\", ({ expect }) => {\n  // Test Result.ok\n  const okResult = Result.ok(42);\n  expect(okResult.status).toBe(\"ok\");\n  expect(okResult.data).toBe(42);\n\n  // Test Result.error\n  const error = new Error(\"Test error\");\n  const errorResult = Result.error(error);\n  expect(errorResult.status).toBe(\"error\");\n  expect(errorResult.error).toBe(error);\n});\n\nundefined?.test(\"Result.or\", ({ expect }) => {\n  // Test with ok result\n  const okResult: Result<number, string> = { status: \"ok\", data: 42 };\n  expect(Result.or(okResult, 0)).toBe(42);\n\n  // Test with error result\n  const errorResult: Result<number, string> = { status: \"error\", error: \"error message\" };\n  expect(Result.or(errorResult, 0)).toBe(0);\n});\n\nundefined?.test(\"Result.orThrow\", ({ expect }) => {\n  // Test with ok result\n  const okResult: Result<number, Error> = { status: \"ok\", data: 42 };\n  expect(Result.orThrow(okResult)).toBe(42);\n\n  // Test with error result\n  const error = new Error(\"Test error\");\n  const errorResult: Result<number, Error> = { status: \"error\", error };\n  expect(() => Result.orThrow(errorResult)).toThrow(error);\n});\n\nundefined?.test(\"Result.orThrowAsync\", async ({ expect }) => {\n  // Test with ok result\n  const okPromise = Promise.resolve({ status: \"ok\", data: 42 } as Result<number, Error>);\n  expect(await Result.orThrowAsync(okPromise)).toBe(42);\n\n  // Test with error result\n  const error = new Error(\"Test error\");\n  const errorPromise = Promise.resolve({ status: \"error\", error } as Result<number, Error>);\n  await expect(Result.orThrowAsync(errorPromise)).rejects.toThrow(error);\n});\n\nexport const AsyncResult = {\n  fromThrowing,\n  fromPromise: promiseToResult,\n  ok: Result.ok,\n  error: Result.error,\n  pending,\n  map: mapResult,\n  or: <T, E, P, U>(result: AsyncResult<T, E, P>, fallback: U): T | U => {\n    if (result.status === \"pending\") {\n      return fallback;\n    }\n    return Result.or(result, fallback);\n  },\n  orThrow: <T, E, P>(result: AsyncResult<T, E, P>): T => {\n    if (result.status === \"pending\") {\n      throw new Error(\"Result still pending\");\n    }\n    return Result.orThrow(result);\n  },\n  retry,\n};\nundefined?.test(\"AsyncResult.or\", ({ expect }) => {\n  // Test with ok result\n  const okResult: AsyncResult<number, string> = { status: \"ok\", data: 42 };\n  expect(AsyncResult.or(okResult, 0)).toBe(42);\n\n  // Test with error result\n  const errorResult: AsyncResult<number, string> = { status: \"error\", error: \"error message\" };\n  expect(AsyncResult.or(errorResult, 0)).toBe(0);\n\n  // Test with pending result\n  const pendingResult: AsyncResult<number, string> = { status: \"pending\", progress: undefined };\n  expect(AsyncResult.or(pendingResult, 0)).toBe(0);\n});\n\nundefined?.test(\"AsyncResult.orThrow\", ({ expect }) => {\n  // Test with ok result\n  const okResult: AsyncResult<number, Error> = { status: \"ok\", data: 42 };\n  expect(AsyncResult.orThrow(okResult)).toBe(42);\n\n  // Test with error result\n  const error = new Error(\"Test error\");\n  const errorResult: AsyncResult<number, Error> = { status: \"error\", error };\n  expect(() => AsyncResult.orThrow(errorResult)).toThrow(error);\n\n  // Test with pending result\n  const pendingResult: AsyncResult<number, Error> = { status: \"pending\", progress: undefined };\n  expect(() => AsyncResult.orThrow(pendingResult)).toThrow(\"Result still pending\");\n});\n\nfunction pending(): AsyncResult<never, never, void> & { status: \"pending\" };\nfunction pending<P>(progress: P): AsyncResult<never, never, P> & { status: \"pending\" };\nfunction pending<P>(progress?: P): AsyncResult<never, never, P> & { status: \"pending\" } {\n  return {\n    status: \"pending\",\n    progress: progress!,\n  };\n}\nundefined?.test(\"pending\", ({ expect }) => {\n  // Test without progress\n  const pendingResult = pending();\n  expect(pendingResult.status).toBe(\"pending\");\n  expect(pendingResult.progress).toBe(undefined);\n\n  // Test with progress\n  const progressValue = { loaded: 50, total: 100 };\n  const pendingWithProgress = pending(progressValue);\n  expect(pendingWithProgress.status).toBe(\"pending\");\n  expect(pendingWithProgress.progress).toBe(progressValue);\n});\n\nasync function promiseToResult<T>(promise: Promise<T>): Promise<Result<T>> {\n  try {\n    const value = await promise;\n    return Result.ok(value);\n  } catch (error) {\n    return Result.error(error);\n  }\n}\nundefined?.test(\"promiseToResult\", async ({ expect }) => {\n  // Test with resolved promise\n  const resolvedPromise = Promise.resolve(42);\n  const resolvedResult = await promiseToResult(resolvedPromise);\n  expect(resolvedResult.status).toBe(\"ok\");\n  if (resolvedResult.status === \"ok\") {\n    expect(resolvedResult.data).toBe(42);\n  }\n\n  // Test with rejected promise\n  const error = new Error(\"Test error\");\n  const rejectedPromise = Promise.reject(error);\n  const rejectedResult = await promiseToResult(rejectedPromise);\n  expect(rejectedResult.status).toBe(\"error\");\n  if (rejectedResult.status === \"error\") {\n    expect(rejectedResult.error).toBe(error);\n  }\n});\n\nfunction fromThrowing<T>(fn: () => T): Result<T, unknown> {\n  try {\n    return Result.ok(fn());\n  } catch (error) {\n    return Result.error(error);\n  }\n}\nundefined?.test(\"fromThrowing\", ({ expect }) => {\n  // Test with function that succeeds\n  const successFn = () => 42;\n  const successResult = fromThrowing(successFn);\n  expect(successResult.status).toBe(\"ok\");\n  if (successResult.status === \"ok\") {\n    expect(successResult.data).toBe(42);\n  }\n\n  // Test with function that throws\n  const error = new Error(\"Test error\");\n  const errorFn = () => {\n    throw error;\n  };\n  const errorResult = fromThrowing(errorFn);\n  expect(errorResult.status).toBe(\"error\");\n  if (errorResult.status === \"error\") {\n    expect(errorResult.error).toBe(error);\n  }\n});\n\nasync function fromThrowingAsync<T>(fn: () => Promise<T>): Promise<Result<T, unknown>> {\n  try {\n    return Result.ok(await fn());\n  } catch (error) {\n    return Result.error(error);\n  }\n}\nundefined?.test(\"fromThrowingAsync\", async ({ expect }) => {\n  // Test with async function that succeeds\n  const successFn = async () => 42;\n  const successResult = await fromThrowingAsync(successFn);\n  expect(successResult.status).toBe(\"ok\");\n  if (successResult.status === \"ok\") {\n    expect(successResult.data).toBe(42);\n  }\n\n  // Test with async function that throws\n  const error = new Error(\"Test error\");\n  const errorFn = async () => {\n    throw error;\n  };\n  const errorResult = await fromThrowingAsync(errorFn);\n  expect(errorResult.status).toBe(\"error\");\n  if (errorResult.status === \"error\") {\n    expect(errorResult.error).toBe(error);\n  }\n});\n\nfunction mapResult<T, U, E = unknown, P = unknown>(result: Result<T, E>, fn: (data: T) => U): Result<U, E>;\nfunction mapResult<T, U, E = unknown, P = unknown>(result: AsyncResult<T, E, P>, fn: (data: T) => U): AsyncResult<U, E, P>;\nfunction mapResult<T, U, E = unknown, P = unknown>(result: AsyncResult<T, E, P>, fn: (data: T) => U): AsyncResult<U, E, P> {\n  if (result.status === \"error\") return {\n    status: \"error\",\n    error: result.error,\n  };\n  if (result.status === \"pending\") return {\n    status: \"pending\",\n    ...\"progress\" in result ? { progress: result.progress } : {},\n  } as any;\n\n  return Result.ok(fn(result.data));\n}\nundefined?.test(\"mapResult\", ({ expect }) => {\n  // Test with ok result\n  const okResult: Result<number, string> = { status: \"ok\", data: 42 };\n  const mappedOk = mapResult(okResult, (n: number) => n * 2);\n  expect(mappedOk.status).toBe(\"ok\");\n  if (mappedOk.status === \"ok\") {\n    expect(mappedOk.data).toBe(84);\n  }\n\n  // Test with error result\n  const errorResult: Result<number, string> = { status: \"error\", error: \"error message\" };\n  const mappedError = mapResult(errorResult, (n: number) => n * 2);\n  expect(mappedError.status).toBe(\"error\");\n  if (mappedError.status === \"error\") {\n    expect(mappedError.error).toBe(\"error message\");\n  }\n\n  // Test with pending result (no progress)\n  const pendingResult: AsyncResult<number, string, void> = { status: \"pending\", progress: undefined };\n  const mappedPending = mapResult(pendingResult, (n: number) => n * 2);\n  expect(mappedPending.status).toBe(\"pending\");\n\n  // Test with pending result (with progress)\n  const progressValue = { loaded: 50, total: 100 };\n  const pendingWithProgress: AsyncResult<number, string, typeof progressValue> = {\n    status: \"pending\",\n    progress: progressValue\n  };\n  const mappedPendingWithProgress = mapResult(pendingWithProgress, (n: number) => n * 2);\n  expect(mappedPendingWithProgress.status).toBe(\"pending\");\n  if (mappedPendingWithProgress.status === \"pending\") {\n    expect(mappedPendingWithProgress.progress).toBe(progressValue);\n  }\n});\n\n\nclass RetryError extends AggregateError {\n  constructor(public readonly errors: unknown[]) {\n    const strings = errors.map(e => nicify(e));\n    const isAllSame = strings.length > 1 && strings.every(s => s === strings[0]);\n    super(\n      errors,\n      deindent`\n      Error after ${errors.length} attempts.\n      \n      ${isAllSame ? deindent`\n        Attempts 1-${errors.length}:\n          ${strings[0]}\n      ` : strings.map((s, i) => deindent`\n          Attempt ${i + 1}:\n            ${s}\n        `).join(\"\\n\\n\")}\n      `,\n      { cause: errors[errors.length - 1] }\n    );\n    this.name = \"RetryError\";\n  }\n\n  get attempts() {\n    return this.errors.length;\n  }\n}\nRetryError.prototype.name = \"RetryError\";\n\nundefined?.test(\"RetryError\", ({ expect }) => {\n  // Test with single error\n  const singleError = new Error(\"Single error\");\n  const retryErrorSingle = new RetryError([singleError]);\n  expect(retryErrorSingle.name).toBe(\"RetryError\");\n  expect(retryErrorSingle.errors).toEqual([singleError]);\n  expect(retryErrorSingle.attempts).toBe(1);\n  expect(retryErrorSingle.cause).toBe(singleError);\n  expect(retryErrorSingle.message).toContain(\"Error after 1 attempts\");\n\n  // Test with multiple different errors\n  const error1 = new Error(\"Error 1\");\n  const error2 = new Error(\"Error 2\");\n  const retryErrorMultiple = new RetryError([error1, error2]);\n  expect(retryErrorMultiple.name).toBe(\"RetryError\");\n  expect(retryErrorMultiple.errors).toEqual([error1, error2]);\n  expect(retryErrorMultiple.attempts).toBe(2);\n  expect(retryErrorMultiple.cause).toBe(error2);\n  expect(retryErrorMultiple.message).toContain(\"Error after 2 attempts\");\n  expect(retryErrorMultiple.message).toContain(\"Attempt 1\");\n  expect(retryErrorMultiple.message).toContain(\"Attempt 2\");\n\n  // Test with multiple identical errors\n  const sameError = new Error(\"Same error\");\n  const retryErrorSame = new RetryError([sameError, sameError]);\n  expect(retryErrorSame.name).toBe(\"RetryError\");\n  expect(retryErrorSame.errors).toEqual([sameError, sameError]);\n  expect(retryErrorSame.attempts).toBe(2);\n  expect(retryErrorSame.cause).toBe(sameError);\n  expect(retryErrorSame.message).toContain(\"Error after 2 attempts\");\n  expect(retryErrorSame.message).toContain(\"Attempts 1-2\");\n});\n\nasync function retry<T>(\n  fn: (attemptIndex: number) => Result<T> | Promise<Result<T>>,\n  totalAttempts: number,\n  { exponentialDelayBase = 1000 } = {},\n): Promise<Result<T, RetryError> & { attempts: number }> {\n  const errors: unknown[] = [];\n  for (let i = 0; i < totalAttempts; i++) {\n    const res = await fn(i);\n    if (res.status === \"ok\") {\n      return Object.assign(Result.ok(res.data), { attempts: i + 1 });\n    } else {\n      errors.push(res.error);\n      if (i < totalAttempts - 1) {\n        await wait((Math.random() + 0.5) * exponentialDelayBase * (2 ** i));\n      }\n    }\n  }\n  return Object.assign(Result.error(new RetryError(errors)), { attempts: totalAttempts });\n}\nundefined?.test(\"retry\", async ({ expect }) => {\n  // Test successful on first attempt\n  const successFn = async () => Result.ok(\"success\");\n  const successResult = await retry(successFn, 3, { exponentialDelayBase: 0 });\n    expect(successResult).toEqual({ status: \"ok\", data: \"success\", attempts: 1 });\n\n    // Test successful after failures\n    let attemptCount = 0;\n    const eventualSuccessFn = async () => {\n      return ++attemptCount < 2 ? Result.error(new Error(`Attempt ${attemptCount} failed`))\n        : Result.ok(\"eventual success\");\n    };\n    const eventualSuccessResult = await retry(eventualSuccessFn, 3, { exponentialDelayBase: 0 });\n    expect(eventualSuccessResult).toEqual({ status: \"ok\", data: \"eventual success\", attempts: 2 });\n\n    // Test all attempts fail\n    const errors = [new Error(\"Error 1\"), new Error(\"Error 2\"), new Error(\"Error 3\")];\n    const allFailFn = async (attempt: number) => {\n      return Result.error(errors[attempt]);\n    };\n    const allFailResult = await retry(allFailFn, 3, { exponentialDelayBase: 0 });\n    expect(allFailResult).toEqual({ status: \"error\", error: expect.any(RetryError), attempts: 3 });\n    const retryError = (allFailResult as any).error as RetryError;\n    expect(retryError.errors).toEqual(errors);\n    expect(retryError.attempts).toBe(3);\n});\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3143, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/urls.tsx"],"sourcesContent":["import { generateSecureRandomString } from \"./crypto\";\nimport { templateIdentity } from \"./strings\";\n\nexport function createUrlIfValid(...args: ConstructorParameters<typeof URL>) {\n  try {\n    return new URL(...args);\n  } catch (e) {\n    return null;\n  }\n}\nundefined?.test(\"createUrlIfValid\", ({ expect }) => {\n  // Test with valid URLs\n  expect(createUrlIfValid(\"https://example.com\")).toBeInstanceOf(URL);\n  expect(createUrlIfValid(\"https://example.com/path?query=value#hash\")).toBeInstanceOf(URL);\n  expect(createUrlIfValid(\"/path\", \"https://example.com\")).toBeInstanceOf(URL);\n\n  // Test with invalid URLs\n  expect(createUrlIfValid(\"\")).toBeNull();\n  expect(createUrlIfValid(\"not a url\")).toBeNull();\n  expect(createUrlIfValid(\"http://\")).toBeNull();\n});\n\nexport function isValidUrl(url: string) {\n  return !!createUrlIfValid(url);\n}\nundefined?.test(\"isValidUrl\", ({ expect }) => {\n  // Test with valid URLs\n  expect(isValidUrl(\"https://example.com\")).toBe(true);\n  expect(isValidUrl(\"http://localhost:3000\")).toBe(true);\n  expect(isValidUrl(\"ftp://example.com\")).toBe(true);\n\n  // Test with invalid URLs\n  expect(isValidUrl(\"\")).toBe(false);\n  expect(isValidUrl(\"not a url\")).toBe(false);\n  expect(isValidUrl(\"http://\")).toBe(false);\n});\n\nexport function isValidHostname(hostname: string) {\n  const url = createUrlIfValid(`https://${hostname}`);\n  if (!url) return false;\n  return url.hostname === hostname;\n}\nundefined?.test(\"isValidHostname\", ({ expect }) => {\n  // Test with valid hostnames\n  expect(isValidHostname(\"example.com\")).toBe(true);\n  expect(isValidHostname(\"localhost\")).toBe(true);\n  expect(isValidHostname(\"sub.domain.example.com\")).toBe(true);\n  expect(isValidHostname(\"127.0.0.1\")).toBe(true);\n\n  // Test with invalid hostnames\n  expect(isValidHostname(\"\")).toBe(false);\n  expect(isValidHostname(\"example.com/path\")).toBe(false);\n  expect(isValidHostname(\"https://example.com\")).toBe(false);\n  expect(isValidHostname(\"example com\")).toBe(false);\n});\n\nexport function isLocalhost(urlOrString: string | URL) {\n  const url = createUrlIfValid(urlOrString);\n  if (!url) return false;\n  if (url.hostname === \"localhost\" || url.hostname.endsWith(\".localhost\")) return true;\n  if (url.hostname.match(/^127\\.\\d+\\.\\d+\\.\\d+$/)) return true;\n  return false;\n}\nundefined?.test(\"isLocalhost\", ({ expect }) => {\n  // Test with localhost URLs\n  expect(isLocalhost(\"http://localhost\")).toBe(true);\n  expect(isLocalhost(\"https://localhost:8080\")).toBe(true);\n  expect(isLocalhost(\"http://sub.localhost\")).toBe(true);\n  expect(isLocalhost(\"http://127.0.0.1\")).toBe(true);\n  expect(isLocalhost(\"http://127.1.2.3\")).toBe(true);\n\n  // Test with non-localhost URLs\n  expect(isLocalhost(\"https://example.com\")).toBe(false);\n  expect(isLocalhost(\"http://192.168.1.1\")).toBe(false);\n  expect(isLocalhost(\"http://10.0.0.1\")).toBe(false);\n\n  // Test with URL objects\n  expect(isLocalhost(new URL(\"http://localhost\"))).toBe(true);\n  expect(isLocalhost(new URL(\"https://example.com\"))).toBe(false);\n\n  // Test with invalid URLs\n  expect(isLocalhost(\"not a url\")).toBe(false);\n  expect(isLocalhost(\"\")).toBe(false);\n});\n\nexport function isRelative(url: string) {\n  const randomDomain = `${generateSecureRandomString()}.stack-auth.example.com`;\n  const u = createUrlIfValid(url, `https://${randomDomain}`);\n  if (!u) return false;\n  if (u.host !== randomDomain) return false;\n  if (u.protocol !== \"https:\") return false;\n  return true;\n}\nundefined?.test(\"isRelative\", ({ expect }) => {\n  // We can't easily mock generateSecureRandomString in this context\n  // but we can still test the function's behavior\n\n  // Test with relative URLs\n  expect(isRelative(\"/\")).toBe(true);\n  expect(isRelative(\"/path\")).toBe(true);\n  expect(isRelative(\"/path?query=value#hash\")).toBe(true);\n\n  // Test with absolute URLs\n  expect(isRelative(\"https://example.com\")).toBe(false);\n  expect(isRelative(\"http://example.com\")).toBe(false);\n  expect(isRelative(\"//example.com\")).toBe(false);\n\n  // Note: The implementation treats empty strings and invalid URLs as relative\n  // This is because they can be resolved against a base URL\n  expect(isRelative(\"\")).toBe(true);\n  expect(isRelative(\"not a url\")).toBe(true);\n});\n\nexport function getRelativePart(url: URL) {\n  return url.pathname + url.search + url.hash;\n}\nundefined?.test(\"getRelativePart\", ({ expect }) => {\n  // Test with various URLs\n  expect(getRelativePart(new URL(\"https://example.com\"))).toBe(\"/\");\n  expect(getRelativePart(new URL(\"https://example.com/path\"))).toBe(\"/path\");\n  expect(getRelativePart(new URL(\"https://example.com/path?query=value\"))).toBe(\"/path?query=value\");\n  expect(getRelativePart(new URL(\"https://example.com/path#hash\"))).toBe(\"/path#hash\");\n  expect(getRelativePart(new URL(\"https://example.com/path?query=value#hash\"))).toBe(\"/path?query=value#hash\");\n\n  // Test with different domains but same paths\n  const url1 = new URL(\"https://example.com/path?query=value#hash\");\n  const url2 = new URL(\"https://different.com/path?query=value#hash\");\n  expect(getRelativePart(url1)).toBe(getRelativePart(url2));\n});\n\n/**\n * A template literal tag that returns a URL.\n *\n * Any values passed are encoded.\n */\nexport function url(strings: TemplateStringsArray | readonly string[], ...values: (string|number|boolean)[]): URL {\n  return new URL(urlString(strings, ...values));\n}\nundefined?.test(\"url\", ({ expect }) => {\n  // Test with no interpolation\n  expect(url`https://example.com`).toBeInstanceOf(URL);\n  expect(url`https://example.com`.href).toBe(\"https://example.com/\");\n\n  // Test with string interpolation\n  expect(url`https://example.com/${\"path\"}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${\"path\"}`.pathname).toBe(\"/path\");\n\n  // Test with number interpolation\n  expect(url`https://example.com/${42}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${42}`.pathname).toBe(\"/42\");\n\n  // Test with boolean interpolation\n  expect(url`https://example.com/${true}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${true}`.pathname).toBe(\"/true\");\n\n  // Test with special characters in interpolation\n  expect(url`https://example.com/${\"path with spaces\"}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${\"path with spaces\"}`.pathname).toBe(\"/path%20with%20spaces\");\n\n  // Test with multiple interpolations\n  expect(url`https://example.com/${\"path\"}?query=${\"value\"}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${\"path\"}?query=${\"value\"}`.pathname).toBe(\"/path\");\n  expect(url`https://example.com/${\"path\"}?query=${\"value\"}`.search).toBe(\"?query=value\");\n});\n\n\n/**\n * A template literal tag that returns a URL string.\n *\n * Any values passed are encoded.\n */\nexport function urlString(strings: TemplateStringsArray | readonly string[], ...values: (string|number|boolean)[]): string {\n  return templateIdentity(strings, ...values.map(encodeURIComponent));\n}\nundefined?.test(\"urlString\", ({ expect }) => {\n  // Test with no interpolation\n  expect(urlString`https://example.com`).toBe(\"https://example.com\");\n\n  // Test with string interpolation\n  expect(urlString`https://example.com/${\"path\"}`).toBe(\"https://example.com/path\");\n\n  // Test with number interpolation\n  expect(urlString`https://example.com/${42}`).toBe(\"https://example.com/42\");\n\n  // Test with boolean interpolation\n  expect(urlString`https://example.com/${true}`).toBe(\"https://example.com/true\");\n\n  // Test with special characters in interpolation\n  expect(urlString`https://example.com/${\"path with spaces\"}`).toBe(\"https://example.com/path%20with%20spaces\");\n  expect(urlString`https://example.com/${\"?&=\"}`).toBe(\"https://example.com/%3F%26%3D\");\n\n  // Test with multiple interpolations\n  expect(urlString`https://example.com/${\"path\"}?query=${\"value\"}`).toBe(\"https://example.com/path?query=value\");\n  expect(urlString`https://example.com/${\"path\"}?query=${\"value with spaces\"}`).toBe(\"https://example.com/path?query=value%20with%20spaces\");\n});\n\n\n"],"names":["url"],"mappings":";;;;;;;;;;;AAAA,SAAS,kCAAkC;AAC3C,SAAS,wBAAwB;;;AAE1B,SAAS;IAAA,IAAA,IAAA,OAAA,UAAA,QAAA,OAAA,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;QAAoB,KAApB,QAAA,SAAA,CAAA,KAAoB,EAAyC;;IAC3E,IAAI;QACF,OAAO,IAAI,IAAI,GAAG,IAAI;IACxB,EAAA,OAAS,GAAG;QACV,OAAO;IACT;AACF;AAaO,SAAS,WAAWA,IAAAA,EAAa;IACtC,OAAO,CAAC,CAAC,iBAAiBA,IAAG;AAC/B;AAaO,SAAS,gBAAgB,QAAA,EAAkB;IAChD,MAAMA,OAAM,iBAAiB,WAAmB,CAAE,MAAV,QAAQ;IAChD,IAAI,CAACA,KAAK,CAAA,OAAO;IACjB,OAAOA,KAAI,QAAA,KAAa;AAC1B;AAeO,SAAS,YAAY,WAAA,EAA2B;IACrD,MAAMA,OAAM,iBAAiB,WAAW;IACxC,IAAI,CAACA,KAAK,CAAA,OAAO;IACjB,IAAIA,KAAI,QAAA,KAAa,eAAeA,KAAI,QAAA,CAAS,QAAA,CAAS,YAAY,EAAG,CAAA,OAAO;IAChF,IAAIA,KAAI,QAAA,CAAS,KAAA,CAAM,sBAAsB,EAAG,CAAA,OAAO;IACvD,OAAO;AACT;AAuBO,SAAS,WAAWA,IAAAA,EAAa;IACtC,MAAM,eAAe,GAA+B,gMAA5B,6BAAA,CAA2B,CAAC,GAAA;IACpD,MAAM,IAAI,iBAAiBA,MAAK,WAAuB,CAAE,MAAd,YAAY;IACvD,IAAI,CAAC,EAAG,CAAA,OAAO;IACf,IAAI,EAAE,IAAA,KAAS,aAAc,CAAA,OAAO;IACpC,IAAI,EAAE,QAAA,KAAa,SAAU,CAAA,OAAO;IACpC,OAAO;AACT;AAqBO,SAAS,gBAAgBA,IAAAA,EAAU;IACxC,OAAOA,KAAI,QAAA,GAAWA,KAAI,MAAA,GAASA,KAAI,IAAA;AACzC;AAoBO,SAAS,IAAI,OAAA;IAAA,IAAA,IAAA,OAAA,UAAA,QAAA,AAAsD,SAAtD,UAAA,OAAA,IAAA,OAAA,QAAA,OAAA,GAAA,OAAA,MAAA;eAAA,OAAA,KAAA,SAAA,CAAA,KAAsD,EAAwC;;IAChH,OAAO,IAAI,IAAI,UAAU,SAAS,GAAG,MAAM,CAAC;AAC9C;AAkCO,SAAS,UAAU,OAAA;IAAA,IAAA,IAAA,OAAA,UAAA,QAAA,AAAsD,SAAtD,UAAA,OAAA,IAAA,OAAA,QAAA,OAAA,GAAA,OAAA,MAAA;eAAA,OAAA,KAAA,SAAA,CAAA,KAAsD,EAA2C;;IACzH,iMAAO,mBAAA,EAAiB,SAAS,GAAG,OAAO,GAAA,CAAI,kBAAkB,CAAC;AACpE","debugId":null}},
    {"offset": {"line": 3212, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/locks.tsx"],"sourcesContent":["import { Semaphore } from 'async-mutex';\n\ntype LockCallback<T> = () => Promise<T>;\n\nexport class ReadWriteLock {\n  private semaphore: Semaphore;\n  private readers: number;\n  private readersMutex: Semaphore;\n\n  constructor() {\n    this.semaphore = new Semaphore(1); // Semaphore with 1 permit\n    this.readers = 0; // Track the number of readers\n    this.readersMutex = new Semaphore(1); // Protect access to `readers` count\n  }\n\n  async withReadLock<T>(callback: LockCallback<T>): Promise<T> {\n    await this._acquireReadLock();\n    try {\n      return await callback();\n    } finally {\n      await this._releaseReadLock();\n    }\n  }\n\n  async withWriteLock<T>(callback: LockCallback<T>): Promise<T> {\n    await this._acquireWriteLock();\n    try {\n      return await callback();\n    } finally {\n      await this._releaseWriteLock();\n    }\n  }\n\n  private async _acquireReadLock(): Promise<void> {\n    // Increment the readers count\n    await this.readersMutex.acquire();\n    try {\n      this.readers += 1;\n      // If this is the first reader, block writers\n      if (this.readers === 1) {\n        await this.semaphore.acquire();\n      }\n    } finally {\n      this.readersMutex.release();\n    }\n  }\n\n  private async _releaseReadLock(): Promise<void> {\n    // Decrement the readers count\n    await this.readersMutex.acquire();\n    try {\n      this.readers -= 1;\n      // If this was the last reader, release the writer block\n      if (this.readers === 0) {\n        this.semaphore.release();\n      }\n    } finally {\n      this.readersMutex.release();\n    }\n  }\n\n  private async _acquireWriteLock(): Promise<void> {\n    // Writers acquire the main semaphore exclusively\n    await this.semaphore.acquire();\n  }\n\n  private async _releaseWriteLock(): Promise<void> {\n    // Writers release the main semaphore\n    this.semaphore.release();\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAiB;;AAInB,IAAM,gBAAN,MAAoB;IAWzB,MAAM,aAAgB,QAAA,EAAuC;QAC3D,MAAM,IAAA,CAAK,gBAAA,CAAiB;QAC5B,IAAI;YACF,OAAO,MAAM,SAAS;QACxB,SAAE;YACA,MAAM,IAAA,CAAK,gBAAA,CAAiB;QAC9B;IACF;IAEA,MAAM,cAAiB,QAAA,EAAuC;QAC5D,MAAM,IAAA,CAAK,iBAAA,CAAkB;QAC7B,IAAI;YACF,OAAO,MAAM,SAAS;QACxB,SAAE;YACA,MAAM,IAAA,CAAK,iBAAA,CAAkB;QAC/B;IACF;IAEA,MAAc,mBAAkC;QAE9C,MAAM,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ;QAChC,IAAI;YACF,IAAA,CAAK,OAAA,IAAW;YAEhB,IAAI,IAAA,CAAK,OAAA,KAAY,GAAG;gBACtB,MAAM,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ;YAC/B;QACF,SAAE;YACA,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ;QAC5B;IACF;IAEA,MAAc,mBAAkC;QAE9C,MAAM,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ;QAChC,IAAI;YACF,IAAA,CAAK,OAAA,IAAW;YAEhB,IAAI,IAAA,CAAK,OAAA,KAAY,GAAG;gBACtB,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ;YACzB;QACF,SAAE;YACA,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ;QAC5B;IACF;IAEA,MAAc,oBAAmC;QAE/C,MAAM,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ;IAC/B;IAEA,MAAc,oBAAmC;QAE/C,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ;IACzB;IA5DA,aAAc;QACZ,IAAA,CAAK,SAAA,GAAY,gJAAI,YAAA,CAAU,CAAC;QAChC,IAAA,CAAK,OAAA,GAAU;QACf,IAAA,CAAK,YAAA,GAAe,gJAAI,YAAA,CAAU,CAAC;IACrC;AAyDF","debugId":null}},
    {"offset": {"line": 3275, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/stores.tsx"],"sourcesContent":["import { ReadWriteLock } from \"./locks\";\nimport { ReactPromise, pending, rejected, resolved } from \"./promises\";\nimport { AsyncResult, Result } from \"./results\";\nimport { generateUuid } from \"./uuids\";\n\nexport type ReadonlyStore<T> = {\n  get(): T,\n  onChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void },\n  onceChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void },\n};\n\nexport type AsyncStoreStateChangeCallback<T> = (args: { state: AsyncResult<T>, oldState: AsyncResult<T>, lastOkValue: T | undefined }) => void;\n\nexport type ReadonlyAsyncStore<T> = {\n  isAvailable(): boolean,\n  get(): AsyncResult<T, unknown, void>,\n  getOrWait(): ReactPromise<T>,\n  onChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void },\n  onceChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void },\n  onStateChange(callback: AsyncStoreStateChangeCallback<T>): { unsubscribe: () => void },\n  onceStateChange(callback: AsyncStoreStateChangeCallback<T>): { unsubscribe: () => void },\n};\n\nexport class Store<T> implements ReadonlyStore<T> {\n  private readonly _callbacks: Map<string, ((value: T, oldValue: T | undefined) => void)> = new Map();\n\n  constructor(\n    private _value: T\n  ) {}\n\n  get(): T {\n    return this._value;\n  }\n\n  set(value: T): void {\n    const oldValue = this._value;\n    this._value = value;\n    this._callbacks.forEach((callback) => callback(value, oldValue));\n  }\n\n  update(updater: (value: T) => T): T {\n    const value = updater(this._value);\n    this.set(value);\n    return value;\n  }\n\n  onChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    const uuid = generateUuid();\n    this._callbacks.set(uuid, callback);\n    return {\n      unsubscribe: () => {\n        this._callbacks.delete(uuid);\n      },\n    };\n  }\n\n  onceChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    const { unsubscribe } = this.onChange((...args) => {\n      unsubscribe();\n      callback(...args);\n    });\n    return { unsubscribe };\n  }\n}\n\nexport const storeLock = new ReadWriteLock();\n\n\nexport class AsyncStore<T> implements ReadonlyAsyncStore<T> {\n  private _isAvailable: boolean;\n  private _mostRecentOkValue: T | undefined = undefined;\n\n  private _isRejected = false;\n  private _rejectionError: unknown;\n  private readonly _waitingRejectFunctions = new Map<string, ((error: unknown) => void)>();\n\n  private readonly _callbacks: Map<string, AsyncStoreStateChangeCallback<T>> = new Map();\n\n  private _updateCounter = 0;\n  private _lastSuccessfulUpdate = -1;\n\n  constructor(...args: [] | [T]) {\n    if (args.length === 0) {\n      this._isAvailable = false;\n    } else {\n      this._isAvailable = true;\n      this._mostRecentOkValue = args[0];\n    }\n  }\n\n  isAvailable(): boolean {\n    return this._isAvailable;\n  }\n\n  isRejected(): boolean {\n    return this._isRejected;\n  }\n\n  get() {\n    if (this.isRejected()) {\n      return AsyncResult.error(this._rejectionError);\n    } else if (this.isAvailable()) {\n      return AsyncResult.ok(this._mostRecentOkValue as T);\n    } else {\n      return AsyncResult.pending();\n    }\n  }\n\n  getOrWait(): ReactPromise<T> {\n    const uuid = generateUuid();\n    if (this.isRejected()) {\n      return rejected(this._rejectionError);\n    } else if (this.isAvailable()) {\n      return resolved(this._mostRecentOkValue as T);\n    }\n    const promise = new Promise<T>((resolve, reject) => {\n      this.onceChange((value) => {\n        resolve(value);\n      });\n      this._waitingRejectFunctions.set(uuid, reject);\n    });\n    const withFinally = promise.finally(() => {\n      this._waitingRejectFunctions.delete(uuid);\n    });\n    return pending(withFinally);\n  }\n\n  _setIfLatest(result: Result<T>, curCounter: number) {\n    const oldState = this.get();\n    const oldValue = this._mostRecentOkValue;\n    if (curCounter > this._lastSuccessfulUpdate) {\n      switch (result.status) {\n        case \"ok\": {\n          if (!this._isAvailable || this._isRejected || this._mostRecentOkValue !== result.data) {\n            this._lastSuccessfulUpdate = curCounter;\n            this._isAvailable = true;\n            this._isRejected = false;\n            this._mostRecentOkValue = result.data;\n            this._rejectionError = undefined;\n            this._callbacks.forEach((callback) => callback({\n              state: this.get(),\n              oldState,\n              lastOkValue: oldValue,\n            }));\n            return true;\n          }\n          return false;\n        }\n        case \"error\": {\n          this._lastSuccessfulUpdate = curCounter;\n          this._isAvailable = false;\n          this._isRejected = true;\n          this._rejectionError = result.error;\n          this._waitingRejectFunctions.forEach((reject) => reject(result.error));\n          this._callbacks.forEach((callback) => callback({\n            state: this.get(),\n            oldState,\n            lastOkValue: oldValue,\n          }));\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  set(value: T): void {\n    this._setIfLatest(Result.ok(value), ++this._updateCounter);\n  }\n\n  update(updater: (value: T | undefined) => T): T {\n    const value = updater(this._mostRecentOkValue);\n    this.set(value);\n    return value;\n  }\n\n  async setAsync(promise: Promise<T>): Promise<boolean> {\n    return await storeLock.withReadLock(async () => {\n      const curCounter = ++this._updateCounter;\n      const result = await Result.fromPromise(promise);\n      return this._setIfLatest(result, curCounter);\n    });\n  }\n\n  setUnavailable(): void {\n    this._lastSuccessfulUpdate = ++this._updateCounter;\n    this._isAvailable = false;\n    this._isRejected = false;\n    this._rejectionError = undefined;\n  }\n\n  setRejected(error: unknown): void {\n    this._setIfLatest(Result.error(error), ++this._updateCounter);\n  }\n\n  map<U>(mapper: (value: T) => U): AsyncStore<U> {\n    const store = new AsyncStore<U>();\n    this.onChange((value) => {\n      store.set(mapper(value));\n    });\n    return store;\n  }\n\n  onChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    return this.onStateChange(({ state, lastOkValue }) => {\n      if (state.status === \"ok\") {\n        callback(state.data, lastOkValue);\n      }\n    });\n  }\n\n  onStateChange(callback: AsyncStoreStateChangeCallback<T>): { unsubscribe: () => void } {\n    const uuid = generateUuid();\n    this._callbacks.set(uuid, callback);\n    return {\n      unsubscribe: () => {\n        this._callbacks.delete(uuid);\n      },\n    };\n  }\n\n  onceChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    const { unsubscribe } = this.onChange((...args) => {\n      unsubscribe();\n      callback(...args);\n    });\n    return { unsubscribe };\n  }\n\n  onceStateChange(callback: AsyncStoreStateChangeCallback<T>): { unsubscribe: () => void } {\n    const { unsubscribe } = this.onStateChange((...args) => {\n      unsubscribe();\n      callback(...args);\n    });\n    return { unsubscribe };\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3497, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/sessions.ts"],"sourcesContent":["import * as jose from 'jose';\nimport { StackAssertionError } from \"./utils/errors\";\nimport { Store } from \"./utils/stores\";\n\nexport class AccessToken {\n  constructor(\n    public readonly token: string,\n  ) {\n    if (token === \"undefined\") {\n      throw new StackAssertionError(\"Access token is the string 'undefined'; it's unlikely this is the correct value. They're supposed to be unguessable!\");\n    }\n  }\n\n  get decoded() {\n    return jose.decodeJwt(this.token);\n  }\n\n  get expiresAt(): Date {\n    const { exp } = this.decoded;\n    if (exp === undefined) return new Date(8640000000000000);  // max date value\n    return new Date(exp * 1000);\n  }\n\n  /**\n   * @returns The number of milliseconds until the access token expires, or 0 if it has already expired.\n   */\n  get expiresInMillis(): number {\n    return Math.max(0, this.expiresAt.getTime() - Date.now());\n  }\n\n  isExpired(): boolean {\n    return this.expiresInMillis <= 0;\n  }\n}\n\nexport class RefreshToken {\n  constructor(\n    public readonly token: string,\n  ) {\n    if (token === \"undefined\") {\n      throw new StackAssertionError(\"Refresh token is the string 'undefined'; it's unlikely this is the correct value. They're supposed to be unguessable!\");\n    }\n  }\n}\n\n/**\n * An InternalSession represents a user's session, which may or may not be valid. It may contain an access token, a refresh token, or both.\n *\n * A session never changes which user or session it belongs to, but the tokens in it may change over time.\n */\nexport class InternalSession {\n  /**\n  * Each session has a session key that depends on the tokens inside. If the session has a refresh token, the session key depends only on the refresh token. If the session does not have a refresh token, the session key depends only on the access token.\n  *\n  * Multiple Session objects may have the same session key, which implies that they represent the same session by the same user. Furthermore, a session's key never changes over the lifetime of a session object.\n  *\n  * This is useful for caching and indexing sessions.\n  */\n  public readonly sessionKey: string;\n\n  /**\n   * An access token that is not known to be invalid (ie. may be valid, but may have expired).\n   */\n  private _accessToken: Store<AccessToken | null>;\n  private readonly _refreshToken: RefreshToken | null;\n\n  /**\n   * Whether the session as a whole is known to be invalid (ie. both access and refresh tokens are invalid). Used as a cache to avoid making multiple requests to the server (sessions never go back to being valid after being invalidated).\n   *\n   * It is possible for the access token to be invalid but the refresh token to be valid, in which case the session is\n   * still valid (just needs a refresh). It is also possible for the access token to be valid but the refresh token to\n   * be invalid, in which case the session is also valid (eg. if the refresh token is null because the user only passed\n   * in an access token, eg. in a server-side request handler).\n   */\n  private _knownToBeInvalid = new Store<boolean>(false);\n\n  private _refreshPromise: Promise<AccessToken | null> | null = null;\n\n  constructor(private readonly _options: {\n    refreshAccessTokenCallback(refreshToken: RefreshToken): Promise<AccessToken | null>,\n    refreshToken: string | null,\n    accessToken?: string | null,\n  }) {\n    this._accessToken = new Store(_options.accessToken ? new AccessToken(_options.accessToken) : null);\n    this._refreshToken = _options.refreshToken ? new RefreshToken(_options.refreshToken) : null;\n    if (_options.accessToken === null && _options.refreshToken === null) {\n      // this session is already invalid\n      this._knownToBeInvalid.set(true);\n    }\n    this.sessionKey = InternalSession.calculateSessionKey({ accessToken: _options.accessToken ?? null, refreshToken: _options.refreshToken });\n  }\n\n  static calculateSessionKey(ofTokens: { refreshToken: string | null, accessToken?: string | null }): string {\n    if (ofTokens.refreshToken) {\n      return `refresh-${ofTokens.refreshToken}`;\n    } else if (ofTokens.accessToken) {\n      return `access-${ofTokens.accessToken}`;\n    } else {\n      return \"not-logged-in\";\n    }\n  }\n\n  isKnownToBeInvalid() {\n    return this._knownToBeInvalid.get();\n  }\n\n  /**\n   * Marks the session object as invalid, meaning that the refresh and access tokens can no longer be used.\n   */\n  markInvalid() {\n    this._accessToken.set(null);\n    this._knownToBeInvalid.set(true);\n  }\n\n  onInvalidate(callback: () => void): { unsubscribe: () => void } {\n    return this._knownToBeInvalid.onChange(() => callback());\n  }\n\n  /**\n   * Returns the access token if it is found in the cache, fetching it otherwise.\n   *\n   * This is usually the function you want to call to get an access token. Either set `minMillisUntilExpiration` to a reasonable value, or catch errors that occur if it expires, and call `markAccessTokenExpired` to mark the token as expired if so (after which a call to this function will always refetch the token).\n   *\n   * @returns null if the session is known to be invalid, cached tokens if they exist in the cache (which may or may not be valid still), or new tokens otherwise.\n   */\n  async getOrFetchLikelyValidTokens(minMillisUntilExpiration: number): Promise<{ accessToken: AccessToken, refreshToken: RefreshToken | null } | null> {\n    if (minMillisUntilExpiration >= 60_000) {\n      throw new Error(`Required access token expiry ${minMillisUntilExpiration}ms is too long; access tokens are too short to be used for more than 60s`);\n    }\n\n    const accessToken = this._getPotentiallyInvalidAccessTokenIfAvailable();\n    if (!accessToken || accessToken.expiresInMillis < minMillisUntilExpiration) {\n      const newTokens = await this.fetchNewTokens();\n      const expiresInMillis = newTokens?.accessToken.expiresInMillis;\n      if (expiresInMillis && expiresInMillis < minMillisUntilExpiration) {\n        throw new StackAssertionError(`Required access token expiry ${minMillisUntilExpiration}ms is too long; access tokens are too short when they're generated (${expiresInMillis}ms)`);\n      }\n      return newTokens;\n    }\n    return { accessToken, refreshToken: this._refreshToken };\n  }\n\n  /**\n   * Fetches new tokens that are, at the time of fetching, guaranteed to be valid.\n   *\n   * The newly generated tokens are short-lived, so it's good practice not to rely on their validity (if possible). However, this function is useful in some cases where you only want to pass access tokens to a service, and you want to make sure said access token has the longest possible lifetime.\n   *\n   * In most cases, you should prefer `getOrFetchLikelyValidTokens`.\n   *\n   * @returns null if the session is known to be invalid, or new tokens otherwise (which, at the time of fetching, are guaranteed to be valid).\n   */\n  async fetchNewTokens(): Promise<{ accessToken: AccessToken, refreshToken: RefreshToken | null } | null> {\n    const accessToken = await this._getNewlyFetchedAccessToken();\n    return accessToken ? { accessToken, refreshToken: this._refreshToken } : null;\n  }\n\n  markAccessTokenExpired(accessToken: AccessToken) {\n    // TODO we don't need this anymore, since we now check the expiry by ourselves\n    if (this._accessToken.get() === accessToken) {\n      this._accessToken.set(null);\n    }\n  }\n\n  /**\n   * Note that a callback invocation with `null` does not mean the session has been invalidated; the access token may just have expired. Use `onInvalidate` to detect invalidation.\n   */\n  onAccessTokenChange(callback: (newAccessToken: AccessToken | null) => void): { unsubscribe: () => void } {\n    return this._accessToken.onChange(callback);\n  }\n\n  /**\n   * @returns An access token, which may be expired or expire soon, or null if it is known to be invalid.\n   */\n  private _getPotentiallyInvalidAccessTokenIfAvailable(): AccessToken | null {\n    if (!this._refreshToken) return null;\n    if (this.isKnownToBeInvalid()) return null;\n\n    const accessToken = this._accessToken.get();\n    if (accessToken && !accessToken.isExpired()) return accessToken;\n\n    return null;\n  }\n\n  /**\n   * You should prefer `_getOrFetchPotentiallyInvalidAccessToken` in almost all cases.\n   *\n   * @returns A newly fetched access token (never read from cache), or null if the session either does not represent a user or the session is invalid.\n   */\n  private async _getNewlyFetchedAccessToken(): Promise<AccessToken | null> {\n    if (!this._refreshToken) return null;\n    if (this._knownToBeInvalid.get()) return null;\n\n    if (!this._refreshPromise) {\n      this._refreshAndSetRefreshPromise(this._refreshToken);\n    }\n    return await this._refreshPromise;\n  }\n\n  private _refreshAndSetRefreshPromise(refreshToken: RefreshToken) {\n    let refreshPromise: Promise<AccessToken | null> = this._options.refreshAccessTokenCallback(refreshToken).then((accessToken) => {\n      if (refreshPromise === this._refreshPromise) {\n        this._refreshPromise = null;\n        this._accessToken.set(accessToken);\n        if (!accessToken) {\n          this.markInvalid();\n        }\n      }\n      return accessToken;\n    });\n    this._refreshPromise = refreshPromise;\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA,YAAY,UAAU;AACtB,SAAS,2BAA2B;AACpC,SAAS,aAAa;;;;AAEf,IAAM,cAAN,MAAkB;IASvB,IAAI,UAAU;QACZ,wKAAY,YAAA,CAAU,IAAA,CAAK,KAAK;IAClC;IAEA,IAAI,YAAkB;QACpB,MAAM,EAAE,GAAA,CAAI,CAAA,GAAI,IAAA,CAAK,OAAA;QACrB,IAAI,QAAQ,KAAA,EAAW,CAAA,OAAO,aAAA,GAAA,IAAI,KAAK,MAAgB;QACvD,OAAO,IAAI,KAAK,MAAM,GAAI;IAC5B;IAAA;;GAAA,GAKA,IAAI,kBAA0B;QAC5B,OAAO,KAAK,GAAA,CAAI,GAAG,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ,IAAI,KAAK,GAAA,CAAI,CAAC;IAC1D;IAEA,YAAqB;QACnB,OAAO,IAAA,CAAK,eAAA,IAAmB;IACjC;IA3BA,YACkB,KAAA,CAChB;QADgB,IAAA,CAAA,KAAA,GAAA;QAEhB,IAAI,UAAU,aAAa;YACzB,MAAM,yLAAI,sBAAA,CAAoB,sHAAsH;QACtJ;IACF;AAsBF;AAEO,IAAM,eAAN,MAAmB;IACxB,YACkB,KAAA,CAChB;QADgB,IAAA,CAAA,KAAA,GAAA;QAEhB,IAAI,UAAU,aAAa;YACzB,MAAM,yLAAI,sBAAA,CAAoB,uHAAuH;QACvJ;IACF;AACF;AAOO,IAAM,kBAAN,MAAM,iBAAgB;IA0C3B,OAAO,oBAAoB,QAAA,EAAgF;QACzG,IAAI,SAAS,YAAA,EAAc;YACzB,OAAO,WAAgC,OAArB,SAAS,YAAY;QACzC,OAAA,IAAW,SAAS,WAAA,EAAa;YAC/B,OAAO,UAA8B,OAApB,SAAS,WAAW;QACvC,OAAO;YACL,OAAO;QACT;IACF;IAEA,qBAAqB;QACnB,OAAO,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI;IACpC;IAAA;;GAAA,GAKA,cAAc;QACZ,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,IAAI;QAC1B,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI,IAAI;IACjC;IAEA,aAAa,QAAA,EAAmD;QAC9D,OAAO,IAAA,CAAK,iBAAA,CAAkB,QAAA,CAAS,IAAM,SAAS,CAAC;IACzD;IAAA;;;;;;GAAA,GASA,MAAM,4BAA4B,wBAAA,EAAmH;QACnJ,IAAI,4BAA4B,KAAQ;YACtC,MAAM,IAAI,MAAM,gCAAwD,OAAxB,wBAAwB,EAAA,yEAA0E;QACpJ;QAEA,MAAM,cAAc,IAAA,CAAK,4CAAA,CAA6C;QACtE,IAAI,CAAC,eAAe,YAAY,eAAA,GAAkB,0BAA0B;YAC1E,MAAM,YAAY,MAAM,IAAA,CAAK,cAAA,CAAe;YAC5C,MAAM,wEAAkB,UAAW,WAAA,CAAY,eAAA;YAC/C,IAAI,mBAAmB,kBAAkB,0BAA0B;gBACjE,MAAM,IAAI,2MAAA,CAAoB,uCAAgC,wBAAwB,EAAA,wEAAsF,OAAf,eAAe,EAAA,IAAK;YACnL;YACA,OAAO;QACT;QACA,OAAO;YAAE;YAAa,cAAc,IAAA,CAAK,aAAA;QAAc;IACzD;IAAA;;;;;;;;GAAA,GAWA,MAAM,iBAAkG;QACtG,MAAM,cAAc,MAAM,IAAA,CAAK,2BAAA,CAA4B;QAC3D,OAAO,cAAc;YAAE;YAAa,cAAc,IAAA,CAAK,aAAA;QAAc,IAAI;IAC3E;IAEA,uBAAuB,WAAA,EAA0B;QAE/C,IAAI,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,MAAM,aAAa;YAC3C,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,IAAI;QAC5B;IACF;IAAA;;GAAA,GAKA,oBAAoB,QAAA,EAAqF;QACvG,OAAO,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,QAAQ;IAC5C;IAAA;;GAAA,GAKQ,+CAAmE;QACzE,IAAI,CAAC,IAAA,CAAK,aAAA,CAAe,CAAA,OAAO;QAChC,IAAI,IAAA,CAAK,kBAAA,CAAmB,EAAG,CAAA,OAAO;QAEtC,MAAM,cAAc,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI;QAC1C,IAAI,eAAe,CAAC,YAAY,SAAA,CAAU,EAAG,CAAA,OAAO;QAEpD,OAAO;IACT;IAAA;;;;GAAA,GAOA,MAAc,8BAA2D;QACvE,IAAI,CAAC,IAAA,CAAK,aAAA,CAAe,CAAA,OAAO;QAChC,IAAI,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI,EAAG,CAAA,OAAO;QAEzC,IAAI,CAAC,IAAA,CAAK,eAAA,EAAiB;YACzB,IAAA,CAAK,4BAAA,CAA6B,IAAA,CAAK,aAAa;QACtD;QACA,OAAO,MAAM,IAAA,CAAK,eAAA;IACpB;IAEQ,6BAA6B,YAAA,EAA4B;QAC/D,IAAI,iBAA8C,IAAA,CAAK,QAAA,CAAS,0BAAA,CAA2B,YAAY,EAAE,IAAA,CAAK,CAAC,gBAAgB;YAC7H,IAAI,mBAAmB,IAAA,CAAK,eAAA,EAAiB;gBAC3C,IAAA,CAAK,eAAA,GAAkB;gBACvB,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,WAAW;gBACjC,IAAI,CAAC,aAAa;oBAChB,IAAA,CAAK,WAAA,CAAY;gBACnB;YACF;YACA,OAAO;QACT,CAAC;QACD,IAAA,CAAK,eAAA,GAAkB;IACzB;IApIA,YAA6B,QAAA,CAI1B;QAJ0B,IAAA,CAAA,QAAA,GAAA;QAJ7B;;;;;;;KAAA,GAAA,IAAA,CAAQ,iBAAA,GAAoB,yLAAI,QAAA,CAAe,KAAK;QAEpD,IAAA,CAAQ,eAAA,GAAsD;QAO5D,IAAA,CAAK,YAAA,GAAe,yLAAI,QAAA,CAAM,SAAS,WAAA,GAAc,IAAI,YAAY,SAAS,WAAW,IAAI,IAAI;QACjG,IAAA,CAAK,aAAA,GAAgB,SAAS,YAAA,GAAe,IAAI,aAAa,SAAS,YAAY,IAAI;QACvF,IAAI,SAAS,WAAA,KAAgB,QAAQ,SAAS,YAAA,KAAiB,MAAM;YAEnE,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI,IAAI;QACjC;;QACA,IAAA,CAAK,UAAA,GAAa,iBAAgB,mBAAA,CAAoB;YAAE,8CAAsB,WAAA,cAAT,yDAAwB;YAAM,cAAc,SAAS,YAAA;QAAa,CAAC;IAC1I;AAyHF","debugId":null}},
    {"offset": {"line": 3675, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/http.tsx"],"sourcesContent":["import { decodeBase64, encodeBase64, isBase64 } from \"./bytes\";\n\nexport const HTTP_METHODS = {\n  \"GET\": {\n    safe: true,\n    idempotent: true,\n  },\n  \"POST\": {\n    safe: false,\n    idempotent: false,\n  },\n  \"PUT\": {\n    safe: false,\n    idempotent: true,\n  },\n  \"DELETE\": {\n    safe: false,\n    idempotent: true,\n  },\n  \"PATCH\": {\n    safe: false,\n    idempotent: false,\n  },\n  \"OPTIONS\": {\n    safe: true,\n    idempotent: true,\n  },\n  \"HEAD\": {\n    safe: true,\n    idempotent: true,\n  },\n  \"TRACE\": {\n    safe: true,\n    idempotent: true,\n  },\n  \"CONNECT\": {\n    safe: false,\n    idempotent: false,\n  },\n} as const;\nexport type HttpMethod = keyof typeof HTTP_METHODS;\n\nexport function decodeBasicAuthorizationHeader(value: string): [string, string] | null {\n  const [type, encoded, ...rest] = value.split(' ');\n  if (rest.length > 0) return null;\n  if (!encoded) return null;\n  if (type !== 'Basic') return null;\n  if (!isBase64(encoded)) return null;\n  const decoded = new TextDecoder().decode(decodeBase64(encoded));\n  const split = decoded.split(':');\n  return [split[0], split.slice(1).join(':')];\n}\nundefined?.test(\"decodeBasicAuthorizationHeader\", ({ expect }) => {\n  // Test with valid Basic Authorization header\n  const username = \"user\";\n  const password = \"pass\";\n  const encoded = encodeBasicAuthorizationHeader(username, password);\n  expect(decodeBasicAuthorizationHeader(encoded)).toEqual([username, password]);\n\n  // Test with password containing colons\n  const complexPassword = \"pass:with:colons\";\n  const encodedComplex = encodeBasicAuthorizationHeader(username, complexPassword);\n  expect(decodeBasicAuthorizationHeader(encodedComplex)).toEqual([username, complexPassword]);\n\n  // Test with invalid headers\n  expect(decodeBasicAuthorizationHeader(\"NotBasic dXNlcjpwYXNz\")).toBe(null); // Wrong type\n  expect(decodeBasicAuthorizationHeader(\"Basic\")).toBe(null); // Missing encoded part\n  expect(decodeBasicAuthorizationHeader(\"Basic not-base64\")).toBe(null); // Not base64\n  expect(decodeBasicAuthorizationHeader(\"Basic dXNlcjpwYXNz extra\")).toBe(null); // Extra parts\n});\n\nexport function encodeBasicAuthorizationHeader(id: string, password: string): string {\n  if (id.includes(':')) throw new Error(\"Basic authorization header id cannot contain ':'\");\n  return `Basic ${encodeBase64(new TextEncoder().encode(`${id}:${password}`))}`;\n}\nundefined?.test(\"encodeBasicAuthorizationHeader\", ({ expect }) => {\n  // Test with simple username and password\n  const encoded = encodeBasicAuthorizationHeader(\"user\", \"pass\");\n  expect(encoded).toMatch(/^Basic [A-Za-z0-9+/=]+$/); // Should start with \"Basic \" followed by base64\n\n  // Test with empty password\n  const encodedEmptyPass = encodeBasicAuthorizationHeader(\"user\", \"\");\n  expect(encodedEmptyPass).toMatch(/^Basic [A-Za-z0-9+/=]+$/);\n\n  // Test with password containing special characters\n  const encodedSpecialChars = encodeBasicAuthorizationHeader(\"user\", \"p@ss!w0rd\");\n  expect(encodedSpecialChars).toMatch(/^Basic [A-Za-z0-9+/=]+$/);\n\n  // Test with username containing colon should throw\n  expect(() => encodeBasicAuthorizationHeader(\"user:name\", \"pass\")).toThrow();\n});\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,cAAc,cAAc,gBAAgB;;AAE9C,IAAM,eAAe;IAC1B,OAAO;QACL,MAAM;QACN,YAAY;IACd;IACA,QAAQ;QACN,MAAM;QACN,YAAY;IACd;IACA,OAAO;QACL,MAAM;QACN,YAAY;IACd;IACA,UAAU;QACR,MAAM;QACN,YAAY;IACd;IACA,SAAS;QACP,MAAM;QACN,YAAY;IACd;IACA,WAAW;QACT,MAAM;QACN,YAAY;IACd;IACA,QAAQ;QACN,MAAM;QACN,YAAY;IACd;IACA,SAAS;QACP,MAAM;QACN,YAAY;IACd;IACA,WAAW;QACT,MAAM;QACN,YAAY;IACd;AACF;AAGO,SAAS,+BAA+B,KAAA,EAAwC;IACrF,MAAM,CAAC,MAAM,SAAS,GAAG,IAAI,CAAA,GAAI,MAAM,KAAA,CAAM,GAAG;IAChD,IAAI,KAAK,MAAA,GAAS,EAAG,CAAA,OAAO;IAC5B,IAAI,CAAC,QAAS,CAAA,OAAO;IACrB,IAAI,SAAS,QAAS,CAAA,OAAO;IAC7B,IAAI,yLAAC,WAAA,EAAS,OAAO,EAAG,CAAA,OAAO;IAC/B,MAAM,UAAU,IAAI,YAAY,EAAE,MAAA,yLAAO,eAAA,EAAa,OAAO,CAAC;IAC9D,MAAM,QAAQ,QAAQ,KAAA,CAAM,GAAG;IAC/B,OAAO;QAAC,KAAA,CAAM,CAAC,CAAA;QAAG,MAAM,KAAA,CAAM,CAAC,EAAE,IAAA,CAAK,GAAG,CAAC;KAAA;AAC5C;AAoBO,SAAS,+BAA+B,EAAA,EAAY,QAAA,EAA0B;IACnF,IAAI,GAAG,QAAA,CAAS,GAAG,EAAG,CAAA,MAAM,IAAI,MAAM,kDAAkD;IACxF,OAAO,SAAoE,+LAA3D,eAAA,EAAa,IAAI,YAAY,EAAE,MAAA,CAAO,UAAG,EAAE,EAAA,KAAY,CAAE,CAAC,CAAC,IAAZ,QAAQ;AACzE","debugId":null}},
    {"offset": {"line": 3744, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/interface/client-interface.ts"],"sourcesContent":["import * as oauth from 'oauth4webapi';\n\nimport * as yup from 'yup';\nimport { KnownError, KnownErrors } from '../known-errors';\nimport { AccessToken, InternalSession, RefreshToken } from '../sessions';\nimport { generateSecureRandomString } from '../utils/crypto';\nimport { StackAssertionError, throwErr } from '../utils/errors';\nimport { globalVar } from '../utils/globals';\nimport { HTTP_METHODS, HttpMethod } from '../utils/http';\nimport { ReadonlyJson } from '../utils/json';\nimport { filterUndefined, filterUndefinedOrNull } from '../utils/objects';\nimport { AuthenticationResponseJSON, PublicKeyCredentialCreationOptionsJSON, PublicKeyCredentialRequestOptionsJSON, RegistrationResponseJSON } from '../utils/passkey';\nimport { wait } from '../utils/promises';\nimport { Result } from \"../utils/results\";\nimport { deindent } from '../utils/strings';\nimport { ConnectedAccountAccessTokenCrud } from './crud/connected-accounts';\nimport { ContactChannelsCrud } from './crud/contact-channels';\nimport { CurrentUserCrud } from './crud/current-user';\nimport { ItemCrud } from './crud/items';\nimport { NotificationPreferenceCrud } from './crud/notification-preferences';\nimport { TeamApiKeysCrud, UserApiKeysCrud, teamApiKeysCreateInputSchema, teamApiKeysCreateOutputSchema, userApiKeysCreateInputSchema, userApiKeysCreateOutputSchema } from './crud/project-api-keys';\nimport { ProjectPermissionsCrud } from './crud/project-permissions';\nimport { AdminUserProjectsCrud, ClientProjectsCrud } from './crud/projects';\nimport { SessionsCrud } from './crud/sessions';\nimport { TeamInvitationCrud } from './crud/team-invitation';\nimport { TeamMemberProfilesCrud } from './crud/team-member-profiles';\nimport { TeamPermissionsCrud } from './crud/team-permissions';\nimport { TeamsCrud } from './crud/teams';\nimport { inlineOfferSchema } from '../schema-fields';\n\nexport type ClientInterfaceOptions = {\n  clientVersion: string,\n  // This is a function instead of a string because it might be different based on the environment (for example client vs server)\n  getBaseUrl: () => string,\n  extraRequestHeaders: Record<string, string>,\n  projectId: string,\n  prepareRequest?: () => Promise<void>,\n} & ({\n  publishableClientKey: string,\n} | {\n  projectOwnerSession: InternalSession,\n});\n\nexport class StackClientInterface {\n  constructor(public readonly options: ClientInterfaceOptions) {\n    // nothing here\n  }\n\n  get projectId() {\n    return this.options.projectId;\n  }\n\n  getApiUrl() {\n    return this.options.getBaseUrl() + \"/api/v1\";\n  }\n\n  public async runNetworkDiagnostics(session?: InternalSession | null, requestType?: \"client\" | \"server\" | \"admin\") {\n    const tryRequest = async (cb: () => Promise<void>) => {\n      try {\n        await cb();\n        return \"OK\";\n      } catch (e) {\n        return `${e}`;\n      }\n    };\n    const cfTrace = await tryRequest(async () => {\n      const res = await fetch(\"https://1.1.1.1/cdn-cgi/trace\");\n      if (!res.ok) {\n        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);\n      }\n    });\n    const apiRoot = session !== undefined && requestType !== undefined ? await tryRequest(async () => {\n      const res = await this.sendClientRequestInner(\"/\", {}, session!, requestType);\n      if (res.status === \"error\") {\n        throw res.error;\n      }\n    }) : \"Not tested\";\n    const baseUrlBackend = await tryRequest(async () => {\n      const res = await fetch(new URL(\"/health\", this.getApiUrl()));\n      if (!res.ok) {\n        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);\n      }\n    });\n    const prodDashboard = await tryRequest(async () => {\n      const res = await fetch(\"https://app.stack-auth.com/health\");\n      if (!res.ok) {\n        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);\n      }\n    });\n    const prodBackend = await tryRequest(async () => {\n      const res = await fetch(\"https://api.stack-auth.com/health\");\n      if (!res.ok) {\n        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);\n      }\n    });\n    return {\n      \"navigator?.onLine\": globalVar.navigator?.onLine,\n      cfTrace,\n      apiRoot,\n      baseUrlBackend,\n      prodDashboard,\n      prodBackend,\n    };\n  }\n\n  protected async _createNetworkError(cause: Error, session?: InternalSession | null, requestType?: \"client\" | \"server\" | \"admin\") {\n    return new Error(deindent`\n      Stack Auth is unable to connect to the server. Please check your internet connection and try again.\n\n      If the problem persists, please contact support and provide a screenshot of your entire browser console.\n\n      ${cause}\n\n      ${JSON.stringify(await this.runNetworkDiagnostics(session, requestType), null, 2)}\n    `, { cause: cause });\n  }\n\n  protected async _networkRetry<T>(cb: () => Promise<Result<T, any>>, session?: InternalSession | null, requestType?: \"client\" | \"server\" | \"admin\"): Promise<T> {\n    const retriedResult = await Result.retry(\n      cb,\n      5,\n      { exponentialDelayBase: 1000 },\n    );\n\n    // try to diagnose the error for the user\n    if (retriedResult.status === \"error\") {\n      if (globalVar.navigator && !globalVar.navigator.onLine) {\n        throw new Error(\"You are offline. Please check your internet connection and try again. (window.navigator.onLine is falsy)\", { cause: retriedResult.error });\n      }\n      throw await this._createNetworkError(retriedResult.error, session, requestType);\n    }\n    return retriedResult.data;\n  }\n\n  protected async _networkRetryException<T>(cb: () => Promise<T>, session?: InternalSession | null, requestType?: \"client\" | \"server\" | \"admin\"): Promise<T> {\n    return await this._networkRetry(async () => await Result.fromThrowingAsync(cb), session, requestType);\n  }\n\n  public async fetchNewAccessToken(refreshToken: RefreshToken) {\n    if (!('publishableClientKey' in this.options)) {\n      // TODO support it\n      throw new Error(\"Admin session token is currently not supported for fetching new access token. Did you try to log in on a StackApp initiated with the admin session?\");\n    }\n\n    const as = {\n      issuer: this.options.getBaseUrl(),\n      algorithm: 'oauth2',\n      token_endpoint: this.getApiUrl() + '/auth/oauth/token',\n    };\n    const client: oauth.Client = {\n      client_id: this.projectId,\n      client_secret: this.options.publishableClientKey,\n      token_endpoint_auth_method: 'client_secret_post',\n    };\n\n    const rawResponse = await this._networkRetryException(\n      async () => await oauth.refreshTokenGrantRequest(\n        as,\n        client,\n        refreshToken.token,\n      )\n    );\n    const response = await this._processResponse(rawResponse);\n\n    if (response.status === \"error\") {\n      const error = response.error;\n      if (KnownErrors.RefreshTokenError.isInstance(error)) {\n        return null;\n      }\n      throw error;\n    }\n\n    if (!response.data.ok) {\n      const body = await response.data.text();\n      throw new Error(`Failed to send refresh token request: ${response.status} ${body}`);\n    }\n\n    const result = await oauth.processRefreshTokenResponse(as, client, response.data);\n    if (oauth.isOAuth2Error(result)) {\n      // TODO Handle OAuth 2.0 response body error\n      throw new StackAssertionError(\"OAuth error\", { result });\n    }\n\n    if (!result.access_token) {\n      throw new StackAssertionError(\"Access token not found in token endpoint response, this is weird!\");\n    }\n\n    return new AccessToken(result.access_token);\n  }\n\n  public async sendClientRequest(\n    path: string,\n    requestOptions: RequestInit,\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\" = \"client\",\n  ) {\n    session ??= this.createSession({\n      refreshToken: null,\n    });\n\n\n    return await this._networkRetry(\n      () => this.sendClientRequestInner(path, requestOptions, session!, requestType),\n      session,\n      requestType,\n    );\n  }\n\n  public createSession(options: Omit<ConstructorParameters<typeof InternalSession>[0], \"refreshAccessTokenCallback\">): InternalSession {\n    const session = new InternalSession({\n      refreshAccessTokenCallback: async (refreshToken) => await this.fetchNewAccessToken(refreshToken),\n      ...options,\n    });\n    return session;\n  }\n\n  protected async sendClientRequestAndCatchKnownError<E extends typeof KnownErrors[keyof KnownErrors]>(\n    path: string,\n    requestOptions: RequestInit,\n    tokenStoreOrNull: InternalSession | null,\n    errorsToCatch: readonly E[],\n  ): Promise<Result<\n    Response & {\n      usedTokens: {\n        accessToken: AccessToken,\n        refreshToken: RefreshToken | null,\n      } | null,\n    },\n    InstanceType<E>\n  >> {\n    try {\n      return Result.ok(await this.sendClientRequest(path, requestOptions, tokenStoreOrNull));\n    } catch (e) {\n      for (const errorType of errorsToCatch) {\n        if (errorType.isInstance(e)) {\n          return Result.error(e as InstanceType<E>);\n        }\n      }\n      throw e;\n    }\n  }\n\n  private async sendClientRequestInner(\n    path: string,\n    options: RequestInit,\n    session: InternalSession,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<Result<Response & {\n    usedTokens: {\n      accessToken: AccessToken,\n      refreshToken: RefreshToken | null,\n    } | null,\n  }>> {\n    /**\n     * `tokenObj === null` means the session is invalid/not logged in\n     */\n    let tokenObj = await session.getOrFetchLikelyValidTokens(20_000);\n\n    let adminSession = \"projectOwnerSession\" in this.options ? this.options.projectOwnerSession : null;\n    let adminTokenObj = adminSession ? await adminSession.getOrFetchLikelyValidTokens(20_000) : null;\n\n    // all requests should be dynamic to prevent Next.js caching\n    await this.options.prepareRequest?.();\n\n    let url = this.getApiUrl() + path;\n    if (url.endsWith(\"/\")) {\n      url = url.slice(0, -1);\n    }\n    const params: RequestInit = {\n      /**\n       * This fetch may be cross-origin, in which case we don't want to send cookies of the\n       * original origin (this is the default behavior of `credentials`).\n       *\n       * To help debugging, also omit cookies on same-origin, so we don't accidentally\n       * implement reliance on cookies anywhere.\n       *\n       * However, Cloudflare Workers don't actually support `credentials`, so we only set it\n       * if Cloudflare-exclusive globals are not detected. https://github.com/cloudflare/workers-sdk/issues/2514\n       */\n      ...(\"WebSocketPair\" in globalVar ? {} : {\n        credentials: \"omit\",\n      }),\n      ...options,\n      headers: {\n        \"X-Stack-Override-Error-Status\": \"true\",\n        \"X-Stack-Project-Id\": this.projectId,\n        \"X-Stack-Access-Type\": requestType,\n        \"X-Stack-Client-Version\": this.options.clientVersion,\n        ...(tokenObj ? {\n          \"X-Stack-Access-Token\": tokenObj.accessToken.token,\n        } : {}),\n        ...(tokenObj?.refreshToken ? {\n          \"X-Stack-Refresh-Token\": tokenObj.refreshToken.token,\n        } : {}),\n        ...('publishableClientKey' in this.options ? {\n          \"X-Stack-Publishable-Client-Key\": this.options.publishableClientKey,\n        } : {}),\n        ...(adminTokenObj ? {\n          \"X-Stack-Admin-Access-Token\": adminTokenObj.accessToken.token,\n        } : {}),\n        /**\n         * Next.js until v15 would cache fetch requests by default, and forcefully disabling it was nearly impossible.\n         *\n         * This header is used to change the cache key and hence always disable it, because we do our own caching.\n         *\n         * When we drop support for Next.js <15, we may be able to remove this header, but please make sure that this is\n         * the case (I haven't actually tested.)\n         */\n        \"X-Stack-Random-Nonce\": generateSecureRandomString(),\n        // don't show a warning when proxying the API through ngrok (only relevant if the API url is an ngrok site)\n        'ngrok-skip-browser-warning': 'true',\n        ...this.options.extraRequestHeaders,\n        ...options.headers,\n      },\n      /**\n       * Cloudflare Workers does not support cache, so don't pass it there\n       */\n      ...(\"WebSocketPair\" in globalVar ? {} : {\n        cache: \"no-store\",\n      }),\n    };\n\n    let rawRes;\n    try {\n      rawRes = await fetch(url, params);\n    } catch (e) {\n      if (e instanceof TypeError) {\n        // Likely to be a network error. Retry if the request is idempotent, throw network error otherwise.\n        if (HTTP_METHODS[(params.method ?? \"GET\") as HttpMethod].idempotent) {\n          return Result.error(e);\n        } else {\n          throw await this._createNetworkError(e, session, requestType);\n        }\n      }\n      throw e;\n    }\n\n    const processedRes = await this._processResponse(rawRes);\n    if (processedRes.status === \"error\") {\n      // If the access token is invalid, reset it and retry\n      if (KnownErrors.InvalidAccessToken.isInstance(processedRes.error)) {\n        if (!tokenObj) {\n          throw new StackAssertionError(\"Received invalid access token, but session is not logged in\", { tokenObj, processedRes });\n        }\n        session.markAccessTokenExpired(tokenObj.accessToken);\n        return Result.error(processedRes.error);\n      }\n\n      // Same for the admin access token\n      // TODO HACK: Some of the backend hasn't been ported to use the new error codes, so if we have project owner tokens we need to check for ApiKeyNotFound too. Once the migration to smartRouteHandlers is complete, we can check for InvalidAdminAccessToken only.\n      if (adminSession && (KnownErrors.InvalidAdminAccessToken.isInstance(processedRes.error) || KnownErrors.ApiKeyNotFound.isInstance(processedRes.error))) {\n        if (!adminTokenObj) {\n          throw new StackAssertionError(\"Received invalid admin access token, but admin session is not logged in\", { adminTokenObj, processedRes });\n        }\n        adminSession.markAccessTokenExpired(adminTokenObj.accessToken);\n        return Result.error(processedRes.error);\n      }\n\n      // Known errors are client side errors, so except for the ones above they should not be retried\n      // Hence, throw instead of returning an error\n      throw processedRes.error;\n    }\n\n\n    const res = Object.assign(processedRes.data, {\n      usedTokens: tokenObj,\n    });\n    if (res.ok) {\n      return Result.ok(res);\n    } else if (res.status === 429) {\n      // Rate limited, so retry if we can\n      const retryAfter = res.headers.get(\"Retry-After\");\n      if (retryAfter !== null) {\n        console.log(`Rate limited while sending request to ${url}. Will retry after ${retryAfter} seconds...`);\n        await wait(Number(retryAfter) * 1000);\n        return Result.error(new Error(`Rate limited, retrying after ${retryAfter} seconds`));\n      }\n      console.log(`Rate limited while sending request to ${url}, no retry-after header received. Retrying...`);\n      return Result.error(new Error(\"Rate limited, no retry-after header received\"));\n    } else {\n      const error = await res.text();\n\n      const errorObj = new StackAssertionError(`Failed to send request to ${url}: ${res.status} ${error}`, { request: params, res, path });\n\n      if (res.status === 508 && error.includes(\"INFINITE_LOOP_DETECTED\")) {\n        // Some Vercel deployments seem to have an odd infinite loop bug. In that case, retry.\n        // See: https://github.com/stack-auth/stack-auth/issues/319\n        return Result.error(errorObj);\n      }\n\n      // Do not retry, throw error instead of returning one\n      throw errorObj;\n    }\n  }\n\n  private async _processResponse(rawRes: Response): Promise<Result<Response, KnownError>> {\n    let res = rawRes;\n    if (rawRes.headers.has(\"x-stack-actual-status\")) {\n      const actualStatus = Number(rawRes.headers.get(\"x-stack-actual-status\"));\n      res = new Response(rawRes.body, {\n        status: actualStatus,\n        statusText: rawRes.statusText,\n        headers: rawRes.headers,\n      });\n    }\n\n    // Handle known errors\n    if (res.headers.has(\"x-stack-known-error\")) {\n      const errorJson = await res.json();\n      if (res.headers.get(\"x-stack-known-error\") !== errorJson.code) {\n        throw new StackAssertionError(\"Mismatch between x-stack-known-error header and error code in body; the server's response is invalid\");\n      }\n      const error = KnownError.fromJson(errorJson);\n      return Result.error(error);\n    }\n\n    return Result.ok(res);\n  }\n\n  public async checkFeatureSupport(options: { featureName?: string } & ReadonlyJson): Promise<never> {\n    const res = await this.sendClientRequest(\"/check-feature-support\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(options),\n    }, null);\n\n    throw new StackAssertionError(await res.text());\n  }\n\n  async sendForgotPasswordEmail(\n    email: string,\n    callbackUrl: string,\n  ): Promise<Result<undefined, KnownErrors[\"UserNotFound\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/send-reset-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          callback_url: callbackUrl,\n        }),\n      },\n      null,\n      [KnownErrors.UserNotFound],\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(undefined);\n    }\n  }\n\n  async sendVerificationEmail(\n    email: string,\n    callbackUrl: string,\n    session: InternalSession\n  ): Promise<KnownErrors[\"EmailAlreadyVerified\"] | undefined> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/contact-channels/send-verification-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          callback_url: callbackUrl,\n        }),\n      },\n      session,\n      [KnownErrors.EmailAlreadyVerified]\n    );\n\n    if (res.status === \"error\") {\n      return res.error;\n    }\n  }\n\n  async sendMagicLinkEmail(\n    email: string,\n    callbackUrl: string,\n  ): Promise<Result<{ nonce: string }, KnownErrors[\"RedirectUrlNotWhitelisted\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/otp/send-sign-in-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          callback_url: callbackUrl,\n        }),\n      },\n      null,\n      [KnownErrors.RedirectUrlNotWhitelisted]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(await res.data.json());\n    }\n  }\n\n  async resetPassword(\n    options: { code: string } & ({ password: string } | { onlyVerifyCode: true })\n  ): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"onlyVerifyCode\" in options ? \"/auth/password/reset/check-code\" : \"/auth/password/reset\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          code: options.code,\n          ...(\"password\" in options ? { password: options.password } : {}),\n        }),\n      },\n      null,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(undefined);\n    }\n  }\n\n  async updatePassword(\n    options: { oldPassword: string, newPassword: string },\n    session: InternalSession\n  ): Promise<KnownErrors[\"PasswordConfirmationMismatch\"] | KnownErrors[\"PasswordRequirementsNotMet\"] | undefined> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/update\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          old_password: options.oldPassword,\n          new_password: options.newPassword,\n        }),\n      },\n      session,\n      [KnownErrors.PasswordConfirmationMismatch, KnownErrors.PasswordRequirementsNotMet]\n    );\n\n    if (res.status === \"error\") {\n      return res.error;\n    }\n  }\n\n  async setPassword(\n    options: { password: string },\n    session: InternalSession\n  ): Promise<KnownErrors[\"PasswordRequirementsNotMet\"] | undefined> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/set\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(options),\n      },\n      session,\n      [KnownErrors.PasswordRequirementsNotMet]\n    );\n\n    if (res.status === \"error\") {\n      return res.error;\n    }\n  }\n\n  async verifyPasswordResetCode(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.resetPassword({ code, onlyVerifyCode: true });\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(undefined);\n    }\n  }\n\n  async verifyEmail(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/contact-channels/verify\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          code,\n        }),\n      },\n      null,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(undefined);\n    }\n  }\n\n  async initiatePasskeyRegistration(\n    options: {},\n    session: InternalSession\n  ): Promise<Result<{ options_json: PublicKeyCredentialCreationOptionsJSON, code: string }, KnownErrors[]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/passkey/initiate-passkey-registration\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(options),\n      },\n      session,\n      []\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    return Result.ok(await res.data.json());\n  }\n\n  async registerPasskey(\n    options: { credential: RegistrationResponseJSON, code: string },\n    session: InternalSession\n  ): Promise<Result<undefined, KnownErrors[\"PasskeyRegistrationFailed\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/passkey/register\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(options),\n      },\n      session,\n      [KnownErrors.PasskeyRegistrationFailed]\n    );\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n    return Result.ok(undefined);\n  }\n\n  async initiatePasskeyAuthentication(\n    options: {\n    },\n    session: InternalSession\n  ): Promise<Result<{ options_json: PublicKeyCredentialRequestOptionsJSON, code: string }, KnownErrors[]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/passkey/initiate-passkey-authentication\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(options),\n      },\n      session,\n      []\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    return Result.ok(await res.data.json());\n  }\n\n  async sendTeamInvitation(options: {\n    email: string,\n    teamId: string,\n    callbackUrl: string,\n    session: InternalSession,\n  }): Promise<void> {\n    await this.sendClientRequest(\n      \"/team-invitations/send-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email: options.email,\n          team_id: options.teamId,\n          callback_url: options.callbackUrl,\n        }),\n      },\n      options.session,\n    );\n  }\n\n  async acceptTeamInvitation<T extends 'use' | 'details' | 'check'>(options: {\n    code: string,\n    session: InternalSession,\n    type: T,\n  }): Promise<Result<T extends 'details' ? { team_display_name: string } : undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      options.type === 'check' ?\n        \"/team-invitations/accept/check-code\" :\n        options.type === 'details' ?\n          \"/team-invitations/accept/details\" :\n          \"/team-invitations/accept\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          code: options.code,\n        }),\n      },\n      options.session,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(await res.data.json());\n    }\n  }\n\n  async totpMfa(\n    attemptCode: string,\n    totp: string,\n    session: InternalSession\n  ) {\n    const res = await this.sendClientRequest(\"/auth/mfa/sign-in\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        code: attemptCode,\n        type: \"totp\",\n        totp: totp,\n      }),\n    }, session);\n\n    const result = await res.json();\n    return {\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n      newUser: result.is_new_user,\n    };\n  }\n\n  async signInWithCredential(\n    email: string,\n    password: string,\n    session: InternalSession\n  ): Promise<Result<{ accessToken: string, refreshToken: string }, KnownErrors[\"EmailPasswordMismatch\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/sign-in\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      },\n      session,\n      [KnownErrors.EmailPasswordMismatch]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    });\n  }\n\n  async signUpWithCredential(\n    email: string,\n    password: string,\n    emailVerificationRedirectUrl: string,\n    session: InternalSession,\n  ): Promise<Result<{ accessToken: string, refreshToken: string }, KnownErrors[\"UserWithEmailAlreadyExists\"] | KnownErrors[\"PasswordRequirementsNotMet\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/sign-up\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        method: \"POST\",\n        body: JSON.stringify({\n          email,\n          password,\n          verification_callback_url: emailVerificationRedirectUrl,\n        }),\n      },\n      session,\n      [KnownErrors.UserWithEmailAlreadyExists, KnownErrors.PasswordRequirementsNotMet]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    });\n  }\n\n  async signUpAnonymously(session: InternalSession): Promise<Result<{ accessToken: string, refreshToken: string }, never>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/anonymous/sign-up\",\n      {\n        method: \"POST\",\n      },\n      session,\n      [],\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    });\n  }\n\n  async signInWithMagicLink(code: string): Promise<Result<{ newUser: boolean, accessToken: string, refreshToken: string }, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/otp/sign-in\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          code,\n        }),\n      },\n      null,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n      newUser: result.is_new_user,\n    });\n  }\n\n  async signInWithMfa(totp: string, code: string): Promise<Result<{ newUser: boolean, accessToken: string, refreshToken: string }, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/mfa/sign-in\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          type: \"totp\",\n          totp,\n          code,\n        }),\n      },\n      null,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n      newUser: result.is_new_user,\n    });\n  }\n\n  async signInWithPasskey(body: { authentication_response: AuthenticationResponseJSON, code: string }): Promise<Result<{accessToken: string, refreshToken: string }, KnownErrors[\"PasskeyAuthenticationFailed\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/passkey/sign-in\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(body),\n      },\n      null,\n      [KnownErrors.PasskeyAuthenticationFailed]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    });\n  }\n\n  async getOAuthUrl(\n    options: {\n      provider: string,\n      redirectUrl: string,\n      errorRedirectUrl: string,\n      afterCallbackRedirectUrl?: string,\n      codeChallenge: string,\n      state: string,\n      type: \"authenticate\" | \"link\",\n      providerScope?: string,\n    } & ({ type: \"authenticate\" } | { type: \"link\", session: InternalSession })\n  ): Promise<string> {\n    const updatedRedirectUrl = new URL(options.redirectUrl);\n    for (const key of [\"code\", \"state\"]) {\n      if (updatedRedirectUrl.searchParams.has(key)) {\n        console.warn(\"Redirect URL already contains \" + key + \" parameter, removing it as it will be overwritten by the OAuth callback\");\n      }\n      updatedRedirectUrl.searchParams.delete(key);\n    }\n\n    if (!('publishableClientKey' in this.options)) {\n      // TODO fix\n      throw new Error(\"Admin session token is currently not supported for OAuth\");\n    }\n    const url = new URL(this.getApiUrl() + \"/auth/oauth/authorize/\" + options.provider.toLowerCase());\n    url.searchParams.set(\"client_id\", this.projectId);\n    url.searchParams.set(\"client_secret\", this.options.publishableClientKey);\n    url.searchParams.set(\"redirect_uri\", updatedRedirectUrl.toString());\n    url.searchParams.set(\"scope\", \"legacy\");\n    url.searchParams.set(\"state\", options.state);\n    url.searchParams.set(\"grant_type\", \"authorization_code\");\n    url.searchParams.set(\"code_challenge\", options.codeChallenge);\n    url.searchParams.set(\"code_challenge_method\", \"S256\");\n    url.searchParams.set(\"response_type\", \"code\");\n    url.searchParams.set(\"type\", options.type);\n    url.searchParams.set(\"error_redirect_url\", options.errorRedirectUrl);\n\n    if (options.afterCallbackRedirectUrl) {\n      url.searchParams.set(\"after_callback_redirect_url\", options.afterCallbackRedirectUrl);\n    }\n\n    if (options.type === \"link\") {\n      const tokens = await options.session.getOrFetchLikelyValidTokens(20_000);\n      url.searchParams.set(\"token\", tokens?.accessToken.token || \"\");\n\n      if (options.providerScope) {\n        url.searchParams.set(\"provider_scope\", options.providerScope);\n      }\n    }\n\n    return url.toString();\n  }\n\n  async callOAuthCallback(options: {\n    oauthParams: URLSearchParams,\n    redirectUri: string,\n    codeVerifier: string,\n    state: string,\n  }): Promise<{ newUser: boolean, afterCallbackRedirectUrl?: string, accessToken: string, refreshToken: string }> {\n    if (!('publishableClientKey' in this.options)) {\n      // TODO fix\n      throw new Error(\"Admin session token is currently not supported for OAuth\");\n    }\n    const as = {\n      issuer: this.options.getBaseUrl(),\n      algorithm: 'oauth2',\n      token_endpoint: this.getApiUrl() + '/auth/oauth/token',\n    };\n    const client: oauth.Client = {\n      client_id: this.projectId,\n      client_secret: this.options.publishableClientKey,\n      token_endpoint_auth_method: 'client_secret_post',\n    };\n    const params = await this._networkRetryException(\n      async () => oauth.validateAuthResponse(as, client, options.oauthParams, options.state),\n    );\n    if (oauth.isOAuth2Error(params)) {\n      throw new StackAssertionError(\"Error validating outer OAuth response\", { params }); // Handle OAuth 2.0 redirect error\n    }\n    const response = await oauth.authorizationCodeGrantRequest(\n      as,\n      client,\n      params,\n      options.redirectUri,\n      options.codeVerifier,\n    );\n\n    const result = await oauth.processAuthorizationCodeOAuth2Response(as, client, response);\n    if (oauth.isOAuth2Error(result)) {\n      if (\"code\" in result && result.code === \"MULTI_FACTOR_AUTHENTICATION_REQUIRED\") {\n        throw new KnownErrors.MultiFactorAuthenticationRequired((result as any).details.attempt_code);\n      }\n      // TODO Handle OAuth 2.0 response body error\n      throw new StackAssertionError(\"Outer OAuth error during authorization code response\", { result });\n    }\n    return {\n      newUser: result.is_new_user as boolean,\n      afterCallbackRedirectUrl: result.after_callback_redirect_url as string | undefined,\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token ?? throwErr(\"Refresh token not found in outer OAuth response\"),\n    };\n  }\n\n  async signOut(session: InternalSession): Promise<void> {\n    const tokenObj = await session.getOrFetchLikelyValidTokens(20_000);\n    if (tokenObj) {\n      const resOrError = await this.sendClientRequestAndCatchKnownError(\n        \"/auth/sessions/current\",\n        {\n          method: \"DELETE\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({}),\n        },\n        session,\n        [KnownErrors.RefreshTokenError]\n      );\n      if (resOrError.status === \"error\") {\n        if (KnownErrors.RefreshTokenError.isInstance(resOrError.error)) {\n          // refresh token was already invalid, just continue like nothing happened\n        } else {\n          // this should never happen\n          throw new StackAssertionError(\"Unexpected error\", { error: resOrError.error });\n        }\n      } else {\n        // user was signed out successfully, all good\n      }\n    }\n    session.markInvalid();\n  }\n\n  async getClientUserByToken(session: InternalSession): Promise<CurrentUserCrud[\"Client\"][\"Read\"] | null> {\n    const responseOrError = await this.sendClientRequestAndCatchKnownError(\n      \"/users/me\",\n      {},\n      session,\n      [KnownErrors.CannotGetOwnUserWithoutUser],\n    );\n    if (responseOrError.status === \"error\") {\n      if (KnownErrors.CannotGetOwnUserWithoutUser.isInstance(responseOrError.error)) {\n        return null;\n      } else {\n        throw new StackAssertionError(\"Unexpected uncaught error\", { cause: responseOrError.error });\n      }\n    }\n    const response = responseOrError.data;\n    const user: CurrentUserCrud[\"Client\"][\"Read\"] = await response.json();\n    if (!(user as any)) throw new StackAssertionError(\"User endpoint returned null; this should never happen\");\n    return user;\n  }\n\n  async listTeamInvitations(\n    options: {\n      teamId: string,\n    },\n    session: InternalSession,\n  ): Promise<TeamInvitationCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      \"/team-invitations?\" + new URLSearchParams({ team_id: options.teamId }),\n      {},\n      session,\n    );\n    const result = await response.json() as TeamInvitationCrud['Client']['List'];\n    return result.items;\n  }\n\n  async revokeTeamInvitation(\n    invitationId: string,\n    teamId: string,\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/team-invitations/${invitationId}?team_id=${teamId}`,\n      { method: \"DELETE\" },\n      session,\n    );\n  }\n\n  async listTeamMemberProfiles(\n    options: {\n      teamId?: string,\n      userId?: string,\n    },\n    session: InternalSession,\n  ): Promise<TeamMemberProfilesCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      \"/team-member-profiles?\" + new URLSearchParams(filterUndefined({\n        team_id: options.teamId,\n        user_id: options.userId,\n      })),\n      {},\n      session,\n    );\n    const result = await response.json() as TeamMemberProfilesCrud['Client']['List'];\n    return result.items;\n  }\n\n  async getTeamMemberProfile(\n    options: {\n      teamId: string,\n      userId: string,\n    },\n    session: InternalSession,\n  ): Promise<TeamMemberProfilesCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      `/team-member-profiles/${options.teamId}/${options.userId}`,\n      {},\n      session,\n    );\n    return await response.json();\n  }\n\n  async leaveTeam(\n    teamId: string,\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/team-memberships/${teamId}/me`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      session,\n    );\n  }\n\n  async updateTeamMemberProfile(\n    options: {\n      teamId: string,\n      userId: string,\n      profile: TeamMemberProfilesCrud['Client']['Update'],\n    },\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/team-member-profiles/${options.teamId}/${options.userId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options.profile),\n      },\n      session,\n    );\n  }\n\n  async updateTeam(\n    options: {\n      teamId: string,\n      data: TeamsCrud['Client']['Update'],\n    },\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/teams/${options.teamId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options.data),\n      },\n      session,\n    );\n  }\n\n  async listCurrentUserTeamPermissions(\n    options: {\n      teamId: string,\n      recursive: boolean,\n    },\n    session: InternalSession\n  ): Promise<TeamPermissionsCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      `/team-permissions?team_id=${options.teamId}&user_id=me&recursive=${options.recursive}`,\n      {},\n      session,\n    );\n    const result = await response.json() as TeamPermissionsCrud['Client']['List'];\n    return result.items;\n  }\n\n  async listCurrentUserProjectPermissions(\n    options: {\n      recursive: boolean,\n    },\n    session: InternalSession\n  ): Promise<ProjectPermissionsCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      `/project-permissions?user_id=me&recursive=${options.recursive}`,\n      {},\n      session,\n    );\n    const result = await response.json() as ProjectPermissionsCrud['Client']['List'];\n    return result.items;\n  }\n\n  async listCurrentUserTeams(session: InternalSession): Promise<TeamsCrud[\"Client\"][\"Read\"][]> {\n    const response = await this.sendClientRequest(\n      \"/teams?user_id=me\",\n      {},\n      session,\n    );\n    const result = await response.json() as TeamsCrud[\"Client\"][\"List\"];\n    return result.items;\n  }\n\n  async getClientProject(): Promise<Result<ClientProjectsCrud['Client']['Read'], KnownErrors[\"ProjectNotFound\"]>> {\n    const responseOrError = await this.sendClientRequestAndCatchKnownError(\"/projects/current\", {}, null, [KnownErrors.ProjectNotFound]);\n    if (responseOrError.status === \"error\") {\n      return Result.error(responseOrError.error);\n    }\n    const response = responseOrError.data;\n    const project: ClientProjectsCrud['Client']['Read'] = await response.json();\n    return Result.ok(project);\n  }\n\n  async updateClientUser(update: CurrentUserCrud[\"Client\"][\"Update\"], session: InternalSession) {\n    await this.sendClientRequest(\n      \"/users/me\",\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(update),\n      },\n      session,\n    );\n  }\n\n  async listProjects(session: InternalSession): Promise<AdminUserProjectsCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\"/internal/projects\", {}, session);\n    if (!response.ok) {\n      throw new Error(\"Failed to list projects: \" + response.status + \" \" + (await response.text()));\n    }\n\n    const json = await response.json() as AdminUserProjectsCrud['Client']['List'];\n    return json.items;\n  }\n\n  async createProject(\n    project: AdminUserProjectsCrud['Client']['Create'],\n    session: InternalSession,\n  ): Promise<AdminUserProjectsCrud['Client']['Read']> {\n    const fetchResponse = await this.sendClientRequest(\n      \"/internal/projects\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(project),\n      },\n      session,\n    );\n    if (!fetchResponse.ok) {\n      throw new Error(\"Failed to create project: \" + fetchResponse.status + \" \" + (await fetchResponse.text()));\n    }\n\n    const json = await fetchResponse.json();\n    return json;\n  }\n\n  async createProviderAccessToken(\n    provider: string,\n    scope: string,\n    session: InternalSession,\n  ): Promise<ConnectedAccountAccessTokenCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      `/connected-accounts/me/${provider}/access-token`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ scope }),\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async createClientTeam(\n    data: TeamsCrud['Client']['Create'],\n    session: InternalSession,\n  ): Promise<TeamsCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      \"/teams\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async deleteTeam(\n    teamId: string,\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/teams/${teamId}`,\n      {\n        method: \"DELETE\",\n      },\n      session,\n    );\n  }\n\n  async deleteCurrentUser(session: InternalSession) {\n    await this.sendClientRequest(\n      \"/users/me\",\n      {\n        method: \"DELETE\",\n      },\n      session,\n    );\n  }\n\n  async createClientContactChannel(\n    data: ContactChannelsCrud['Client']['Create'],\n    session: InternalSession,\n  ): Promise<ContactChannelsCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      \"/contact-channels\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async updateClientContactChannel(\n    id: string,\n    data: ContactChannelsCrud['Client']['Update'],\n    session: InternalSession,\n  ): Promise<ContactChannelsCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      `/contact-channels/me/${id}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async deleteClientContactChannel(\n    id: string,\n    session: InternalSession,\n  ): Promise<void> {\n    await this.sendClientRequest(\n      `/contact-channels/me/${id}`,\n      {\n        method: \"DELETE\",\n      },\n      session,\n    );\n  }\n\n  async deleteSession(\n    sessionId: string,\n    session: InternalSession,\n  ): Promise<void> {\n    await this.sendClientRequest(\n      `/auth/sessions/${sessionId}?user_id=me`,\n      {\n        method: \"DELETE\",\n      },\n      session,\n    );\n  }\n\n  async listSessions(\n    session: InternalSession,\n  ): Promise<SessionsCrud['Client']['List']> {\n    const response = await this.sendClientRequest(\n      \"/auth/sessions?user_id=me\",\n      {\n        method: \"GET\",\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n\n  async listClientContactChannels(\n    session: InternalSession,\n  ): Promise<ContactChannelsCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      \"/contact-channels?user_id=me\",\n      {\n        method: \"GET\",\n      },\n      session,\n    );\n    const json = await response.json() as ContactChannelsCrud['Client']['List'];\n    return json.items;\n  }\n\n  async sendCurrentUserContactChannelVerificationEmail(\n    contactChannelId: string,\n    callbackUrl: string,\n    session: InternalSession,\n  ): Promise<Result<undefined, KnownErrors[\"EmailAlreadyVerified\"]>> {\n    const responseOrError = await this.sendClientRequestAndCatchKnownError(\n      `/contact-channels/me/${contactChannelId}/send-verification-code`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ callback_url: callbackUrl }),\n      },\n      session,\n      [KnownErrors.EmailAlreadyVerified]\n    );\n\n    if (responseOrError.status === \"error\") {\n      return Result.error(responseOrError.error);\n    }\n    return Result.ok(undefined);\n  }\n\n  async cliLogin(\n    loginCode: string,\n    refreshToken: string,\n    session: InternalSession\n  ): Promise<Result<undefined, KnownErrors[\"SchemaError\"]>> {\n    const responseOrError = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/cli/complete\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          login_code: loginCode,\n          refresh_token: refreshToken,\n        }),\n      },\n      session,\n      [KnownErrors.SchemaError]\n    );\n\n    if (responseOrError.status === \"error\") {\n      return Result.error(responseOrError.error);\n    }\n    return Result.ok(undefined);\n  }\n\n  private async _getApiKeyRequestInfo(options: { user_id: string | null } | { team_id: string }) {\n    if (\"user_id\" in options && \"team_id\" in options) {\n      throw new StackAssertionError(\"Cannot specify both user_id and team_id in _getApiKeyRequestInfo\");\n    }\n\n    return {\n      endpoint: \"team_id\" in options ? \"/team-api-keys\" : \"/user-api-keys\",\n      queryParams: new URLSearchParams(filterUndefinedOrNull(options)),\n    };\n  }\n\n  // API Keys CRUD operations\n  listProjectApiKeys(options: { user_id: string }, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'][]>;\n  listProjectApiKeys(options: { team_id: string }, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<TeamApiKeysCrud['Client']['Read'][]>;\n  listProjectApiKeys(options: { user_id: string } | { team_id: string }, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<(UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read'])[]>;\n  async listProjectApiKeys(\n    options: { user_id: string } | { team_id: string },\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<(UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read'])[]> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest as never).bind(this);\n    const { endpoint, queryParams } = await this._getApiKeyRequestInfo(options);\n\n    const response = await sendRequest(\n      `${endpoint}?${queryParams.toString()}`,\n      {\n        method: \"GET\",\n      },\n      session,\n      requestType,\n    );\n    const json = await response.json();\n    return json.items;\n  }\n\n  createProjectApiKey(data: yup.InferType<typeof userApiKeysCreateInputSchema>, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<yup.InferType<typeof userApiKeysCreateOutputSchema>>;\n  createProjectApiKey(data: yup.InferType<typeof teamApiKeysCreateInputSchema>, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<yup.InferType<typeof teamApiKeysCreateOutputSchema>>;\n  createProjectApiKey(data: yup.InferType<typeof userApiKeysCreateInputSchema> | yup.InferType<typeof teamApiKeysCreateInputSchema>, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<yup.InferType<typeof userApiKeysCreateOutputSchema> | yup.InferType<typeof teamApiKeysCreateOutputSchema>>;\n  async createProjectApiKey(\n    data: yup.InferType<typeof userApiKeysCreateInputSchema> | yup.InferType<typeof teamApiKeysCreateInputSchema>,\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<yup.InferType<typeof userApiKeysCreateOutputSchema> | yup.InferType<typeof teamApiKeysCreateOutputSchema>> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest as never).bind(this);\n    const { endpoint } = await this._getApiKeyRequestInfo(data);\n\n    const response = await sendRequest(\n      `${endpoint}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n      requestType,\n    );\n    return await response.json();\n  }\n\n  getProjectApiKey(options: { user_id: string | null }, keyId: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read']>;\n  getProjectApiKey(options: { team_id: string }, keyId: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<TeamApiKeysCrud['Client']['Read']>;\n  getProjectApiKey(options: { user_id: string | null } | { team_id: string }, keyId: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read']>;\n  async getProjectApiKey(\n    options: { user_id: string | null } | { team_id: string },\n    keyId: string,\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read']> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest as never).bind(this);\n    const { endpoint, queryParams } = await this._getApiKeyRequestInfo(options);\n\n    const response = await sendRequest(\n      `${endpoint}/${keyId}?${queryParams.toString()}`,\n      {\n        method: \"GET\",\n      },\n      session,\n      requestType,\n    );\n    return await response.json();\n  }\n\n  updateProjectApiKey(options: { user_id: string }, keyId: string, data: UserApiKeysCrud['Client']['Update'], session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read']>;\n  updateProjectApiKey(options: { team_id: string }, keyId: string, data: TeamApiKeysCrud['Client']['Update'], session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<TeamApiKeysCrud['Client']['Read']>;\n  updateProjectApiKey(options: { user_id: string } | { team_id: string }, keyId: string, data: UserApiKeysCrud['Client']['Update'] | TeamApiKeysCrud['Client']['Update'], session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read']>;\n  async updateProjectApiKey(\n    options: { user_id: string } | { team_id: string },\n    keyId: string,\n    data: UserApiKeysCrud['Client']['Update'] | TeamApiKeysCrud['Client']['Update'],\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read']> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest as never).bind(this);\n    const { endpoint, queryParams } = await this._getApiKeyRequestInfo(options);\n\n    const response = await sendRequest(\n      `${endpoint}/${keyId}?${queryParams.toString()}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n      requestType,\n    );\n    return await response.json();\n  }\n\n  checkProjectApiKey(type: \"user\", apiKey: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | null>;\n  checkProjectApiKey(type: \"team\", apiKey: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<TeamApiKeysCrud['Client']['Read'] | null>;\n  checkProjectApiKey(type: \"user\" | \"team\", apiKey: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read'] | null>;\n  async checkProjectApiKey(type: \"user\" | \"team\", apiKey: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read'] | null> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequestAndCatchKnownError : (this as any).sendServerRequestAndCatchKnownError as never).bind(this);\n    const result = await sendRequest(\n      `/${type}-api-keys/check`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ api_key: apiKey }),\n      },\n      session,\n      [KnownErrors.ApiKeyNotValid]\n    );\n    if (result.status === \"error\") {\n      return null;\n    }\n    return await result.data.json();\n  }\n\n  async listNotificationCategories(\n    session: InternalSession,\n  ): Promise<NotificationPreferenceCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      `/emails/notification-preference/me`,\n      {},\n      session,\n    );\n    const result = await response.json() as NotificationPreferenceCrud['Client']['List'];\n    return result.items;\n  }\n\n  async setNotificationsEnabled(\n    notificationCategoryId: string,\n    enabled: boolean,\n    session: InternalSession,\n  ): Promise<void> {\n    await this.sendClientRequest(\n      `/emails/notification-preference/me/${notificationCategoryId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          enabled,\n        }),\n      },\n      session,\n    );\n  }\n\n  async getOAuthProvider(\n    userId: string,\n    providerId: string,\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\" = \"client\",\n  ): Promise<{\n    id: string,\n    type: string,\n    user_id: string,\n    account_id?: string,\n    email: string,\n    allow_sign_in: boolean,\n    allow_connected_accounts: boolean,\n  }> {\n    const sendRequest = requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest;\n    const response = await sendRequest.call(this,\n      `/oauth-providers/${userId}/${providerId}`,\n      {\n        method: \"GET\",\n      },\n      session,\n      requestType,\n    );\n    return response.json();\n  }\n\n  async listOAuthProviders(\n    options: {\n      user_id?: string,\n    } = {},\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\" = \"client\",\n  ): Promise<{\n    id: string,\n    type: string,\n    user_id: string,\n    account_id?: string,\n    email: string,\n    allow_sign_in: boolean,\n    allow_connected_accounts: boolean,\n  }[]> {\n    const sendRequest = requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest;\n    const queryParams = new URLSearchParams(filterUndefined(options));\n    const response = await sendRequest.call(this,\n      `/oauth-providers${queryParams.toString() ? `?${queryParams.toString()}` : ''}`,\n      {\n        method: \"GET\",\n      },\n      session,\n      requestType,\n    );\n    const result = await response.json();\n    return result.items;\n  }\n\n  async deleteOAuthProvider(\n    userId: string,\n    providerId: string,\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\" = \"client\",\n  ): Promise<{ success: boolean }> {\n    const sendRequest = requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest;\n    const response = await sendRequest.call(this,\n      `/oauth-providers/${userId}/${providerId}`,\n      {\n        method: \"DELETE\",\n      },\n      session,\n      requestType,\n    );\n    return response.json();\n  }\n\n  async getItem(options: {\n    teamId?: string,\n    userId?: string,\n    itemId: string,\n  }, session: InternalSession | null): Promise<ItemCrud['Client']['Read']> {\n    const customerId = options.teamId ?? options.userId;\n    const response = await this.sendClientRequest(\n      `/payments/items/${customerId}/${options.itemId}`,\n      {},\n      session,\n    );\n    return await response.json();\n  }\n\n  async createCheckoutUrl(\n    customer_id: string,\n    offerIdOrInline: string | yup.InferType<typeof inlineOfferSchema>,\n    session: InternalSession | null,\n  ): Promise<string> {\n    const offerBody = typeof offerIdOrInline === \"string\" ?\n      { offer_id: offerIdOrInline } :\n      { inline_offer: offerIdOrInline };\n    const response = await this.sendClientRequest(\n      \"/payments/purchases/create-purchase-url\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ customer_id, ...offerBody }),\n      },\n      session\n    );\n    const { url } = await response.json() as { url: string };\n    return url;\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4911, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/interface/server-interface.ts"],"sourcesContent":["import { KnownErrors } from \"../known-errors\";\nimport { AccessToken, InternalSession, RefreshToken } from \"../sessions\";\nimport { StackAssertionError } from \"../utils/errors\";\nimport { filterUndefined } from \"../utils/objects\";\nimport { Result } from \"../utils/results\";\nimport { urlString } from \"../utils/urls\";\nimport {\n  ClientInterfaceOptions,\n  StackClientInterface\n} from \"./client-interface\";\nimport { ConnectedAccountAccessTokenCrud } from \"./crud/connected-accounts\";\nimport { ContactChannelsCrud } from \"./crud/contact-channels\";\nimport { CurrentUserCrud } from \"./crud/current-user\";\nimport { ItemCrud } from \"./crud/items\";\nimport { NotificationPreferenceCrud } from \"./crud/notification-preferences\";\nimport { ProjectPermissionsCrud } from \"./crud/project-permissions\";\nimport { SessionsCrud } from \"./crud/sessions\";\nimport { TeamInvitationCrud } from \"./crud/team-invitation\";\nimport { TeamMemberProfilesCrud } from \"./crud/team-member-profiles\";\nimport { TeamMembershipsCrud } from \"./crud/team-memberships\";\nimport { TeamPermissionsCrud } from \"./crud/team-permissions\";\nimport { TeamsCrud } from \"./crud/teams\";\nimport { UsersCrud } from \"./crud/users\";\n\nexport type ServerAuthApplicationOptions = (\n  & ClientInterfaceOptions\n  & (\n    | {\n      readonly secretServerKey: string,\n    }\n    | {\n      readonly projectOwnerSession: InternalSession,\n    }\n  )\n);\n\nexport class StackServerInterface extends StackClientInterface {\n  constructor(public override options: ServerAuthApplicationOptions) {\n    super(options);\n  }\n\n  protected async sendServerRequest(path: string, options: RequestInit, session: InternalSession | null, requestType: \"server\" | \"admin\" = \"server\") {\n    return await this.sendClientRequest(\n      path,\n      {\n        ...options,\n        headers: {\n          \"x-stack-secret-server-key\": \"secretServerKey\" in this.options ? this.options.secretServerKey : \"\",\n          ...options.headers,\n        },\n      },\n      session,\n      requestType,\n    );\n  }\n\n  protected async sendServerRequestAndCatchKnownError<E extends typeof KnownErrors[keyof KnownErrors]>(\n    path: string,\n    requestOptions: RequestInit,\n    tokenStoreOrNull: InternalSession | null,\n    errorsToCatch: readonly E[],\n  ): Promise<Result<\n    Response & {\n      usedTokens: {\n        accessToken: AccessToken,\n        refreshToken: RefreshToken | null,\n      } | null,\n    },\n    InstanceType<E>\n  >> {\n    try {\n      return Result.ok(await this.sendServerRequest(path, requestOptions, tokenStoreOrNull));\n    } catch (e) {\n      for (const errorType of errorsToCatch) {\n        if (errorType.isInstance(e)) {\n          return Result.error(e as InstanceType<E>);\n        }\n      }\n      throw e;\n    }\n  }\n\n  async createServerUser(data: UsersCrud['Server']['Create']): Promise<UsersCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      \"/users\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async getServerUserByToken(session: InternalSession): Promise<CurrentUserCrud['Server']['Read'] | null> {\n    const responseOrError = await this.sendServerRequestAndCatchKnownError(\n      \"/users/me\",\n      {},\n      session,\n      [KnownErrors.CannotGetOwnUserWithoutUser],\n    );\n    if (responseOrError.status === \"error\") {\n      if (KnownErrors.CannotGetOwnUserWithoutUser.isInstance(responseOrError.error)) {\n        return null;\n      } else {\n        throw new StackAssertionError(\"Unexpected uncaught error\", { cause: responseOrError.error });\n      }\n    }\n    const response = responseOrError.data;\n    const user: CurrentUserCrud['Server']['Read'] = await response.json();\n    if (!(user as any)) throw new StackAssertionError(\"User endpoint returned null; this should never happen\");\n    return user;\n  }\n\n  async getServerUserById(userId: string): Promise<Result<UsersCrud['Server']['Read']>> {\n    const responseOrError = await this.sendServerRequestAndCatchKnownError(\n      urlString`/users/${userId}`,\n      {},\n      null,\n      [KnownErrors.UserNotFound],\n    );\n    if (responseOrError.status === \"error\") {\n      return Result.error(responseOrError.error);\n    }\n    const user: UsersCrud['Server']['Read'] = await responseOrError.data.json();\n    return Result.ok(user);\n  }\n\n  async listServerTeamInvitations(options: {\n    teamId: string,\n  }): Promise<TeamInvitationCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/team-invitations?team_id=${options.teamId}`,\n      {},\n      null,\n    );\n    const result = await response.json() as TeamInvitationCrud['Server']['List'];\n    return result.items;\n  }\n\n  async revokeServerTeamInvitation(invitationId: string, teamId: string) {\n    await this.sendServerRequest(\n      urlString`/team-invitations/${invitationId}?team_id=${teamId}`,\n      { method: \"DELETE\" },\n      null,\n    );\n  }\n\n  async listServerTeamMemberProfiles(\n    options: {\n      teamId: string,\n    },\n  ): Promise<TeamMemberProfilesCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/team-member-profiles?team_id=${options.teamId}`,\n      {},\n      null,\n    );\n    const result = await response.json() as TeamMemberProfilesCrud['Server']['List'];\n    return result.items;\n  }\n\n  async getServerTeamMemberProfile(\n    options: {\n      teamId: string,\n      userId: string,\n    },\n  ): Promise<TeamMemberProfilesCrud['Client']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/team-member-profiles/${options.teamId}/${options.userId}`,\n      {},\n      null,\n    );\n    return await response.json();\n  }\n\n  async listServerTeamPermissions(\n    options: {\n      userId?: string,\n      teamId?: string,\n      recursive: boolean,\n    },\n    session: InternalSession | null,\n  ): Promise<TeamPermissionsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      `/team-permissions?${new URLSearchParams(filterUndefined({\n        user_id: options.userId,\n        team_id: options.teamId,\n        recursive: options.recursive.toString(),\n      }))}`,\n      {},\n      session,\n    );\n    const result = await response.json() as TeamPermissionsCrud['Server']['List'];\n    return result.items;\n  }\n\n  async listServerProjectPermissions(\n    options: {\n      userId?: string,\n      recursive: boolean,\n    },\n    session: InternalSession | null,\n  ): Promise<ProjectPermissionsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      `/project-permissions?${new URLSearchParams(filterUndefined({\n        user_id: options.userId,\n        recursive: options.recursive.toString(),\n      }))}`,\n      {},\n      session,\n    );\n    const result = await response.json() as ProjectPermissionsCrud['Server']['List'];\n    return result.items;\n  }\n\n  async listServerUsers(options: {\n    cursor?: string,\n    limit?: number,\n    orderBy?: 'signedUpAt',\n    desc?: boolean,\n    query?: string,\n  }): Promise<UsersCrud['Server']['List']> {\n    const searchParams = new URLSearchParams(filterUndefined({\n      cursor: options.cursor,\n      limit: options.limit?.toString(),\n      desc: options.desc?.toString(),\n      ...options.orderBy ? {\n        order_by: {\n          signedUpAt: \"signed_up_at\",\n        }[options.orderBy],\n      } : {},\n      ...options.query ? {\n        query: options.query,\n      } : {},\n    }));\n    const response = await this.sendServerRequest(\"/users?\" + searchParams.toString(), {}, null);\n    return await response.json();\n  }\n\n  async listServerTeams(options?: {\n    userId?: string,\n  }): Promise<TeamsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      `/teams?${new URLSearchParams(filterUndefined({\n        user_id: options?.userId,\n      }))}`,\n      {},\n      null\n    );\n    const result = await response.json() as TeamsCrud['Server']['List'];\n    return result.items;\n  }\n\n  async getServerTeam(teamId: string): Promise<TeamsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      `/teams/${teamId}`,\n      {},\n      null\n    );\n    return await response.json();\n  }\n\n  async listServerTeamUsers(teamId: string): Promise<UsersCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(`/users?team_id=${teamId}`, {}, null);\n    const result = await response.json() as UsersCrud['Server']['List'];\n    return result.items;\n  }\n\n  /* when passing a session, the user will be added to the team */\n  async createServerTeam(data: TeamsCrud['Server']['Create']): Promise<TeamsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      \"/teams\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null\n    );\n    return await response.json();\n  }\n\n  async updateServerTeam(teamId: string, data: TeamsCrud['Server']['Update']): Promise<TeamsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/teams/${teamId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteServerTeam(teamId: string): Promise<void> {\n    await this.sendServerRequest(\n      urlString`/teams/${teamId}`,\n      { method: \"DELETE\" },\n      null,\n    );\n  }\n\n  async addServerUserToTeam(options: {\n    userId: string,\n    teamId: string,\n  }): Promise<TeamMembershipsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/team-memberships/${options.teamId}/${options.userId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async removeServerUserFromTeam(options: {\n    userId: string,\n    teamId: string,\n  }) {\n    await this.sendServerRequest(\n      urlString`/team-memberships/${options.teamId}/${options.userId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async updateServerUser(userId: string, update: UsersCrud['Server']['Update']): Promise<UsersCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/users/${userId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(update),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async createServerProviderAccessToken(\n    userId: string,\n    provider: string,\n    scope: string,\n  ): Promise<ConnectedAccountAccessTokenCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/connected-accounts/${userId}/${provider}/access-token`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ scope }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async createServerUserSession(userId: string, expiresInMillis: number, isImpersonation: boolean): Promise<{ accessToken: string, refreshToken: string }> {\n    const response = await this.sendServerRequest(\n      \"/auth/sessions\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          user_id: userId,\n          expires_in_millis: expiresInMillis,\n          is_impersonation: isImpersonation,\n        }),\n      },\n      null,\n    );\n    const result = await response.json();\n    return {\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    };\n  }\n\n  async leaveServerTeam(\n    options: {\n      teamId: string,\n      userId: string,\n    },\n  ) {\n    await this.sendClientRequest(\n      urlString`/team-memberships/${options.teamId}/${options.userId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async updateServerTeamMemberProfile(options: {\n    teamId: string,\n    userId: string,\n    profile: TeamMemberProfilesCrud['Server']['Update'],\n  }) {\n    await this.sendServerRequest(\n      urlString`/team-member-profiles/${options.teamId}/${options.userId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options.profile),\n      },\n      null,\n    );\n  }\n\n  async grantServerTeamUserPermission(teamId: string, userId: string, permissionId: string) {\n    await this.sendServerRequest(\n      urlString`/team-permissions/${teamId}/${userId}/${permissionId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async grantServerProjectPermission(userId: string, permissionId: string) {\n    await this.sendServerRequest(\n      urlString`/project-permissions/${userId}/${permissionId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async revokeServerTeamUserPermission(teamId: string, userId: string, permissionId: string) {\n    await this.sendServerRequest(\n      urlString`/team-permissions/${teamId}/${userId}/${permissionId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async revokeServerProjectPermission(userId: string, permissionId: string) {\n    await this.sendServerRequest(\n      urlString`/project-permissions/${userId}/${permissionId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async deleteServerUser(userId: string) {\n    await this.sendServerRequest(\n      urlString`/users/${userId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async createServerContactChannel(\n    data: ContactChannelsCrud['Server']['Create'],\n  ): Promise<ContactChannelsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      \"/contact-channels\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateServerContactChannel(\n    userId: string,\n    contactChannelId: string,\n    data: ContactChannelsCrud['Server']['Update'],\n  ): Promise<ContactChannelsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/contact-channels/${userId}/${contactChannelId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteServerContactChannel(\n    userId: string,\n    contactChannelId: string,\n  ): Promise<void> {\n    await this.sendServerRequest(\n      urlString`/contact-channels/${userId}/${contactChannelId}`,\n      {\n        method: \"DELETE\",\n      },\n      null,\n    );\n  }\n\n  async listServerContactChannels(\n    userId: string,\n  ): Promise<ContactChannelsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/contact-channels?user_id=${userId}`,\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    const json = await response.json() as ContactChannelsCrud['Server']['List'];\n    return json.items;\n  }\n\n  async listServerNotificationCategories(\n    userId: string,\n  ): Promise<NotificationPreferenceCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/emails/notification-preference/${userId}`,\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    const json = await response.json() as NotificationPreferenceCrud['Server']['List'];\n    return json.items;\n  }\n\n  async setServerNotificationsEnabled(\n    userId: string,\n    notificationCategoryId: string,\n    enabled: boolean,\n  ): Promise<void> {\n    await this.sendServerRequest(\n      urlString`/emails/notification-preference/${userId}/${notificationCategoryId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          enabled,\n        }),\n      },\n      null,\n    );\n  }\n\n  async sendServerContactChannelVerificationEmail(\n    userId: string,\n    contactChannelId: string,\n    callbackUrl: string,\n  ): Promise<void> {\n    await this.sendServerRequest(\n      urlString`/contact-channels/${userId}/${contactChannelId}/send-verification-code`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ callback_url: callbackUrl }),\n      },\n      null,\n    );\n  }\n\n\n  async listServerSessions(userId: string): Promise<SessionsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/auth/sessions?user_id=${userId}`,\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteServerSession(sessionId: string) {\n    await this.sendServerRequest(\n      urlString`/auth/sessions/${sessionId}`,\n      {\n        method: \"DELETE\",\n      },\n      null,\n    );\n  }\n\n\n  async sendServerTeamInvitation(options: {\n    email: string,\n    teamId: string,\n    callbackUrl: string,\n  }): Promise<void> {\n    await this.sendServerRequest(\n      \"/team-invitations/send-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email: options.email,\n          team_id: options.teamId,\n          callback_url: options.callbackUrl,\n        }),\n      },\n      null,\n    );\n  }\n\n  async updatePassword(\n    options: { oldPassword: string, newPassword: string },\n  ): Promise<KnownErrors[\"PasswordConfirmationMismatch\"] | KnownErrors[\"PasswordRequirementsNotMet\"] | undefined> {\n    const res = await this.sendServerRequestAndCatchKnownError(\n      \"/auth/password/update\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          old_password: options.oldPassword,\n          new_password: options.newPassword,\n        }),\n      },\n      null,\n      [KnownErrors.PasswordConfirmationMismatch, KnownErrors.PasswordRequirementsNotMet]\n    );\n\n    if (res.status === \"error\") {\n      return res.error;\n    }\n  }\n\n  // OAuth Providers CRUD operations\n  async createServerOAuthProvider(\n    data: {\n      user_id: string,\n      provider_config_id: string,\n      account_id: string,\n      email: string,\n      allow_sign_in: boolean,\n      allow_connected_accounts: boolean,\n    },\n  ): Promise<{\n    id: string,\n    type: string,\n    user_id: string,\n    account_id: string,\n    email: string,\n    allow_sign_in: boolean,\n    allow_connected_accounts: boolean,\n  }> {\n    const response = await this.sendServerRequest(\n      \"/oauth-providers\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n\n  async listServerOAuthProviders(\n    options: {\n      user_id?: string,\n    } = {},\n  ): Promise<{\n    id: string,\n    type: string,\n    user_id: string,\n    account_id: string,\n    email: string,\n    allow_sign_in: boolean,\n    allow_connected_accounts: boolean,\n  }[]> {\n    const queryParams = new URLSearchParams(filterUndefined(options));\n    const response = await this.sendServerRequest(\n      `/oauth-providers${queryParams.toString() ? `?${queryParams.toString()}` : ''}`,\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    const result = await response.json();\n    return result.items;\n  }\n\n  async updateServerOAuthProvider(\n    userId: string,\n    providerId: string,\n    data: {\n      account_id?: string,\n      email?: string,\n      allow_sign_in?: boolean,\n      allow_connected_accounts?: boolean,\n    },\n  ): Promise<{\n    id: string,\n    type: string,\n    user_id: string,\n    account_id: string,\n    email: string,\n    allow_sign_in: boolean,\n    allow_connected_accounts: boolean,\n  }> {\n    const response = await this.sendServerRequest(\n      urlString`/oauth-providers/${userId}/${providerId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteServerOAuthProvider(\n    userId: string,\n    providerId: string,\n  ): Promise<{ success: boolean }> {\n    const response = await this.sendServerRequest(\n      urlString`/oauth-providers/${userId}/${providerId}`,\n      {\n        method: \"DELETE\",\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async sendEmail(options: {\n    userIds: string[],\n    themeId?: string | null | false,\n    html?: string,\n    subject?: string,\n    notificationCategoryName?: string,\n    templateId?: string,\n    variables?: Record<string, any>,\n  }): Promise<Result<void, KnownErrors[\"RequiresCustomEmailServer\"] | KnownErrors[\"SchemaError\"] | KnownErrors[\"UserIdDoesNotExist\"]>> {\n    const res = await this.sendServerRequestAndCatchKnownError(\n      \"/emails/send-email\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          user_ids: options.userIds,\n          theme_id: options.themeId,\n          html: options.html,\n          subject: options.subject,\n          notification_category_name: options.notificationCategoryName,\n          template_id: options.templateId,\n          variables: options.variables,\n        }),\n      },\n      null,\n      [KnownErrors.RequiresCustomEmailServer, KnownErrors.SchemaError, KnownErrors.UserIdDoesNotExist]\n    );\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n    return Result.ok(undefined);\n  }\n\n  async updateItemQuantity(\n    customerId: string,\n    itemId: string,\n    data: ItemCrud['Server']['Update'],\n  ): Promise<void> {\n    const queryParams = new URLSearchParams({ allow_negative: (data.allow_negative ?? false).toString() });\n    await this.sendServerRequest(\n      `/payments/items/${customerId}/${itemId}/update-quantity?${queryParams.toString()}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          delta: data.delta,\n          expires_at: data.expires_at,\n          description: data.description,\n        }),\n      },\n      null\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5698, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/interface/admin-interface.ts"],"sourcesContent":["import { InternalSession } from \"../sessions\";\nimport { ConfigCrud, ConfigOverrideCrud } from \"./crud/config\";\nimport { InternalEmailsCrud } from \"./crud/emails\";\nimport { InternalApiKeysCrud } from \"./crud/internal-api-keys\";\nimport { ProjectPermissionDefinitionsCrud } from \"./crud/project-permissions\";\nimport { ProjectsCrud } from \"./crud/projects\";\nimport { SvixTokenCrud } from \"./crud/svix-token\";\nimport { TeamPermissionDefinitionsCrud } from \"./crud/team-permissions\";\nimport { ServerAuthApplicationOptions, StackServerInterface } from \"./server-interface\";\n\nexport type ChatContent = Array<\n  | { type: \"text\", text: string }\n  | { type: \"tool-call\", toolName: string, toolCallId: string, args: any, argsText: string, result: any }\n>;\n\nexport type AdminAuthApplicationOptions = ServerAuthApplicationOptions &(\n  | {\n    superSecretAdminKey: string,\n  }\n  | {\n    projectOwnerSession: InternalSession,\n  }\n);\n\nexport type InternalApiKeyCreateCrudRequest = {\n  has_publishable_client_key: boolean,\n  has_secret_server_key: boolean,\n  has_super_secret_admin_key: boolean,\n  expires_at_millis: number,\n  description: string,\n};\n\nexport type InternalApiKeyCreateCrudResponse = InternalApiKeysCrud[\"Admin\"][\"Read\"] & {\n  publishable_client_key?: string,\n  secret_server_key?: string,\n  super_secret_admin_key?: string,\n};\n\nexport class StackAdminInterface extends StackServerInterface {\n  constructor(public readonly options: AdminAuthApplicationOptions) {\n    super(options);\n  }\n\n  public async sendAdminRequest(path: string, options: RequestInit, session: InternalSession | null, requestType: \"admin\" = \"admin\") {\n    return await this.sendServerRequest(\n      path,\n      {\n        ...options,\n        headers: {\n          \"x-stack-super-secret-admin-key\": \"superSecretAdminKey\" in this.options ? this.options.superSecretAdminKey : \"\",\n          ...options.headers,\n        },\n      },\n      session,\n      requestType,\n    );\n  }\n\n  async getProject(): Promise<ProjectsCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      \"/internal/projects/current\",\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateProject(update: ProjectsCrud[\"Admin\"][\"Update\"]): Promise<ProjectsCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      \"/internal/projects/current\",\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(update),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async createInternalApiKey(\n    options: InternalApiKeyCreateCrudRequest,\n  ): Promise<InternalApiKeyCreateCrudResponse> {\n    const response = await this.sendAdminRequest(\n      \"/internal/api-keys\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async listInternalApiKeys(): Promise<InternalApiKeysCrud[\"Admin\"][\"Read\"][]> {\n    const response = await this.sendAdminRequest(\"/internal/api-keys\", {}, null);\n    const result = await response.json() as InternalApiKeysCrud[\"Admin\"][\"List\"];\n    return result.items;\n  }\n\n  async revokeInternalApiKeyById(id: string) {\n    await this.sendAdminRequest(\n      `/internal/api-keys/${id}`, {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          revoked: true,\n        }),\n      },\n      null,\n    );\n  }\n\n  async getInternalApiKey(id: string, session: InternalSession): Promise<InternalApiKeysCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(`/internal/api-keys/${id}`, {}, session);\n    return await response.json();\n  }\n\n  async listInternalEmailTemplates(): Promise<{ id: string, display_name: string, theme_id?: string, tsx_source: string }[]> {\n    const response = await this.sendAdminRequest(`/internal/email-templates`, {}, null);\n    const result = await response.json() as { templates: { id: string, display_name: string, theme_id?: string, tsx_source: string }[] };\n    return result.templates;\n  }\n\n  async listEmailThemes(): Promise<{ id: string, display_name: string }[]> {\n    const response = await this.sendAdminRequest(`/internal/email-themes`, {}, null);\n    const result = await response.json() as { themes: { id: string, display_name: string }[] };\n    return result.themes;\n  }\n\n\n  // Team permission definitions methods\n  async listTeamPermissionDefinitions(): Promise<TeamPermissionDefinitionsCrud['Admin']['Read'][]> {\n    const response = await this.sendAdminRequest(`/team-permission-definitions`, {}, null);\n    const result = await response.json() as TeamPermissionDefinitionsCrud['Admin']['List'];\n    return result.items;\n  }\n\n  async createTeamPermissionDefinition(data: TeamPermissionDefinitionsCrud['Admin']['Create']): Promise<TeamPermissionDefinitionsCrud['Admin']['Read']> {\n    const response = await this.sendAdminRequest(\n      \"/team-permission-definitions\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateTeamPermissionDefinition(permissionId: string, data: TeamPermissionDefinitionsCrud['Admin']['Update']): Promise<TeamPermissionDefinitionsCrud['Admin']['Read']> {\n    const response = await this.sendAdminRequest(\n      `/team-permission-definitions/${permissionId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteTeamPermissionDefinition(permissionId: string): Promise<void> {\n    await this.sendAdminRequest(\n      `/team-permission-definitions/${permissionId}`,\n      { method: \"DELETE\" },\n      null,\n    );\n  }\n\n  async listProjectPermissionDefinitions(): Promise<ProjectPermissionDefinitionsCrud['Admin']['Read'][]> {\n    const response = await this.sendAdminRequest(`/project-permission-definitions`, {}, null);\n    const result = await response.json() as ProjectPermissionDefinitionsCrud['Admin']['List'];\n    return result.items;\n  }\n\n  async createProjectPermissionDefinition(data: ProjectPermissionDefinitionsCrud['Admin']['Create']): Promise<ProjectPermissionDefinitionsCrud['Admin']['Read']> {\n    const response = await this.sendAdminRequest(\n      \"/project-permission-definitions\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateProjectPermissionDefinition(permissionId: string, data: ProjectPermissionDefinitionsCrud['Admin']['Update']): Promise<ProjectPermissionDefinitionsCrud['Admin']['Read']> {\n    const response = await this.sendAdminRequest(\n      `/project-permission-definitions/${permissionId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteProjectPermissionDefinition(permissionId: string): Promise<void> {\n    await this.sendAdminRequest(\n      `/project-permission-definitions/${permissionId}`,\n      { method: \"DELETE\" },\n      null,\n    );\n  }\n\n  async getSvixToken(): Promise<SvixTokenCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      \"/webhooks/svix-token\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteProject(): Promise<void> {\n    await this.sendAdminRequest(\n      \"/internal/projects/current\",\n      {\n        method: \"DELETE\",\n      },\n      null,\n    );\n  }\n\n  async getMetrics(): Promise<any> {\n    const response = await this.sendAdminRequest(\n      \"/internal/metrics\",\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async sendTestEmail(data: {\n    recipient_email: string,\n    email_config: {\n      host: string,\n      port: number,\n      username: string,\n      password: string,\n      sender_email: string,\n      sender_name: string,\n    },\n  }): Promise<{ success: boolean, error_message?: string }> {\n    const response = await this.sendAdminRequest(`/internal/send-test-email`, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n      body: JSON.stringify(data),\n    }, null);\n    return await response.json();\n  }\n\n  async listSentEmails(): Promise<InternalEmailsCrud[\"Admin\"][\"List\"]> {\n    const response = await this.sendAdminRequest(\"/internal/emails\", {\n      method: \"GET\",\n    }, null);\n    return await response.json();\n  }\n\n  async sendSignInInvitationEmail(\n    email: string,\n    callbackUrl: string,\n  ): Promise<void> {\n    await this.sendAdminRequest(\n      \"/internal/send-sign-in-invitation\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          callback_url: callbackUrl,\n        }),\n      },\n      null,\n    );\n  }\n\n\n  async sendChatMessage(\n    threadId: string,\n    contextType: \"email-theme\" | \"email-template\",\n    messages: Array<{ role: string, content: any }>,\n    abortSignal?: AbortSignal,\n  ): Promise<{ content: ChatContent }> {\n    const response = await this.sendAdminRequest(\n      `/internal/ai-chat/${threadId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ context_type: contextType, messages }),\n        signal: abortSignal,\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async saveChatMessage(threadId: string, message: any): Promise<void> {\n    await this.sendAdminRequest(\n      `/internal/ai-chat/${threadId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ message }),\n      },\n      null,\n    );\n  }\n\n  async listChatMessages(threadId: string): Promise<{ messages: Array<any> }> {\n    const response = await this.sendAdminRequest(\n      `/internal/ai-chat/${threadId}`,\n      { method: \"GET\" },\n      null,\n    );\n    return await response.json();\n  }\n\n  async renderEmailPreview(options: { themeId?: string | null | false, themeTsxSource?: string, templateId?: string, templateTsxSource?: string }): Promise<{ html: string }> {\n    const response = await this.sendAdminRequest(`/emails/render-email`, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        theme_id: options.themeId,\n        theme_tsx_source: options.themeTsxSource,\n        template_id: options.templateId,\n        template_tsx_source: options.templateTsxSource,\n      }),\n    }, null);\n    return await response.json();\n  }\n\n  async createEmailTheme(displayName: string): Promise<{ id: string }> {\n    const response = await this.sendAdminRequest(\n      `/internal/email-themes`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          display_name: displayName,\n        }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async getEmailTheme(id: string): Promise<{ display_name: string, tsx_source: string }> {\n    const response = await this.sendAdminRequest(\n      `/internal/email-themes/${id}`,\n      { method: \"GET\" },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateEmailTheme(id: string, tsxSource: string): Promise<void> {\n    await this.sendAdminRequest(\n      `/internal/email-themes/${id}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          tsx_source: tsxSource,\n        }),\n      },\n      null,\n    );\n  }\n\n  async updateEmailTemplate(id: string, tsxSource: string, themeId: string | null | false): Promise<{ rendered_html: string }> {\n    const response = await this.sendAdminRequest(\n      `/internal/email-templates/${id}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ tsx_source: tsxSource, theme_id: themeId }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async getConfig(): Promise<ConfigCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      `/internal/config`,\n      { method: \"GET\" },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateConfig(data: { configOverride: any }): Promise<ConfigOverrideCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      `/internal/config/override`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ config_override_string: JSON.stringify(data.configOverride) }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n  async createEmailTemplate(displayName: string): Promise<{ id: string }> {\n    const response = await this.sendAdminRequest(\n      `/internal/email-templates`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          display_name: displayName,\n        }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async setupPayments(): Promise<{ url: string }> {\n    const response = await this.sendAdminRequest(\n      \"/internal/payments/setup\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async createStripeWidgetAccountSession(): Promise<{ client_secret: string }> {\n    const response = await this.sendAdminRequest(\n      \"/internal/payments/stripe-widgets/account-session\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async createPurchaseUrl(options: { customer_id: string, offer_id: string }): Promise<string> {\n    const response = await this.sendAdminRequest(\n      \"/payments/purchases/create-purchase-url\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options),\n      },\n      null,\n    );\n    const result = await response.json() as { url: string };\n    return result.url;\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 6041, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/index.ts"],"sourcesContent":["export {\n  StackAdminInterface\n} from \"./interface/admin-interface\";\nexport {\n  StackClientInterface\n} from \"./interface/client-interface\";\nexport {\n  StackServerInterface\n} from \"./interface/server-interface\";\nexport {\n  KnownError,\n  KnownErrors\n} from \"./known-errors\";\n\n"],"names":[],"mappings":";;AAAA;AAGA;AAGA;AAGA","debugId":null}},
    {"offset": {"line": 6067, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/helpers/production-mode.ts"],"sourcesContent":["import { ProjectsCrud } from \"../interface/crud/projects\";\nimport { StackAssertionError, captureError } from \"../utils/errors\";\nimport { isLocalhost } from \"../utils/urls\";\n\nexport type ProductionModeError = {\n  message: string,\n  relativeFixUrl: `/${string}`,\n};\n\nexport function getProductionModeErrors(project: ProjectsCrud[\"Admin\"][\"Read\"]): ProductionModeError[] {\n  const errors: ProductionModeError[] = [];\n  const domainsFixUrl = `/projects/${project.id}/domains` as const;\n\n  if (project.config.allow_localhost) {\n    errors.push({\n      message: \"Localhost is not allowed in production mode, turn off 'Allow localhost' in project settings\",\n      relativeFixUrl: domainsFixUrl,\n    });\n  }\n\n  for (const { domain } of project.config.domains) {\n    let url;\n    try {\n      url = new URL(domain);\n    } catch (e) {\n      captureError(\"production-mode-domain-not-valid\", new StackAssertionError(\"Domain was somehow not a valid URL; we should've caught this when setting the domain in the first place\", {\n        domain,\n        projectId: project\n      }));\n      errors.push({\n        message: \"Trusted domain is not a valid URL: \" + domain,\n        relativeFixUrl: domainsFixUrl,\n      });\n      continue;\n    }\n\n    if (isLocalhost(url)) {\n      errors.push({\n        message: \"Localhost domains are not allowed to be trusted in production mode: \" + domain,\n        relativeFixUrl: domainsFixUrl,\n      });\n    } else if (url.hostname.match(/^\\d+(\\.\\d+)*$/)) {\n      errors.push({\n        message: \"Direct IPs are not valid for trusted domains in production mode: \" + domain,\n        relativeFixUrl: domainsFixUrl,\n      });\n    } else if (url.protocol !== \"https:\") {\n      errors.push({\n        message: \"Trusted domains should be HTTPS: \" + domain,\n        relativeFixUrl: domainsFixUrl,\n      });\n    }\n  }\n\n  return errors;\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,qBAAqB,oBAAoB;AAClD,SAAS,mBAAmB;;;AAOrB,SAAS,wBAAwB,OAAA,EAA+D;IACrG,MAAM,SAAgC,CAAC,CAAA;IACvC,MAAM,gBAAgB,aAAuB,OAAV,QAAQ,EAAE,EAAA;IAE7C,IAAI,QAAQ,MAAA,CAAO,eAAA,EAAiB;QAClC,OAAO,IAAA,CAAK;YACV,SAAS;YACT,gBAAgB;QAClB,CAAC;IACH;IAEA,KAAA,MAAW,EAAE,MAAA,CAAO,CAAA,IAAK,QAAQ,MAAA,CAAO,OAAA,CAAS;QAC/C,IAAI;QACJ,IAAI;YACF,MAAM,IAAI,IAAI,MAAM;QACtB,EAAA,OAAS,GAAG;YACV,CAAA,GAAA,oLAAA,CAAA,eAAA,EAAa,oCAAoC,yLAAI,sBAAA,CAAoB,2GAA2G;gBAClL;gBACA,WAAW;YACb,CAAC,CAAC;YACF,OAAO,IAAA,CAAK;gBACV,SAAS,wCAAwC;gBACjD,gBAAgB;YAClB,CAAC;YACD;QACF;QAEA,2LAAI,cAAA,EAAY,GAAG,GAAG;YACpB,OAAO,IAAA,CAAK;gBACV,SAAS,yEAAyE;gBAClF,gBAAgB;YAClB,CAAC;QACH,OAAA,IAAW,IAAI,QAAA,CAAS,KAAA,CAAM,eAAe,GAAG;YAC9C,OAAO,IAAA,CAAK;gBACV,SAAS,sEAAsE;gBAC/E,gBAAgB;YAClB,CAAC;QACH,OAAA,IAAW,IAAI,QAAA,KAAa,UAAU;YACpC,OAAO,IAAA,CAAK;gBACV,SAAS,sCAAsC;gBAC/C,gBAAgB;YAClB,CAAC;QACH;IACF;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 6124, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/caches.tsx"],"sourcesContent":["import { DependenciesMap } from \"./maps\";\nimport { filterUndefined } from \"./objects\";\nimport { RateLimitOptions, ReactPromise, pending, rateLimited, resolved, runAsynchronously, wait } from \"./promises\";\nimport { AsyncStore } from \"./stores\";\n\n/**\n * Can be used to cache the result of a function call, for example for the `use` hook in React.\n */\nexport function cacheFunction<F extends Function>(f: F): F {\n  const dependenciesMap = new DependenciesMap<any, any>();\n\n  return ((...args: any) => {\n    if (dependenciesMap.has(args)) {\n      return dependenciesMap.get(args);\n    }\n\n    const value = f(...args);\n    dependenciesMap.set(args, value);\n    return value;\n  }) as any as F;\n}\nundefined?.test(\"cacheFunction\", ({ expect }) => {\n  // Test with a simple function\n  let callCount = 0;\n  const add = (a: number, b: number) => {\n    callCount++;\n    return a + b;\n  };\n\n  const cachedAdd = cacheFunction(add);\n\n  // First call should execute the function\n  expect(cachedAdd(1, 2)).toBe(3);\n  expect(callCount).toBe(1);\n\n  // Second call with same args should use cached result\n  expect(cachedAdd(1, 2)).toBe(3);\n  expect(callCount).toBe(1);\n\n  // Call with different args should execute the function again\n  expect(cachedAdd(2, 3)).toBe(5);\n  expect(callCount).toBe(2);\n\n  // Test with a function that returns objects\n  let objectCallCount = 0;\n  const createObject = (id: number) => {\n    objectCallCount++;\n    return { id };\n  };\n\n  const cachedCreateObject = cacheFunction(createObject);\n\n  // First call should execute the function\n  const obj1 = cachedCreateObject(1);\n  expect(obj1).toEqual({ id: 1 });\n  expect(objectCallCount).toBe(1);\n\n  // Second call with same args should use cached result\n  const obj2 = cachedCreateObject(1);\n  expect(obj2).toBe(obj1); // Same reference\n  expect(objectCallCount).toBe(1);\n});\n\n\ntype CacheStrategy = \"write-only\" | \"read-write\" | \"never\";\n\nexport class AsyncCache<D extends any[], T> {\n  private readonly _map = new DependenciesMap<D, AsyncValueCache<T>>();\n\n  constructor(\n    private readonly _fetcher: (dependencies: D) => Promise<T>,\n    private readonly _options: {\n      onSubscribe?: (key: D, refresh: () => void) => (() => void),\n      rateLimiter?: Omit<RateLimitOptions, \"batchCalls\">,\n    } = {},\n  ) {\n    // nothing here yet\n  }\n\n  private _createKeyed<FunctionName extends keyof AsyncValueCache<T>>(\n    functionName: FunctionName,\n  ): (key: D, ...args: Parameters<AsyncValueCache<T>[FunctionName]>) => ReturnType<AsyncValueCache<T>[FunctionName]> {\n    return (key: D, ...args) => {\n      const valueCache = this.getValueCache(key);\n      return (valueCache[functionName] as any).apply(valueCache, args);\n    };\n  }\n\n  getValueCache(dependencies: D): AsyncValueCache<T> {\n    let cache = this._map.get(dependencies);\n    if (!cache) {\n      cache = new AsyncValueCache(\n        async () => await this._fetcher(dependencies),\n        {\n          ...this._options,\n          onSubscribe: this._options.onSubscribe ? (cb) => this._options.onSubscribe!(dependencies, cb) : undefined,\n        },\n      );\n      this._map.set(dependencies, cache);\n    }\n    return cache;\n  }\n\n  async refreshWhere(predicate: (dependencies: D) => boolean) {\n    const promises: Promise<T>[] = [];\n    for (const [dependencies, cache] of this._map) {\n      if (predicate(dependencies)) {\n        promises.push(cache.refresh());\n      }\n    }\n    await Promise.all(promises);\n  }\n\n  readonly isCacheAvailable = this._createKeyed(\"isCacheAvailable\");\n  readonly getIfCached = this._createKeyed(\"getIfCached\");\n  readonly getOrWait = this._createKeyed(\"getOrWait\");\n  readonly forceSetCachedValue = this._createKeyed(\"forceSetCachedValue\");\n  readonly forceSetCachedValueAsync = this._createKeyed(\"forceSetCachedValueAsync\");\n  readonly refresh = this._createKeyed(\"refresh\");\n  readonly invalidate = this._createKeyed(\"invalidate\");\n  readonly onStateChange = this._createKeyed(\"onStateChange\");\n}\n\nclass AsyncValueCache<T> {\n  private _store: AsyncStore<T>;\n  private _pendingPromise: ReactPromise<T> | undefined;\n  private _fetcher: () => Promise<T>;\n  private readonly _rateLimitOptions: Omit<RateLimitOptions, \"batchCalls\">;\n  private _subscriptionsCount = 0;\n  private _unsubscribers: (() => void)[] = [];\n  private _mostRecentRefreshPromiseIndex = 0;\n\n  constructor(\n    fetcher: () => Promise<T>,\n    private readonly _options: {\n      onSubscribe?: (refresh: () => void) => (() => void),\n      rateLimiter?: Omit<RateLimitOptions, \"batchCalls\">,\n    } = {},\n  ) {\n    this._store = new AsyncStore();\n    this._rateLimitOptions = {\n      concurrency: 1,\n      throttleMs: 300,\n      ...filterUndefined(_options.rateLimiter ?? {}),\n    };\n\n\n    this._fetcher = rateLimited(fetcher, {\n      ...this._rateLimitOptions,\n      batchCalls: true,\n    });\n  }\n\n  isCacheAvailable(): boolean {\n    return this._store.isAvailable();\n  }\n\n  getIfCached() {\n    return this._store.get();\n  }\n\n  getOrWait(cacheStrategy: CacheStrategy): ReactPromise<T> {\n    const cached = this.getIfCached();\n    if (cacheStrategy === \"read-write\" && cached.status === \"ok\") {\n      return resolved(cached.data);\n    }\n\n    return this._refetch(cacheStrategy);\n  }\n\n  private _set(value: T): void {\n    this._store.set(value);\n  }\n\n  private _setAsync(value: Promise<T>): ReactPromise<boolean> {\n    const promise = pending(value);\n    this._pendingPromise = promise;\n    return pending(this._store.setAsync(promise));\n  }\n\n  private _refetch(cacheStrategy: CacheStrategy): ReactPromise<T> {\n    if (cacheStrategy === \"read-write\" && this._pendingPromise) {\n      return this._pendingPromise;\n    }\n    const promise = pending(this._fetcher());\n    if (cacheStrategy === \"never\") {\n      return promise;\n    }\n    return pending(this._setAsync(promise).then(() => promise));\n  }\n\n  forceSetCachedValue(value: T): void {\n    this._set(value);\n  }\n\n  forceSetCachedValueAsync(value: Promise<T>): ReactPromise<boolean> {\n    return this._setAsync(value);\n  }\n\n  /**\n   * Refetches the value from the fetcher, and updates the cache with it.\n   */\n  async refresh(): Promise<T> {\n    return await this.getOrWait(\"write-only\");\n  }\n\n  /**\n   * Invalidates the cache, marking it to refresh on the next read. If anyone was listening to it, it will refresh\n   * immediately.\n   */\n  invalidate(): void {\n    this._store.setUnavailable();\n    this._pendingPromise = undefined;\n    if (this._subscriptionsCount > 0) {\n      runAsynchronously(this.refresh());\n    }\n  }\n\n  onStateChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    const storeObj = this._store.onChange(callback);\n\n    runAsynchronously(this.getOrWait(\"read-write\"));\n\n    if (this._subscriptionsCount++ === 0 && this._options.onSubscribe) {\n      const unsubscribe = this._options.onSubscribe(() => {\n        runAsynchronously(this.refresh());\n      });\n      this._unsubscribers.push(unsubscribe);\n    }\n\n    let hasUnsubscribed = false;\n    return {\n      unsubscribe: () => {\n        if (hasUnsubscribed) return;\n        hasUnsubscribed = true;\n        storeObj.unsubscribe();\n        if (--this._subscriptionsCount === 0) {\n          const currentRefreshPromiseIndex = ++this._mostRecentRefreshPromiseIndex;\n          runAsynchronously(async () => {\n            // wait a few seconds; if anything changes during that time, we don't want to refresh\n            // else we do unnecessary requests if we unsubscribe and then subscribe again immediately\n            await wait(5000);\n            if (this._subscriptionsCount === 0 && currentRefreshPromiseIndex === this._mostRecentRefreshPromiseIndex) {\n              this.invalidate();\n            }\n          });\n\n          for (const unsubscribe of this._unsubscribers) {\n            unsubscribe();\n          }\n        }\n      },\n    };\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 6303, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/env.tsx"],"sourcesContent":["import { throwErr } from \"./errors\";\nimport { deindent } from \"./strings\";\n\nexport function isBrowserLike() {\n  return typeof window !== \"undefined\" && typeof document !== \"undefined\" && typeof document.createElement !== \"undefined\";\n}\n\n// newName: oldName\nconst ENV_VAR_RENAME: Record<string, string[]> = {\n  NEXT_PUBLIC_STACK_API_URL: ['STACK_BASE_URL', 'NEXT_PUBLIC_STACK_URL'],\n};\n\n/**\n * Returns the environment variable with the given name, returning the default (if given) or throwing an error (otherwise) if it's undefined or the empty string.\n */\nexport function getEnvVariable(name: string, defaultValue?: string | undefined): string {\n  if (isBrowserLike()) {\n    throw new Error(deindent`\n      Can't use getEnvVariable on the client because Next.js transpiles expressions of the kind process.env.XYZ at build-time on the client.\n    \n      Use process.env.XYZ directly instead.\n    `);\n  }\n  if (name === \"NEXT_RUNTIME\") {\n    throw new Error(deindent`\n      Can't use getEnvVariable to access the NEXT_RUNTIME environment variable because it's compiled into the client bundle.\n    \n      Use getNextRuntime() instead.\n    `);\n  }\n\n  // throw error if the old name is used as the retrieve key\n  for (const [newName, oldNames] of Object.entries(ENV_VAR_RENAME)) {\n    if (oldNames.includes(name)) {\n      throwErr(`Environment variable ${name} has been renamed to ${newName}. Please update your configuration to use the new name.`);\n    }\n  }\n\n  let value = process.env[name];\n\n  // check the key under the old name if the new name is not found\n  if (!value && ENV_VAR_RENAME[name] as any) {\n    for (const oldName of ENV_VAR_RENAME[name]) {\n      value = process.env[oldName];\n      if (value) break;\n    }\n  }\n\n  if (value === undefined) {\n    if (defaultValue !== undefined) {\n      value = defaultValue;\n    } else {\n      throwErr(`Missing environment variable: ${name}`);\n    }\n  }\n\n  return value;\n}\n\nexport function getNextRuntime() {\n  // This variable is compiled into the client bundle, so we can't use getEnvVariable here.\n  return process.env.NEXT_RUNTIME || throwErr(\"Missing environment variable: NEXT_RUNTIME\");\n}\n\nexport function getNodeEnvironment() {\n  return getEnvVariable(\"NODE_ENV\", \"\");\n}\n"],"names":[],"mappings":";;;;;;;AAsCc;;AAtCd,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;;;;;;;;;;;;;;;;;;;;;;AAElB,SAAS,gBAAgB;IAC9B,OAAO,OAAO,WAAW,eAAe,OAAO,aAAa,eAAe,OAAO,SAAS,aAAA,KAAkB;AAC/G;AAGA,IAAM,iBAA2C;IAC/C,2BAA2B;QAAC;QAAkB,uBAAuB;KAAA;AACvE;AAKO,SAAS,eAAe,IAAA,EAAc,YAAA,EAA2C;IACtF,IAAI,cAAc,GAAG;QACnB,MAAM,IAAI,gMAAM,WAAA;IAKlB;IACA,IAAI,SAAS,gBAAgB;QAC3B,MAAM,IAAI,MAAM,qMAAA;IAKlB;IAGA,KAAA,MAAW,CAAC,SAAS,QAAQ,CAAA,IAAK,OAAO,OAAA,CAAQ,cAAc,EAAG;QAChE,IAAI,SAAS,QAAA,CAAS,IAAI,GAAG;YAC3B,CAAA,GAAA,oLAAA,CAAA,WAAA,EAAS,+BAAwB,IAAI,EAAA,yBAA+B,OAAP,OAAO,EAAA,wDAAyD;QAC/H;IACF;IAEA,IAAI,mLAAQ,CAAQ,GAAA,CAAI,IAAI,CAAA;IAG5B,IAAI,CAAC,SAAS,cAAA,CAAe,IAAI,CAAA,EAAU;QACzC,KAAA,MAAW,WAAW,cAAA,CAAe,IAAI,CAAA,CAAG;YAC1C,wKAAQ,WAAA,CAAQ,GAAA,CAAI,OAAO,CAAA;YAC3B,IAAI,MAAO,CAAA;QACb;IACF;IAEA,IAAI,UAAU,KAAA,GAAW;QACvB,IAAI,iBAAiB,KAAA,GAAW;YAC9B,QAAQ;QACV,OAAO;YACL,CAAA,GAAA,oLAAA,CAAA,WAAA,EAAS,iCAAqC,CAAE,MAAN,IAAI;QAChD;IACF;IAEA,OAAO;AACT;AAEO,SAAS,iBAAiB;IAE/B,OAAO,QAAQ,IAAI,qNAAgB,WAAA,EAAS,4CAA4C;AAC1F;AAEO,SAAS,qBAAqB;IACnC,OAAO,eAAe,YAAY,EAAE;AACtC","debugId":null}},
    {"offset": {"line": 6384, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsawhney/Desktop/Orientation-Site-GR/node_modules/%40stackframe/stack-shared/src/utils/react.tsx"],"sourcesContent":["import React, { SetStateAction } from \"react\";\nimport { isBrowserLike } from \"./env\";\nimport { neverResolve } from \"./promises\";\nimport { deindent } from \"./strings\";\n\nexport function componentWrapper<\n  C extends React.ComponentType<any> | keyof React.JSX.IntrinsicElements,\n  ExtraProps extends {} = {}\n>(displayName: string, render: React.ForwardRefRenderFunction<RefFromComponent<C>, React.ComponentPropsWithRef<C> & ExtraProps>) {\n  const Component = forwardRefIfNeeded(render);\n  Component.displayName = displayName;\n  return Component;\n}\ntype RefFromComponent<C extends React.ComponentType<any> | keyof React.JSX.IntrinsicElements> = NonNullable<RefFromComponentDistCond<React.ComponentPropsWithRef<C>[\"ref\"]>>;\ntype RefFromComponentDistCond<A> = A extends React.RefObject<infer T> ? T : never;  // distributive conditional type; see https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n\nexport function forwardRefIfNeeded<T, P = {}>(render: React.ForwardRefRenderFunction<T, P>): React.FC<P & { ref?: React.Ref<T> }> {\n  // TODO: when we drop support for react 18, remove this\n\n  const version = React.version;\n  const major = parseInt(version.split(\".\")[0]);\n  if (major < 19) {\n    return React.forwardRef<T, P>(render as any) as any;\n  } else {\n    return ((props: P) => render(props, (props as any).ref)) as any;\n  }\n}\n\nexport function getNodeText(node: React.ReactNode): string {\n  if ([\"number\", \"string\"].includes(typeof node)) {\n    return `${node}`;\n  }\n  if (!node) {\n    return \"\";\n  }\n  if (Array.isArray(node)) {\n    return node.map(getNodeText).join(\"\");\n  }\n  if (typeof node === \"object\" && \"props\" in node) {\n    return getNodeText(node.props.children);\n  }\n  throw new Error(`Unknown node type: ${typeof node}`);\n}\nundefined?.test(\"getNodeText\", ({ expect }) => {\n  // Test with string\n  expect(getNodeText(\"hello\")).toBe(\"hello\");\n\n  // Test with number\n  expect(getNodeText(42)).toBe(\"42\");\n\n  // Test with null/undefined\n  expect(getNodeText(null)).toBe(\"\");\n  expect(getNodeText(undefined)).toBe(\"\");\n\n  // Test with array\n  expect(getNodeText([\"hello\", \" \", \"world\"])).toBe(\"hello world\");\n  expect(getNodeText([1, 2, 3])).toBe(\"123\");\n\n  // Test with mixed array\n  expect(getNodeText([\"hello\", 42, null])).toBe(\"hello42\");\n\n  // Test with React element (mocked)\n  const mockElement = {\n    props: {\n      children: \"child text\"\n    }\n  } as React.ReactElement;\n  expect(getNodeText(mockElement)).toBe(\"child text\");\n\n  // Test with nested React elements\n  const nestedElement = {\n    props: {\n      children: {\n        props: {\n          children: \"nested text\"\n        }\n      } as React.ReactElement\n    }\n  } as React.ReactElement;\n  expect(getNodeText(nestedElement)).toBe(\"nested text\");\n\n  // Test with array of React elements\n  const arrayOfElements = [\n    { props: { children: \"first\" } } as React.ReactElement,\n    { props: { children: \"second\" } } as React.ReactElement\n  ];\n  expect(getNodeText(arrayOfElements)).toBe(\"firstsecond\");\n});\n\n/**\n * Suspends the currently rendered component indefinitely. Will not unsuspend unless the component rerenders.\n *\n * You can use this to translate older query- or AsyncResult-based code to new the Suspense system, for example: `if (query.isLoading) suspend();`\n */\nexport function suspend(): never {\n  React.use(neverResolve());\n  throw new Error(\"Somehow a Promise that never resolves was resolved?\");\n}\n\nexport function mapRef<T, R>(ref: ReadonlyRef<T>, mapper: (value: T) => R): ReadonlyRef<R> {\n  let last: [T, R] | null = null;\n  return {\n    get current() {\n      const input = ref.current;\n      if (last === null || input !== last[0]) {\n        last = [input, mapper(input)];\n      }\n      return last[1];\n    },\n  };\n}\n\nexport type ReadonlyRef<T> = {\n  readonly current: T,\n};\n\nexport type RefState<T> = ReadonlyRef<T> & {\n  set: (updater: SetStateAction<T>) => void,\n};\n\n/**\n * Like useState, but its value is immediately available on refState.current after being set.\n *\n * Like useRef, but setting the value will cause a rerender.\n *\n * Note that useRefState returns a new object every time a rerender happens due to a value change, which is intentional\n * as it allows you to specify it in a dependency array like this:\n *\n * ```tsx\n * useEffect(() => {\n *   // do something with refState.current\n * }, [refState]);  // instead of refState.current\n * ```\n *\n * If you don't want this, you can wrap the result in a useMemo call.\n */\nexport function useRefState<T>(initialValue: T): RefState<T> {\n  const [, setState] = React.useState(initialValue);\n  const ref = React.useRef(initialValue);\n  const setValue = React.useCallback((updater: SetStateAction<T>) => {\n    const value: T = typeof updater === \"function\" ? (updater as any)(ref.current) : updater;\n    setState(value);\n    ref.current = value;\n  }, []);\n  const res = React.useMemo(() => ({\n    current: ref.current,\n    set: setValue,\n  }), [ref.current, setValue]);\n  return res;\n}\n\nexport function mapRefState<T, R>(refState: RefState<T>, mapper: (value: T) => R, reverseMapper: (oldT: T, newR: R) => T): RefState<R> {\n  let last: [T, R] | null = null;\n  return {\n    get current() {\n      const input = refState.current;\n      if (last === null || input !== last[0]) {\n        last = [input, mapper(input)];\n      }\n      return last[1];\n    },\n    set(updater: SetStateAction<R>) {\n      const value: R = typeof updater === \"function\" ? (updater as any)(this.current) : updater;\n      refState.set(reverseMapper(refState.current, value));\n    },\n  };\n}\n\nexport class NoSuspenseBoundaryError extends Error {\n  digest: string;\n  reason: string;\n\n  constructor(options: { caller?: string }) {\n    super(deindent`\n      ${options.caller ?? \"This code path\"} attempted to display a loading indicator, but didn't find a Suspense boundary above it. Please read the error message below carefully.\n      \n      The fix depends on which of the 3 scenarios caused it:\n      \n      1. You are missing a loading.tsx file in your app directory. Fix it by adding a loading.tsx file in your app directory.\n\n      2. The component is rendered in the root (outermost) layout.tsx or template.tsx file. Next.js does not wrap those files in a Suspense boundary, even if there is a loading.tsx file in the same folder. To fix it, wrap your layout inside a route group like this:\n\n        - app\n        - - layout.tsx  // contains <html> and <body>, alongside providers and other components that don't need ${options.caller ?? \"this code path\"}\n        - - loading.tsx  // required for suspense\n        - - (main)\n        - - - layout.tsx  // contains the main layout of your app, like a sidebar or a header, and can use ${options.caller ?? \"this code path\"}\n        - - - route.tsx  // your actual main page\n        - - - the rest of your app\n\n        For more information on this approach, see Next's documentation on route groups: https://nextjs.org/docs/app/building-your-application/routing/route-groups\n      \n      3. You caught this error with try-catch or a custom error boundary. Fix this by rethrowing the error or not catching it in the first place.\n\n      See: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\n\n      More information on SSR and Suspense boundaries: https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content\n    `);\n\n    this.name = \"NoSuspenseBoundaryError\";\n    this.reason = options.caller ?? \"suspendIfSsr()\";\n\n    // set the digest so nextjs doesn't log the error\n    // https://github.com/vercel/next.js/blob/d01d6d9c35a8c2725b3d74c1402ab76d4779a6cf/packages/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts#L14\n    this.digest = \"BAILOUT_TO_CLIENT_SIDE_RENDERING\";\n  }\n}\nundefined?.test(\"NoSuspenseBoundaryError\", ({ expect }) => {\n  // Test with default options\n  const defaultError = new NoSuspenseBoundaryError({});\n  expect(defaultError.name).toBe(\"NoSuspenseBoundaryError\");\n  expect(defaultError.reason).toBe(\"suspendIfSsr()\");\n  expect(defaultError.digest).toBe(\"BAILOUT_TO_CLIENT_SIDE_RENDERING\");\n  expect(defaultError.message).toContain(\"This code path attempted to display a loading indicator\");\n\n  // Test with custom caller\n  const customError = new NoSuspenseBoundaryError({ caller: \"CustomComponent\" });\n  expect(customError.name).toBe(\"NoSuspenseBoundaryError\");\n  expect(customError.reason).toBe(\"CustomComponent\");\n  expect(customError.digest).toBe(\"BAILOUT_TO_CLIENT_SIDE_RENDERING\");\n  expect(customError.message).toContain(\"CustomComponent attempted to display a loading indicator\");\n\n  // Verify error message contains all the necessary information\n  expect(customError.message).toContain(\"loading.tsx\");\n  expect(customError.message).toContain(\"route groups\");\n  expect(customError.message).toContain(\"https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\");\n});\n\n\n/**\n * Use this in a component or a hook to disable SSR. Should be wrapped in a Suspense boundary, or it will throw an error.\n */\nexport function suspendIfSsr(caller?: string) {\n  if (!isBrowserLike()) {\n    throw new NoSuspenseBoundaryError({ caller });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}